<!DOCTYPE html>
<html lang="zh-hant">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">

        <link rel="shortcut icon" type="image/x-ico" href="http://alrightchiu.github.io/SecondRound/fig/favicon.ico" />


        <title>Binary Tree: Traversal(尋訪)</title>

            <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Full Atom Feed" />
            <link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="http://alrightchiu.github.io/SecondRound/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="C++" />
        <meta name="tags" contents="Binary Tree" />


	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Second Round">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html">
	<meta property="og:title" content="Binary Tree: Traversal(尋訪)">
	<meta property="og:description" content="">
	<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/">
	<meta property="article:published_time" content="2015-12-24 22:41:00+08:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://alrightchiu.github.io/SecondRound/">Second Round</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                        <li><a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a></li>
                        <li><a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a></li>

                            <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html">About</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('http://alrightchiu.github.io/SecondRound/theme/images/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Binary Tree: Traversal(尋訪)</h1>
                        <span class="meta">Posted by
                                <a href="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">Chiu CC</a>
                             on 12 24, 2015
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p></br></p>
<h3>先備知識與注意事項</h3>
<p>在Linked list與Tree中的traversal中對於pointer的操作，在概念上完全相同，不過由於Node的pointer增加了，於是從一維的移動拓展到二維的移動。<br />
建議讀者可以先閱讀<a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html#print">Linked List: 新增資料、刪除資料、反轉</a>作簡單複習。  </p>
<p>本篇文章將介紹在Binary Tree中的四種traversal方法。  </p>
<p>程式實作的部分，除了<strong>遞迴(recursion)</strong>，還有可能會使用上Stack(堆疊)與Queue(佇列)，如果不太熟悉，請參考：</p>
<ul>
<li><a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html">Stack: Intro(簡介)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html">Queue: Intro(簡介)，並以Linked list實作</a></li>
</ul>
<hr />
<h2>目錄</h2>
<ul>
<li><a href="#bttraversal">Traversal in Binary Tree</a></li>
<li><a href="#ex_code">Example with Code</a><ul>
<li><a href="#pre">Pre-Order Traversal</a></li>
<li><a href="#in">In-Order Traversal</a></li>
<li><a href="#post">Post-Order Traversal</a></li>
<li><a href="#level">Level-Order Traversal</a></li>
</ul>
</li>
<li><a href="#in_parent">In-Order Traversal by Parent Field</a><ul>
<li><a href="#successor">Successor、leftmost</a></li>
<li><a href="#predecessor">Predecessor、rightmost</a></li>
</ul>
</li>
<li><a href="#ref">參考資料</a></li>
<li><a href="#tree_series">Binary Tree系列文章</a></li>
</ul>
<p></br></p>
<p><a name="bttraversal"></a></p>
<h2>Traversal in Binary Tree</h2>
<p>Traversal(尋訪)有「站在A地，往所有與A地相連的地方移動」的意思：  </p>
<ul>
<li>以Graph(圖)的語言來說，站在vertex(A)上，有一條edge連結vertex(A)與vertex(B)，若能夠由A往B移動，此即可視為traversal；</li>
<li>在以pointer實現之Linked list和Tree中，站在node(A)上，並且node(A)具有指向node(B)之pointer，便能夠由A往B移動，此即可視為traversal。</li>
</ul>
<p>移動到特定的node之後，通常伴隨著其他行為，例如print out(顯示資料)、assign(賦值)、刪除資料等等，這些操作又稱作<strong>Visiting</strong>。</p>
<p>Binary Tree的Node具有兩個指向child的pointer，traversal以「當前所在的node」為參考點，所能夠進行的行為有三種：</p>
<ul>
<li><strong>V</strong>：Visiting，對當前所在的node進行print、assign或其他操作。</li>
<li><strong>L</strong>：移動到left child。</li>
<li><strong>R</strong>：移動到right child。</li>
</ul>
<p><center>
<img alt="VLR" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f1.png?raw=true" /></p>
<p><strong>圖一：CurrentNode位在A，leftchild與rightchild分別為B與C。</strong><br />
</center>   </p>
<p>以圖一為例，假設現在CurrentNode位在A，leftchild與rightchild分別為B與C，並加上一項限制：「L一定在R之前」，便能產生三種相對關係：</p>
<p><center>
<img alt="VLR_pre" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f2.png?raw=true" />  </p>
<p><strong>圖二(a)-(c) 依序為： (a)pre-order：VLR、(b)in-order：LVR、(c)post-order：LRV</strong>
</center></p>
<p><strong>pre-order(VLR)</strong>：當CurrentNode移動到A時，會先對A進行Visiting，接著前往left child進行Visiting，再前往right child進行Visiting。(若child指向NULL則忽略。)</p>
<p><strong>in-order(LVR)</strong>：當CurrentNode移動到A時，會先對A的left child(B)進行Visiting，接著回到A進行Visiting，再前往right child(C)進行Visiting。(若child指向NULL則忽略。)</p>
<p><strong>post-order(LRV)</strong>：當CurrentNode移動到A時，會先對A的left child(B)進行Visiting，再前往right child(C)進行Visiting，接著回到A進行Visiting。(若child指向NULL則忽略。)</p>
<p></br><br />
小小備註：</p>
<ol>
<li>以下圖例中，V表示CurrentNode所在的node，標上數字後表示已經Visiting完成，以print(顯示資料)為例，標上「<span class="math">\(1\)</span>」表示該node第一個被印出。</li>
<li>以下文字說明，將使用scope(視野範圍)的概念，用來表示以每個CurrentNode(也就是V)為中心，與其所能夠指向之pointer所構成的範圍(等同於「迴圈」或者「函式呼叫」的scope)。因為每個迴圈都會改變CurrentNode(V)的位置，因此scope會以CurrentNode(V)為中心不停移動，直到迴圈/函式結束。</li>
</ol>
<p>現有一棵樹如圖三(a)，欲進行post-order traversal，並將Visiting用作print(顯示資料)，流程如下：</p>
<p><center>
<img alt="bt_a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f5.png?raw=true" /></p>
<p><strong>圖三(a)</strong><br />
</center>   </p>
<p>一開始，CurrentNode進到A(root)，按照post-order的順序規則(LRV)，先檢查left child：B是否為NULL，若不是，則先將CurrentNode移動到B(L)：</p>
<p><center>
<img alt="bt_b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f6.png?raw=true" /></p>
<p><strong>圖三(b)：scope內：A(V)、B(L)、C(R)。</strong><br />
</center></p>
<p>當CurrentNode移動到B，再一次執行post-order的順序規則(LRV)，檢查left child：D是否為NULL，若不是，則將CurrentNode移動到D(L)：</p>
<p><center>
<img alt="bt_c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f7.png?raw=true" /></p>
<p><strong>圖三(c)：scope內：B(V)、D(L)、E(R)。</strong><br />
</center></p>
<p>當CurrentNode移動到D，再一次執行post-order的順序規則(LRV)，檢查出D的left child與right child皆為NULL，表示「LRV」的「L」與「R」都已經執行完畢，便「回到D」做Visiting，在此即印出D(print)。</p>
<p>接著，由於「以D為CurrentNode」形成的scope內之node已經全數Visiting完畢，便可回到「以D之parent作為CurrentNode之scope」，於是將CurrentNode移回B。</p>
<p>回到B的動作發生，即表示：以D為CurrentNode之迴圈或函式已經結束。</p>
<p><center>
<img alt="bt_d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f8.png?raw=true" /></p>
<p><strong>圖三(d)：scope內：D(V)。</strong><br />
</center></p>
<p>D已經進行過Visiting，便標上數字「<span class="math">\(1\)</span>」，表示D為post-order traversal的第一站。<br />
接著，在「以B為CurrentNode」的scope中，根據post-order規則，繼續往E(R)移動。</p>
<p><center>
<img alt="bt_e" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f9.png?raw=true" /></p>
<p><strong>圖三(e)：scope內：B(V)、D(L)、E(R)。</strong><br />
</center></p>
<p>進入E後，因為E為leaf node，因此過程如圖三(d)，不會進入NULL。<br />
在D(L)與E(R)都Visiting過後，便回到B(V)進行Visiting，並標上數字。如此便完成「以B為CurrentNode之scope」內的所有node之Visiting。</p>
<p>接著回到「以A為CurrentNode」的scope。</p>
<p><center>
<img alt="bt_f" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f10.png?raw=true" /></p>
<p><strong>圖三(f)：scope內：B(V)、D(L)、E(R)。</strong><br />
</center></p>
<p>回到「以A為CurrentNode」的scope後，按照post-order的規則，接著往C(R)移動。</p>
<p><center>
<img alt="bt_g" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f11.png?raw=true" /></p>
<p><strong>圖三(g)：scope內：A(V)、B(L)、C(R)。</strong><br />
</center></p>
<p>同樣地步驟，再從C移動至F(L)，並發現F為leaf node，於是對F進行Visiting，並標上數字。</p>
<p><center>
<img alt="bt_h" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f12.png?raw=true" /></p>
<p><strong>圖三(h)：scope內：C(V)、F(L)。</strong><br />
</center></p>
<p>列出F後，發現C的right child指向NULL，於是略過right child(R)，回到C(V)，並對C進行Visiting，標上數字。</p>
<p><center>
<img alt="bt_i" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f13.png?raw=true" /><img alt="bt_j" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f14.png?raw=true" /></p>
<p><strong>圖三(i)-(j)：scope內：C(V)、F(L)。</strong><br />
</center></p>
<p>最後回到「以A為CurrentNode」的scope，對A(V)進行Visiting，便完成了此次post-order traversal，並依序印出<code>D E B F C A</code>。</p>
<p><center>
<img alt="bt_k" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f15.png?raw=true" /><img alt="bt_l" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f16.png?raw=true" /></p>
<p><strong>圖三(k)-(l)：scope內：A(V)、B(L)、C(R)。</strong><br />
</center></p>
<p>以上說明了post-order traversal之過程，另外兩種pre-order與in-order在概念上皆相同，只要把握順序規則即可。</p>
<p></br></p>
<p><a name="ex_code"></a></p>
<h2>Example with Code</h2>
<p>(完整範例程式碼也可以看這裡：<a href="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/ExampleCode/BT_Traversal.cpp">BT_Traversal.cpp</a>)</p>
<p>接下來，再以一棵稍微複雜的Binary Tree作為範例，展示pre-order、in-order、post-order及level-order之traversal。</p>
<p>現有一棵樹如圖四(a)：</p>
<p><center>
<img alt="ex" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f17.png?raw=true" /></p>
<p><strong>圖四(a)：。</strong><br />
</center></p>
<p>並以最暴力的方式建立<code>TreeNode</code>與<code>BinaryTree</code>之物件(object)：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;queue&gt;</span>

<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftchild</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightchild</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>

    <span class="n">TreeNode</span><span class="p">()</span><span class="o">:</span><span class="n">leftchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">rightchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">parent</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">str</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">){};</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span><span class="n">leftchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">rightchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">parent</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">str</span><span class="p">(</span><span class="n">s</span><span class="p">){};</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>         <span class="c1">// 以root作為存取整棵樹的起點</span>
    <span class="n">BinaryTree</span><span class="p">()</span><span class="o">:</span><span class="n">root</span><span class="p">(</span><span class="mi">0</span><span class="p">){};</span>
    <span class="n">BinaryTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span><span class="o">:</span><span class="n">root</span><span class="p">(</span><span class="n">node</span><span class="p">){};</span>

    <span class="kt">void</span> <span class="nf">Preorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Inorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Postorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Levelorder</span><span class="p">();</span>
<span class="p">};</span>
<span class="c1">// definition of BinaryTree::Preorder()</span>
<span class="c1">// definition of BinaryTree::Inorder()</span>
<span class="c1">// definition of BinaryTree::Postorder()</span>
<span class="c1">// definition of BinaryTree::Levelorder()</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// TreeNode instantiation</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">);</span> 
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeC</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">);</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeD</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">);</span> 
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">);</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeF</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;F&quot;</span><span class="p">);</span> 
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeG</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;G&quot;</span><span class="p">);</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeH</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;H&quot;</span><span class="p">);</span> 
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">nodeI</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">);</span>

    <span class="c1">// construct the Binary Tree</span>
    <span class="n">nodeA</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">nodeB</span><span class="p">;</span> <span class="n">nodeA</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">nodeC</span><span class="p">;</span> 
    <span class="n">nodeB</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">nodeD</span><span class="p">;</span> <span class="n">nodeB</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">nodeE</span><span class="p">;</span> 
    <span class="n">nodeE</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">nodeG</span><span class="p">;</span> <span class="n">nodeE</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">nodeH</span><span class="p">;</span> 
    <span class="n">nodeC</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">nodeF</span><span class="p">;</span> <span class="n">nodeF</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">nodeI</span><span class="p">;</span>

    <span class="n">BinaryTree</span> <span class="n">T</span><span class="p">(</span><span class="n">nodeA</span><span class="p">);</span>

    <span class="n">T</span><span class="p">.</span><span class="n">Preorder</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">T</span><span class="p">.</span><span class="n">Inorder</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">T</span><span class="p">.</span><span class="n">Postorder</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">T</span><span class="p">.</span><span class="n">Levelorder</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>    

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>上面的程式碼包含了幾個部分：</p>
<ul>
<li><code>class TreeNode</code>的定義；<ul>
<li>這裡把所有的data與pointer全部設成「public」裸露在外其實不太好，不過為了要能在<code>main()</code>裡土法煉鋼建立出一棵如圖四(a)的Binary Tree，只好將就。</li>
<li>下一篇文章會用比較文明的方式建立Binary Tree，請參考：<a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">Binary Tree: 建立一棵Binary Tree</a>。</li>
</ul>
</li>
<li><code>class BinaryTree</code>的定義，其中有四個member function分別為四種traversal；<ul>
<li>四個函式的定義請繼續看下去。</li>
</ul>
</li>
<li>main()中建立如圖四(a)的樹，並依序執行四種traversal。</li>
</ul>
<p>其中，pre-order、in-order、post-order traversal的邏輯就只是「V」、「L」、「R」誰先誰後的差別，以下程式碼是以較直覺的遞迴(recursion)形式完成，不過，換成迭代(iteration)配合<strong>Stack(堆疊)</strong>在概念上完全相同，實作上即是考慮「V」、「L」、「R」誰先push(推)進stack。  </p>
<p><a name="pre"></a></p>
<h3>Pre-Order Traversal</h3>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Preorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>                          <span class="c1">// if current != NULL</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>   <span class="c1">// V</span>
        <span class="n">Preorder</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">);</span>       <span class="c1">// L</span>
        <span class="n">Preorder</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">);</span>      <span class="c1">// R</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>output:</p>
<div class="highlight"><pre><span class="n">A</span> <span class="n">B</span> <span class="n">D</span> <span class="n">E</span> <span class="n">G</span> <span class="n">H</span> <span class="n">C</span> <span class="n">F</span> <span class="n">I</span> 
</pre></div>


<p><center>
<img alt="ex_pre" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f18.png?raw=true" /></p>
<p><strong>圖四(b)：。</strong><br />
</center></p>
<p><a name="in"></a></p>
<h3>In-Order Traversal</h3>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Inorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>                          <span class="c1">// if current != NULL</span>
        <span class="n">Inorder</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">);</span>        <span class="c1">// L</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>   <span class="c1">// V</span>
        <span class="n">Inorder</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">);</span>       <span class="c1">// R</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>output:</p>
<div class="highlight"><pre><span class="n">D</span> <span class="n">B</span> <span class="n">G</span> <span class="n">E</span> <span class="n">H</span> <span class="n">A</span> <span class="n">F</span> <span class="n">I</span> <span class="n">C</span> 
</pre></div>


<p><center>
<img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f19.png?raw=true" /></p>
<p><strong>圖四(c)：。</strong><br />
</center></p>
<p><a name="post"></a></p>
<h3>Post-Order Traversal</h3>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Postorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>                         <span class="c1">// if current != NULL</span>
        <span class="n">Postorder</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">);</span>     <span class="c1">// L</span>
        <span class="n">Postorder</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">);</span>    <span class="c1">// R</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>  <span class="c1">// V</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>output:</p>
<div class="highlight"><pre><span class="n">D</span> <span class="n">G</span> <span class="n">H</span> <span class="n">E</span> <span class="n">B</span> <span class="n">I</span> <span class="n">F</span> <span class="n">C</span> <span class="n">A</span> 
</pre></div>


<p><center>
<img alt="ex_post" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f20.png?raw=true" /></p>
<p><strong>圖四(d)：。</strong><br />
</center></p>
<p><a name="level"></a></p>
<h3>Level-Order Traversal</h3>
<p>Level-order是照著「level由小到大」的順序，由上而下，並在同一個level「由左至右」依序Visiting每個node。</p>
<p>以下提供以迴圈配合<strong>Queue(佇列)</strong>實現level-order traversal之程式碼，其邏輯也非常直觀：</p>
<ul>
<li>以圖四(e)為例，當CurrentNode站在A時，先對A作Visiting，接著檢查是否有left child與right child，若不為NULL，則「依序」將child pointer 推(push)進queue中，又根據queue「先進先出」(first-in-first-out)的特性，先將B(left child)推入queue，再推入C(right child)，便能確保在下一層level時，是由左至右，先Visiting到B，才Visiting到C。</li>
</ul>
<p><center>
<img alt="ex_level" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f21.png?raw=true" /></p>
<p><strong>圖四(e)：。</strong><br />
</center></p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Levelorder</span><span class="p">(){</span>

    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>                     <span class="c1">// 把root作為level-order traversal之起點</span>
                                            <span class="c1">// 推進queue中</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>                     <span class="c1">// 若queue不是空的, 表示還有node沒有visiting</span>

        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>      <span class="c1">// 取出先進入queue的node</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>                          
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>   <span class="c1">// 進行visiting</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>    <span class="c1">// 若leftchild有資料, 將其推進queue</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>   <span class="c1">// 若rightchild有資料, 將其推進queue</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>output:</p>
<div class="highlight"><pre><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="n">G</span> <span class="n">H</span> <span class="n">I</span>
</pre></div>


<p></br></p>
<p><a name="in_parent"></a></p>
<h2>In-Order Traversal by Parent Field</h2>
<p>在<a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html#code">Binary Tree: Intro(簡介)</a>提到，若在<code>class TreeNode</code>加入pointer指向其parent node會非常有幫助，其中一項理由正是接下來要介紹的兩個函式：<code>InorderSuccessor()</code>與<code>InorderPredecessor()</code>。  </p>
<p>說文解字時間：  </p>
<ul>
<li>字首Inorder-，即是按照inorder traversal之規則(LVR)；</li>
<li>字尾Successor/ Predecessor，即是「下一個」與「前一個」。</li>
</ul>
<p>因此，<code>InorderSuccessor()</code>與<code>InorderPredecessor()</code>便是用來尋找「<strong>以inorder順序</strong>」進行traversal之下一個與前一個node。  </p>
<p>以圖四(c)為例，若CurrentNode站在H(<code>CurrentNode = nodeH</code>)，則：</p>
<ul>
<li><code>CurrentNode = InorderSuccessor(CurrentNode)</code>會將CurrentNode移動至A；</li>
<li><code>CurrentNode = InorderPredecessor(CurrentNode)</code>則會將CurrentNode移動至E。</li>
</ul>
<p><center>
<img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f19.png?raw=true" /></p>
<p><strong>圖四(c)：。</strong><br />
</center></p>
<p>特別介紹inorder，一大原因是為了Binary Search Tree(BST)鋪路，在BST中，照著inorder順序印出node，就會得到「排好序」的資料。</p>
<ul>
<li>詳見：<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao">Binary Search Tree: Sort(排序)、Delete(刪除資料)</a>。</li>
</ul>
<p>另外，若觀察前面提過的遞迴(recursion)形式之inorder traversal，Visiting被包含在遞迴函式內，這表示若要進行多種不同的Visiting，例如print(顯示資料)、assign(賦值、更新資料)，都需要重新寫一個專門功能的遞迴函式。<br />
顯然，把Visiting和Traversal獨立開來會更方便。</p>
<p>在看兩個實用的函式之前，有幾件前置作業：  </p>
<ul>
<li>在<code>class BinaryTree</code>的定義中加入六個member function(成員函式)：</li>
<li>在<code>main()</code>中，把如圖四之Binary Tree的parent pointer建立起來。</li>
</ul>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="c1">// inside main()</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="p">...</span>
    <span class="c1">// link parent pointer</span>
    <span class="n">nodeB</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeA</span><span class="p">;</span> <span class="n">nodeC</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeA</span><span class="p">;</span>
    <span class="n">nodeD</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeB</span><span class="p">;</span> <span class="n">nodeE</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeB</span><span class="p">;</span>
    <span class="n">nodeG</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeE</span><span class="p">;</span> <span class="n">nodeH</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeE</span><span class="p">;</span>
    <span class="n">nodeF</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeC</span><span class="p">;</span> 
    <span class="n">nodeI</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeF</span><span class="p">;</span>
    <span class="p">...</span>

<span class="p">}</span>

<span class="c1">// inside definition of class BinaryTree</span>
<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>         <span class="c1">// 以root作為存取整棵樹的起點</span>
    <span class="n">BinaryTree</span><span class="p">()</span><span class="o">:</span><span class="n">root</span><span class="p">(</span><span class="mi">0</span><span class="p">){};</span>
    <span class="n">BinaryTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span><span class="o">:</span><span class="n">root</span><span class="p">(</span><span class="n">node</span><span class="p">){};</span>

    <span class="kt">void</span> <span class="nf">Preorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Inorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Postorder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Levelorder</span><span class="p">();</span>

    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">leftmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">rightmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>

    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">InorderSuccessor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">InorderPredecessor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">Inorder_by_parent</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Inorder_Reverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p>其中包含：</p>
<ul>
<li><code>InorderSuccessor()</code>與<code>InorderPredecessor()</code>為找到「下一個」與「上一個」的函式主體；</li>
<li><code>leftmost()</code>和<code>rightmost()</code>即是找到Binary Tree整棵樹中「最左」與「最右」的node；</li>
<li><code>Inorder_by_parent()</code>與<code>Inorder_Reverse()</code>將利用<code>InorderSuccessor()</code>與<code>InorderPredecessor()</code>進行一次In-Order Tarversal。</li>
</ul>
<p>看下去。<br />
</br></p>
<p><a name="successor"></a></p>
<h3>Successor、leftmost</h3>
<p>函式<code>leftmost()</code>的功能為：尋找以<code>current</code>為root之subtree中，最左邊的node。</p>
<p>以圖四(c)為例，進入以A為root的Binary Tree後，<code>leftmost()</code>將一路往leftchild前進，最後回傳D。</p>
<ul>
<li>而以inorder的順序來說，<code>leftmost()</code>將回傳該subtree中第一個進行Visiting的node。</li>
</ul>
<p><center>
<img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f19.png?raw=true" /></p>
<p><strong>圖四(c)：。</strong><br />
</center></p>
<p>以下為<code>leftmost()</code>的範例程式碼：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">leftmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p></br><br />
接著重點來了，觀察在inorder規則下，某一node的「<strong>Successor</strong>」之所在位置有兩種可能：</p>
<p><strong>第一種</strong>：若CurrentNode的right child不是NULL，則CurrentNode之下一個順序的node即為以「Current<span class="math">\(-\)</span>&gt;rightchild為root」之subtree中，最左的node。  </p>
<ul>
<li>如圖五(a)所示，若CurrentNode站在B上，B的下一個node即為「以B的right child(也就是E)為root」之subtree中的最左node，即為G。</li>
</ul>
<p><strong>第二種</strong>：若CurrentNode沒有right child，則CurrentNode之下一個順序的node是「以left child的身份尋找到的ancestor」。</p>
<ul>
<li>以圖五(a)中的H為例，H沒有right child，因此往上(往root方向)找ancestor。  </li>
<li>首先找到E，但是H是E的right child，因此再繼續往上找，此時CurrentNode移動到E。  </li>
<li>接著往E的parent找到B，由於E是B的right child，所以要再繼續往上找，並更新CurrentNode為B。  </li>
<li>接著往B的parent找到A，此時，<strong>B為A的left child</strong>，則A即為H的下一個順序的node。</li>
</ul>
<p>特例是root，若整棵樹偏向一邊，root只有left subtree，沒有right subtree，那麼便回傳NULL，表示root沒有successor。</p>
<p><center>
<img alt="successor" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f22.png?raw=true" /></p>
<p><strong>圖五(a)：。</strong><br />
</center></p>
<p>以下為<code>InorderSuccessor()</code>的範例程式碼：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">InorderSuccessor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">leftmost</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 利用兩個pointer: successor與current做traversal </span>

    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">successor</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>   
    <span class="k">while</span> <span class="p">(</span><span class="n">successor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">current</span> <span class="o">==</span> <span class="n">successor</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">successor</span><span class="p">;</span>
        <span class="n">successor</span> <span class="o">=</span> <span class="n">successor</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">successor</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>最後，有了<code>leftmost()</code>與<code>InorderSuccessor()</code>，即能夠以迴圈的方式進行inorder traversal，相較於遞迴形式的函式，具有更大彈性，以函式<code>Inorder_by_parent()</code>呈現：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Inorder_by_parent</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">){</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">leftmost</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">InorderSuccessor</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>在<code>main()</code>中輸入：</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="p">...</span>

    <span class="n">T</span><span class="p">.</span><span class="n">Inorder_by_parent</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>得到output：</p>
<div class="highlight"><pre><span class="n">D</span> <span class="n">B</span> <span class="n">G</span> <span class="n">E</span> <span class="n">H</span> <span class="n">A</span> <span class="n">F</span> <span class="n">I</span> <span class="n">C</span>
</pre></div>


<p></br><br />
<a name="predecessor"></a></p>
<h3>Predecessor、rightmost</h3>
<p>只要把<code>InorderSuccessor()</code>與<code>leftmost()</code>中，所有的left與right互換，就得到<code>InorderPredecessor()</code>與<code>rightmost()</code>，而概念上也確實是如此：</p>
<p><strong>rightmost</strong>：從「以CurrentNode為subtree」的root一路向右做Linked list的單向traversal。</p>
<p><strong>Predecessor</strong>：某一CurrentNode的「前一個順序的node」之位置有兩種可能：</p>
<p><strong>第一種</strong>：若CurrentNode的left child不是NULL，則CurrentNode之前一個順序的node即為以「Current-&gt;lefttchild為root」之subtree中，最右的node。  </p>
<ul>
<li>如圖五(b)所示，若CurrentNode站在C上，C的前一個node即為「以C的right child(也就是F)」為root之subtree中的最右node，即為I。</li>
</ul>
<p><strong>第二種</strong>：若CurrentNode沒有left child，則CurrentNode之前一個順序的node是「以right child的身份尋找到的ancestor」。  </p>
<ul>
<li>以圖五(b)中的F為例，F沒有left child，因此往上(往root方向)找ancestor。</li>
<li>首先找到C，但是F是C的left child，因此再繼續往上找，此時CurrentNode更新成C。</li>
<li>再往C的parent找到A，此時，<strong>C為A的right child</strong>，則A即為F的前一個順序的node。</li>
</ul>
<p>同樣地，若整棵樹偏向一邊，root只有right subtree，沒有left subtree，則回傳NULL，表示root沒有predecessor。</p>
<p><center>
<img alt="predecessor" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f23.png?raw=true" /></p>
<p><strong>圖五(b)：。</strong><br />
</center></p>
<p>以下為<code>rightmost()</code>與<code>InorderPredecessor()</code>的範例程式碼：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">rightmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">InorderPredecessor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">rightmost</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 利用兩個pointer: predecessor與current做traversal</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">predecessor</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">predecessor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">current</span> <span class="o">==</span> <span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">predecessor</span><span class="p">;</span>
        <span class="n">predecessor</span> <span class="o">=</span> <span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">predecessor</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>有了<code>rightmost()</code>與<code>InorderPredecessor()</code>，便能夠照inorder traversal的相反順序對樹的node做Visiting，以函式<code>Inorder_Reverse</code>呈現：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Inorder_Reverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">){</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">rightmost</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">InorderPredecessor</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>在<code>main()</code>中輸入：</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="p">...</span>

    <span class="n">T</span><span class="p">.</span><span class="n">Inorder_Reverse</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>得到output：</p>
<div class="highlight"><pre><span class="n">C</span> <span class="n">I</span> <span class="n">F</span> <span class="n">A</span> <span class="n">H</span> <span class="n">E</span> <span class="n">G</span> <span class="n">B</span> <span class="n">D</span>
</pre></div>


<p></br> <br />
<code>InorderSuccessor()</code>和<code>InorderPredecessor()</code>在Binary Search Tree的部分會再次出現，並且出現在基本操作：deletion(刪除node)中，因此學起來不止酷，還很實用的啊。</p>
<p></br></p>
<hr />
<p><a name="ref"></a></p>
<h3>參考資料：</h3>
<ul>
<li><a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">Introduction to Algorithms, Ch12</a> </li>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++, Ch5</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html#print">Linked List: 新增資料、刪除資料、反轉</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html">Stack: Intro(簡介)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html">Queue: Intro(簡介)，並以Linked list實作</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao">Binary Search Tree: Sort(排序)、Delete(刪除資料)</a></li>
</ul>
<p></br></p>
<p><a name="tree_series"></a></p>
<h3>Binary Tree系列文章</h3>
<p><a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html">Binary Tree: Intro(簡介)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html">Binary Tree: Traversal(尋訪)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">Binary Tree: 建立一棵Binary Tree</a>  </p>
<p>回到目錄：</p>
<p><a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html">目錄：演算法與資料結構</a></p>
<p></br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </article>

        <div class="tags">
            <p>tags: <a href="http://alrightchiu.github.io/SecondRound/tag/c.html">C++</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/binary-tree.html">Binary Tree</a>, </p>
        </div>

<hr>
<div class="sharing">
</div>
    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="https://github.com/alrightchiu">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="http://alrightchiu.github.io/SecondRound/theme/js/clean-blog.min.js"></script>

</body>

</html>
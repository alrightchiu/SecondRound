<!DOCTYPE html>
<html lang="zh-hant">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">

        <link rel="shortcut icon" type="image/x-ico" href="http://alrightchiu.github.io/SecondRound/fig/favicon.ico" />


        <title>Red Black Tree: Delete(刪除資料)與Fixup(修正)</title>

            <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Full Atom Feed" />
            <link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="http://alrightchiu.github.io/SecondRound/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="C++" />
        <meta name="tags" contents="Red Black Tree" />


	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Second Round">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html">
	<meta property="og:title" content="Red Black Tree: Delete(刪除資料)與Fixup(修正)">
	<meta property="og:description" content="">
	<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/">
	<meta property="article:published_time" content="2016-01-30 14:11:00+08:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://alrightchiu.github.io/SecondRound/">Second Round</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                        <li><a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a></li>
                        <li><a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a></li>

                            <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html">About</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('http://alrightchiu.github.io/SecondRound/theme/images/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Red Black Tree: Delete(刪除資料)與Fixup(修正)</h1>
                        <span class="meta">Posted by
                                <a href="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">Chiu CC</a>
                             on  1 30, 2016
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p></br></p>
<h3>先備知識與注意事項</h3>
<p>(完整範例程式碼也可以看這裡：<a href="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/ExampleCode/RBT_Insert_Delete.cpp">RBT_Insert_Delete.cpp</a>)</p>
<p>如同<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Insert(新增資料)與Fixup(修正)</a>，RBT之Delete(刪除資料)方法同樣是先沿用<code>DeleteBST()</code>，再對顏色利用<code>Rotation</code>進行修正。  </p>
<p>建議讀者在閱讀本篇文章之前，先復習<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#delete">BST::DeleteBST(刪除資料)</a>與<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html">Red Black Tree: Rotation(旋轉)</a>，會比較容易上手。</p>
<hr />
<h2>目錄</h2>
<ul>
<li><a href="#violate">於RBT中Delete(刪除資料)可能違反RBT之特徵</a></li>
<li><a href="#bst">如同於BST中Delete(刪除資料)</a></li>
<li><a href="#fixup">修正：DeleteFixUpRBT()</a><ul>
<li><a href="#case1">Case1</a></li>
<li><a href="#case2">Case2</a></li>
<li><a href="#case3">Case3</a></li>
<li><a href="#case4">Case4</a></li>
<li><a href="#example">範例</a></li>
</ul>
</li>
<li><a href="#code">程式碼</a></li>
<li><a href="#ref">參考資料</a></li>
<li><a href="#tree_series">RBT系列文章</a></li>
</ul>
<p></br></p>
<p><a name="violate"></a></p>
<h2>於RBT中Delete(刪除資料)可能違反RBT之特徵</h2>
<p>在RBT中執行Delete(刪除資料)時，若刪除之node為黑色，有可能違反三點RBT特徵：</p>
<ol>
<li>圖一(a)：若要刪除的node恰好為<code>root</code>，而刪除後恰好是紅色的node遞補成為新的<code>root</code>，此時便違反RBT之第二點特徵：<code>root</code>一定要是黑色；</li>
<li>圖一(b)：若刪除node後，出現紅色與紅色node相連之情形，則違反RBT之第四點特徵：紅色node之<code>child</code>一定要是黑色；</li>
<li>圖一(b)：若刪除之node是黑色，而且恰好不是<code>root</code>，那麼所有包含被刪除node的path上之黑色node數必定會減少，將會違反RBT之第五點特徵：「站在任何一個node上，所有從該node走到其任意descendant leaf的path上之黑色node數必定相同」。<ul>
<li>圖一(b)左：從<code>root</code>:node(B)出發至任意leaf的path上都有三個黑色node(包含<code>NIL</code>)；</li>
<li>圖一(b)右：刪除node(D)後，path:node(B)-node(E)-node(C)上之黑色node數剩下<span class="math">\(2\)</span>個(包含<code>NIL</code>)。</li>
</ul>
</li>
</ol>
<p>因此，需要對顏色進行修正，以滿足RBT特徵。</p>
<p><center>
<img alt="violate" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete1.png?raw=true" /></p>
<p><strong>圖一(a)：違反RBT之第二點與第四點特徵。</strong></p>
<p><img alt="violate" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete2.png?raw=true" /></p>
<p><strong>圖一(b)：違反RBT之第四點與第五點特徵。</strong>
</center></p>
<p></br></p>
<p><a name="bst"></a></p>
<h2>如同於BST中Delete(刪除資料)</h2>
<p><code>RBT::DeleteRBT()</code>之範例程式碼分成兩個部分：</p>
<ol>
<li>第一部分，如同<code>DeleteBST()</code>，依照欲刪除之node的child個數分成三種情形處理：<ol>
<li>先確認BST中有沒有要刪除的node；</li>
<li>把要刪除的node調整成「至多只有一個child」；</li>
<li>把要刪除的node的child指向新的<code>parent</code>；</li>
<li>把要刪除的node的<code>parent</code>指向新的child；</li>
<li>若實際上刪除的是「替身」，再把替身的資料放回BST中；</li>
</ol>
</li>
<li>第二部分，若刪除的node是黑色，需要進行修正(Fix-Up)，引進函式：<code>DeleteFixedUpRBT()</code>。   </li>
</ol>
<p></br>  </p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">RBT</span><span class="o">::</span><span class="n">DeleteRBT</span><span class="p">(</span><span class="kt">int</span> <span class="n">KEY</span><span class="p">){</span>              <span class="c1">// 要刪除具有KEY的node</span>

    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">delete_node</span> <span class="o">=</span> <span class="n">Search</span><span class="p">(</span><span class="n">KEY</span><span class="p">);</span>   <span class="c1">// 先確認RBT中是否存在具有KEY的node</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">delete_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;data not found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// 真正要被刪除並釋放記憶體的node</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// 要被刪除的node的&quot;child&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">==</span> <span class="n">neel</span> <span class="o">||</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">==</span> <span class="n">neel</span><span class="p">){</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Successor</span><span class="p">(</span><span class="n">delete_node</span><span class="p">);</span>         <span class="c1">// 將y設成delete_node的Successor</span>
    <span class="p">}</span>                                       <span class="c1">// 經過這組if-else, y調整成至多只有一個child</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="n">neel</span><span class="p">){</span>              <span class="c1">// 將x設成y的child, 可能有實際資料, 也有可能是NIL</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>                 <span class="c1">// 即使x是NIL也要把x的parent指向有效的記憶體位置</span>
                                           <span class="c1">// 因為在FixUp時需要藉由x-&gt;parent判斷x為leftchild或是rightchild</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">neel</span><span class="p">){</span>                <span class="c1">// 接著再把要被釋放記憶體的node之&quot;parent&quot;指向新的child</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                    <span class="c1">// 若刪除的是原先的root, 就把x當成新的root </span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">){</span>   <span class="c1">// 若y原本是其parent之left child</span>
        <span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>          <span class="c1">// 便把x皆在y的parent的left child, 取代y</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>                                  <span class="c1">// 若y原本是其parent之right child</span>
        <span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>         <span class="c1">// 便把x皆在y的parent的right child, 取代y</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">delete_node</span><span class="p">)</span> <span class="p">{</span>                <span class="c1">// 針對case3</span>
        <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>         <span class="c1">// 若y是delete_node的替身, 最後要再將y的資料</span>
        <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">;</span> <span class="c1">// 放回delete_node的記憶體位置, 並將y的記憶體位置釋放</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>                   <span class="c1">// 若刪除的node是黑色, 要從x進行修正, 以符合RBT的顏色規則</span>
        <span class="n">DeleteFixedUpRBT</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p></br></p>
<p><a name="fixup"></a></p>
<h2>修正：DeleteFixUpRBT()</h2>
<p>考慮在圖二之RBT中刪除node(B)，由於node(B)是黑色，必定違反RBT之特徵，因此需要修正。<br />
(以下圖示中，白色的node表示顏色可能為黑色也可能為紅色，而且可能是一棵subtree或是<code>NIL</code>，需視情況而定。)</p>
<p><center>
<img alt="original" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete3.png?raw=true" /></p>
<p><strong>圖二：。</strong>
</center></p>
<p>根據<code>sibling</code>之顏色與<code>sibling</code>之<code>child</code>之顏色，可以分為下列四種情形(Case)，如圖三：</p>
<ul>
<li>Case1：<code>sibling</code>為紅色；</li>
<li>Case2：<code>sibling</code>為黑色，而且<code>sibling</code>的兩個<code>child</code>都是黑色；</li>
<li>Case3：<code>sibling</code>為黑色，而且<code>sibling</code>的<code>rightchild</code>是黑色，<code>leftchild</code>是紅色；</li>
<li>Case4：<code>sibling</code>為黑色，而且<code>sibling</code>的<code>rightchild</code>是紅色。</li>
</ul>
<p><center>
<img alt="4cases" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete4.png?raw=true" /></p>
<p><strong>圖三：。</strong>
</center></p>
<p><code>DeleteFixUpRBT()</code>的情形(Case)較為複雜，圖四是所有情形之循環圖：<br />
(<code>current</code>即是被刪除的node之<code>child</code>)</p>
<ul>
<li>若<code>current</code>是黑色的，而且<code>current</code>不為<code>root</code>，則依情況進入四個Case；</li>
<li>若進入Case1，修正後，將進入Case2、Case3或Case4；</li>
<li>若進入Case2，有可能修正後即符合RBT特徵，也有可能根據新的<code>current</code>之情形重新判斷起；</li>
<li>若進入Case3，修正後必定進入Case4；</li>
<li>若進入Case4，修正後必定符合RBT之特徵。</li>
</ul>
<p><center>
<img alt="flow" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete5.png?raw=true" /></p>
<p><strong>圖四：。</strong>
</center></p>
<p><a name="case1"></a></p>
<h3>Case1</h3>
<p>若<code>sibling</code>為紅色，修正方法如下，見圖五(a)：</p>
<ul>
<li>將<code>sibling</code>塗成黑色：node(E)塗成黑色；</li>
<li>將<code>current</code>之<code>parent</code>塗成紅色：node(C)塗成紅色；</li>
<li>對<code>current</code>之<code>parent</code>做Left Rotation：對node(C)做Left Rotation；</li>
<li>將<code>sibling</code>移動到<code>current-&gt;parent</code>的<code>rightchild</code>：將<code>sibling</code>指向node(D)。</li>
</ul>
<p><center>
<img alt="case1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete6.png?raw=true" /></p>
<p><strong>圖五(a)：。</strong>
</center></p>
<p>在上述步驟中，並沒有更改<code>current</code>之記憶體位置和顏色，<code>current</code>仍為黑色。不過其<code>sibling</code>必定會變成黑色，因此將進入Case2、Case3或Case4。</p>
<p>為什麼Case1經過以上修正還沒有結束？原因要回到刪除node之前的RBT。  </p>
<p>圖五(b)左，展示了刪除node之前，以node(C)為<code>root</code>的RBT(或是更大的RBT之subtree)的其中一種可能情況。<br />
從node(C)往任何一個descendant leaf的path上之黑色node數為<span class="math">\(3\)</span>，刪除node(B)後，使得其中一條path的黑色node數減少，經過上述方法之調整，仍然無法使得所有path之黑色node數相同，如圖五(b)右。  </p>
<p>不過Case1所提出的修正方法能夠將情況調整成Case2、Case3或Case4，並且修正至滿足RBT之特徵。</p>
<p><center>
<img alt="case1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete7.png?raw=true" /></p>
<p><strong>圖五(b)：圖中的「Original」僅代表其中一種可能的情形。</strong>
</center></p>
<p><a name="case2"></a></p>
<h3>Case2</h3>
<p>若<code>sibling</code>為黑色，並且<code>sibling</code>之兩個<code>child</code>皆為黑色，修正的方法如下，見圖五(c)：</p>
<ul>
<li>將<code>sibling</code>塗成紅色：node(E)塗成紅色；</li>
<li>將<code>current</code>移至<code>currnet</code>的<code>parent</code>：<code>current</code>移至node(C)。</li>
</ul>
<p><center>
<img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete8.png?raw=true" /></p>
<p><strong>圖五(c)：。</strong>
</center></p>
<p>經過上述步驟，根據新的<code>current</code>:8node(C)之顏色，可以分成兩種情形：</p>
<ul>
<li>若node(C)為紅色，則跳出迴圈，把node(C)塗黑，即可滿足RBT之特徵，如圖五(d)，其邏輯便是：將從node(C)出發往<code>leftchild</code>與<code>rightchild</code>path的黑色數目調整成與刪除之前(Original)相同；</li>
<li>若node(C)為黑色，且node(C)不是<code>root</code>，則繼續下一輪迴圈，重新判斷其屬於四種情況之何者並修正，如圖五(e)，從node(G)出發至任意descendant leaf之path上的黑色node數並不完全相同。</li>
</ul>
<p><center>
<img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete9.png?raw=true" /></p>
<p><strong>圖五(d)：圖中的「Original」僅代表其中一種可能的情形。</strong></p>
<p><img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete10.png?raw=true" /></p>
<p><strong>圖五(e)：圖中的「Original」僅代表其中一種可能的情形。<br />
此時的RBT還要繼續修正，重新回到Case2。</strong>
</center></p>
<p><a name="case3"></a></p>
<h3>Case3</h3>
<p>若<code>sibling</code>為黑色，並且<code>sibling</code>之<code>rightchild</code>為黑色，<code>leftchild</code>為紅色，修正的方法如下，見圖五(f)：</p>
<ul>
<li>將<code>sibling</code>之<code>leftchild</code>塗成黑色：node(D)塗成黑色；</li>
<li>將<code>sibling</code>塗成紅色：node(E)塗成紅色；</li>
<li>對<code>sibling</code>進行Right Rotation：對node(E)進行Right Rotation；</li>
<li>將<code>sibling</code>移至<code>current-&gt;parent</code>的<code>rightchild</code>：將<code>sibling</code>移至node(D)。</li>
</ul>
<p><center>
<img alt="case3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete11.png?raw=true" /></p>
<p><strong>圖五(f)：。</strong>
</center></p>
<p>經過以上修正步驟，<code>sibling</code>之<code>rightchild</code>成為紅色，便進入Case4。</p>
<p><a name="case4"></a></p>
<h3>Case4</h3>
<p>若<code>sibling</code>為黑色，並且<code>sibling</code>之<code>rightchild</code>為紅色，修正的方法如下，見圖五(g)：</p>
<ul>
<li>將<code>sibling</code>塗成<code>current</code>之<code>parent</code>的顏色：<ul>
<li>若node(C)是紅色，則將node(E)塗成紅色；</li>
<li>若node(C)是黑色，則將node(E)塗成黑色；</li>
</ul>
</li>
<li>將<code>parent</code>塗成黑色：node(C)塗成黑色；</li>
<li>將<code>sibling</code>之<code>rightchild</code>塗成黑色：node(F)塗成黑色；</li>
<li>對<code>parent</code>進行Left Rotation：對node(C)做Left Rotation；</li>
<li>將<code>current</code>移至<code>root</code>，把<code>root</code>塗黑。<br />
(注意：圖五(d)之node(E)未必是RBT之<code>root</code>。)</li>
</ul>
<p><center>
<img alt="case4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete12.png?raw=true" /></p>
<p><strong>圖五(g)：。</strong>
</center></p>
<p>如圖五(h)所示，Case4修正方法的邏輯便是：在刪除node(B)之後的RBT(或是subtree)中，將所有從<code>root</code>位置(調整前是node(C)，調整後是node(E))出發往任意descendant leaf之path上的黑色數目調整成與刪除之前(Original)相同，因此，經過Case4的修正一定能夠滿足RBT之特徵。</p>
<p><center>
<img alt="case4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete13.png?raw=true" /></p>
<p><strong>圖五(h)：圖中的「Original」僅代表其中一種可能的情形。</strong>
</center></p>
<hr />
<p><a name="example"></a></p>
<h3>範例</h3>
<p>接著以一個簡單的範例(圖六(a)之RBT)操作上述四種Case的修正方法。</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete14.png?raw=true" /></p>
<p><strong>圖六(a)：。</strong>
</center></p>
<h3>Case3-&gt;Case4</h3>
<p>若考慮刪除node(19)，由於node(19)是黑色，需要修正。<br />
接著判斷，node(19)的child(為黑色的<code>NIL</code>)之<code>sibling</code>:node(27)為黑色，且<code>sibling</code>之<code>rightchild</code>為黑色，符合Case3的描述，因此利用Case3之修正方法，見圖六(b)：</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete15.png?raw=true" /></p>
<p><strong>圖六(b)：。</strong>
</center></p>
<ul>
<li>將<code>sibling</code>之<code>leftchild</code>塗成黑色：node(24)塗成黑色；</li>
<li>將<code>sibling</code>塗成紅色：node(27)塗成紅色；</li>
<li>對<code>sibling</code>進行Right Rotation：對node(27)進行Right Rotation；</li>
<li>將<code>sibling</code>移至<code>current-&gt;parent</code>的<code>rightchild</code>：將<code>sibling</code>移至node(24)；</li>
</ul>
<p>接著進入Case4：<code>subling</code>為黑色，而且<code>sibling</code>之<code>rightchild</code>為紅色，進行修正：</p>
<ul>
<li>將<code>sibling</code>塗成<code>current</code>之<code>parent</code>的顏色：node(22)是黑色，則將node(24)塗成黑色；</li>
<li>將<code>parent</code>塗成黑色：node(22)塗成黑色；</li>
<li>將<code>sibling</code>之<code>rightchild</code>塗成黑色：node(27)塗成黑色；</li>
<li>對<code>parent</code>進行Left Rotation：對node(22)做Left Rotation；</li>
<li>將<code>current</code>移至<code>root</code>，把<code>root</code>塗黑。</li>
</ul>
<p>如此一來便再次滿足RBT之特徵限制，如圖六(c)。</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete16.png?raw=true" /></p>
<p><strong>圖六(c)：。</strong>
</center></p>
<h3>Case4</h3>
<p>再考慮刪除黑色的node(45)，判斷：node(45)的child(為黑色的<code>NIL</code>)之<code>sibling</code>:node(52)為黑色，且<code>sibling</code>之<code>rightchild</code>:node(55)為紅色，符合Case4的描述，並利用Case4方法修正，見圖六(d)：</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete17.png?raw=true" /></p>
<p><strong>圖六(d)：。</strong>
</center></p>
<ul>
<li>將<code>sibling</code>塗成<code>current</code>之<code>parent</code>的顏色：node(48)是紅色，則將node(52)塗成紅色；</li>
<li>將<code>parent</code>塗成黑色：node(48)塗成黑色；</li>
<li>將<code>sibling</code>之<code>rightchild</code>塗成黑色：node(55)塗成黑色；</li>
<li>對<code>parent</code>進行Left Rotation：對node(48)做Left Rotation；</li>
<li>將<code>current</code>移至<code>root</code>，把<code>root</code>塗黑。</li>
</ul>
<p>如此一來便再次滿足RBT之特徵限制，如圖六(e)。</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete18.png?raw=true" /></p>
<p><strong>圖六(e)：。</strong>
</center></p>
<h3>Case1-&gt;Case4</h3>
<p>接著考慮刪除黑色的node(39)，判斷：node(39)的child(為黑色的<code>NIL</code>)之<code>sibling</code>:node(52)為紅色，符合Case1之描述，便利用Case1之方法，調整成Case4，見圖六(f)：</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete19.png?raw=true" /></p>
<p><strong>圖六(f)：。</strong>
</center></p>
<p>Case1調整：</p>
<ul>
<li>將<code>sibling</code>塗成黑色：node(52)塗成黑色；</li>
<li>將<code>current</code>之<code>parent</code>塗成紅色：node(41)塗成紅色；</li>
<li>對<code>current</code>之<code>parent</code>做Left Rotation：對node(41)做Left Rotation；</li>
<li>將<code>sibling</code>移動到<code>current-&gt;parent</code>的<code>rightchild</code>：將<code>sibling</code>移動至node(48)；  </li>
</ul>
<p>再利用Case4的方法修正，便能滿足RBT之特徵，見圖六(g)。</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete20.png?raw=true" /></p>
<p><strong>圖六(g)：。</strong>
</center></p>
<h3>Case2</h3>
<p>若要刪除黑色的node(7)，由於node(7)的child之<code>sibling</code>:node(10)為黑色，且具有兩個黑色的child(都是<code>NIL</code>)，符合Case2的情況，便修正如下，見圖六(h)：</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete21.png?raw=true" /></p>
<p><strong>圖六(h)：。</strong>
</center></p>
<ul>
<li>將<code>sibling</code>塗成紅色：node(10)塗成紅色；</li>
<li>將<code>current</code>移至<code>currnet</code>的<code>parent</code>：<code>current</code>移至node(9)；</li>
<li>若新的<code>current</code>:node(9)為紅色，即跳出迴圈，並將<code>current</code>塗黑。</li>
</ul>
<p>經修正後，便符合RBT之特徵，見圖六(i)。</p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete22.png?raw=true" /></p>
<p><strong>圖六(i)：。</strong>
</center></p>
<h3>Case0: current is red or current is root</h3>
<p>最後，若要刪除黑色的node(3)呢？由於node(3)的child:node(1)為紅色，並不需要考慮到Case1(<code>sibling</code>為紅色，兩個child為黑色)，只要將node(1)塗黑即可，如圖六(j)。  </p>
<p><center>
<img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete23.png?raw=true" /></p>
<p><strong>圖六(j)：。</strong>
</center></p>
<p></br></p>
<p><a name="code"></a></p>
<h2>程式碼</h2>
<p><code>RBT::DeleteFixedUpRBT()</code>之範例程式碼分成以下幾個部分：</p>
<p>如圖四所示，修正的過程可能經歷不止一個Case，因此利用<code>while</code>來實現，條件式為：<code>current</code>不是<code>root</code>，而且<code>current</code>為黑色；</p>
<p>若<code>current</code>是其<code>parent</code>之<code>leftchild</code>，其<code>sibling</code>就必須是<code>rightchild</code>，反之亦然，而兩種情形之<code>Rotation</code>修正之方向正好相反，因此，如同<code>InsertFixedUpRBT()</code>，必須區分出「<code>current</code>是其<code>parent</code>之<code>leftchild</code>」與「<code>current</code>是其<code>parent</code>之<code>rightchild</code>」兩種情況，彼此結構對稱。</p>
<p>中間利用數個<code>if-else</code>條件式進行Case1、Case2、Case3與Case4之修正。</p>
<p>當滿足「<code>current</code>為<code>root</code>」或者「<code>current</code>顏色為黑色」時便跳出迴圈，最後為確保RBT滿足<code>root</code>為黑色，將<code>current</code>之顏色塗黑，有可能在Case2用上，見圖五(d)與圖六(h)。</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">RBT</span><span class="o">::</span><span class="n">DeleteFixedUpRBT</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span>
    <span class="c1">// Case0:(i)  current是紅色的, 直接把它塗黑</span>
    <span class="c1">//       (ii) current是root, 直接把它塗黑</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// current是leftchild</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">)</span> <span class="p">{</span>    
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">sibling</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span>
            <span class="c1">// Case1: 如果sibling是紅色</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">LeftRotation</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
                <span class="n">sibling</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 進入 Case2、3、4: sibling是黑色</span>
            <span class="c1">// Case2: sibling的兩個child都是黑色</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sibling</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>           <span class="c1">// 若current更新到root, 即跳出迴圈</span>
            <span class="p">}</span>
            <span class="c1">// Case3 &amp; 4: current只有其中一個child是黑色</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// case3: sibling的right child是黑的, left child是紅色</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sibling</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
                    <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">RightRotation</span><span class="p">(</span><span class="n">sibling</span><span class="p">);</span>
                    <span class="n">sibling</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// 經過Case3後, 一定會變成Case4</span>
                <span class="c1">// Case 4: sibling的right child 是紅色的, left child是黑色</span>
                <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">;</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">LeftRotation</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>     <span class="c1">// 將current移動到root, 一定跳出迴圈</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// current是rightchild</span>
        <span class="k">else</span> <span class="p">{</span>  
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">sibling</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span>
            <span class="c1">// Case1: 如果sibling是紅色</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">RightRotation</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
                <span class="n">sibling</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 進入 Case2、3、4: sibling是黑色</span>
            <span class="c1">// Case2: sibling的兩個child都是黑色</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sibling</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>             <span class="c1">// 若current更新到root, 即跳出迴圈</span>
            <span class="p">}</span>
            <span class="c1">// Case3 &amp; 4: current只有其中一個child是黑色</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// case3: sibling的left child是黑的, right child是紅色</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sibling</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
                    <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="n">LeftRotation</span><span class="p">(</span><span class="n">sibling</span><span class="p">);</span>
                    <span class="n">sibling</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// 經過Case3後, 一定會變成Case4</span>
                <span class="c1">// Case 4: sibling的left child 是紅色的, rightt child是黑色</span>
                <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">;</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">sibling</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">RightRotation</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>     <span class="c1">// 將current移動到root, 一定跳出迴圈</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p></br></p>
<p>以上便是於Red Black Tree(紅黑樹)中進行Delete(刪除資料)與Delete後的Fixup(修正)之介紹。</p>
<p></br></p>
<hr />
<p><a name="ref"></a></p>
<h3>參考資料：</h3>
<ul>
<li><a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">Introduction to Algorithms, Ch13</a> </li>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++, Ch10</a></li>
<li><a href="http://code.geeksforgeeks.org/NtLnIk">GeeksforGeeks：Red Black Tree</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#delete">BST::DeleteBST(刪除資料)</a></li>
</ul>
<p></br></p>
<p><a name="tree_series"></a></p>
<h3>RBT系列文章</h3>
<p><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html">Red Black Tree: Intro(簡介)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html">Red Black Tree: Rotation(旋轉)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Insert(新增資料)與Fixup(修正)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Delete(刪除資料)與Fixup(修正)</a></p>
<p>回到目錄：</p>
<p><a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html">目錄：演算法與資料結構</a></p>
<p></br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </article>

        <div class="tags">
            <p>tags: <a href="http://alrightchiu.github.io/SecondRound/tag/c.html">C++</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/red-black-tree.html">Red Black Tree</a>, </p>
        </div>

<hr>
<div class="sharing">
</div>
    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="https://github.com/alrightchiu">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="http://alrightchiu.github.io/SecondRound/theme/js/clean-blog.min.js"></script>

</body>

</html>
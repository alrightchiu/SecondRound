<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Second Round</title><link href="http://alrightchiu.github.io/SecondRound/" rel="alternate"></link><link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" rel="self"></link><id>http://alrightchiu.github.io/SecondRound/</id><updated>2099-12-31T23:59:00+08:00</updated><entry><title>目錄：演算法與資料結構</title><link href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html" rel="alternate"></link><updated>2099-12-31T23:59:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2099-12-31:SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html</id><summary type="html">&lt;h2&gt;演算法與資料結構&lt;/h2&gt;
&lt;p&gt;介紹演算法與資料結構的基本概念。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Complexity系列文章&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/complexityasymptotic-notationjian-jin-fu-hao.html"&gt;Complexity：Asymptotic Notation(漸進符號)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;基本資料結構系列文章&lt;/h2&gt;
&lt;h3&gt;Linked List&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List：新增資料、刪除資料、反轉&lt;/a&gt;    &lt;/p&gt;
&lt;h3&gt;Stack&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html"&gt;Stack：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html"&gt;Stack：以Array與Linked list實作&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/stack-neng-gou-zai-o1qu-de-zui-xiao-zhi-de-minstack.html"&gt;Stack：能夠在O(1)取得最小值的MinStack&lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;Queue&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html"&gt;Queue：Intro(簡介)，並以Linked list實作&lt;/a&gt;  &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html"&gt;Queue：以Array實作Queue&lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;Set&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/setyi-arraybiao-shi.html"&gt;Set：以Array表示&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Sort系列文章&lt;/h2&gt;
&lt;h3&gt;Comparison Sort&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-insertion-sortcha-ru-pai-xu-fa.html"&gt;Comparison Sort：Insertion Sort(插入排序法)&lt;/a&gt;  &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-quick-sortkuai-su-pai-xu-fa.html"&gt;Comparison Sort：Quick Sort(快速排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-heap-sortdui-ji-pai-xu-fa.html"&gt;Comparison Sort：Heap Sort(堆積排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html"&gt;Comparison Sort：Merge Sort(合併排序法)&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹)：Intro(簡介)&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Binary Tree(二元樹)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree：Traversal(尋訪)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree：建立一棵Binary Tree&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Binary Search Tree(二元搜尋樹)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree：Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree：Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Red Black Tree(紅黑樹)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree：Rotation(旋轉)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree：Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree：Delete(刪除資料)與Fixup(修正)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Hash Table系列文章&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html"&gt;Hash Table：Intro(簡介)&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tablechaining.html"&gt;Hash Table：Chaining&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableopen-addressing.html"&gt;Hash Table：Open Addressing&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Graph系列文章&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph：Intro(簡介)&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Breadth-First Search與Depth-First Search&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph：Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph：Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph：利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah：利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah：利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;Minimum Spanning Tree(最小生成樹)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treekruskals-algorithm.html"&gt;Minimum Spanning Tree：Kruskal's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html"&gt;Minimum Spanning Tree：Prim's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue&lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;Shortest Path&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html"&gt;Shortest Path：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathbellman-ford-algorithm.html"&gt;Single-Source Shortest Path：Bellman-Ford Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html"&gt;Single-Source Shortest Path：on DAG(directed acyclic graph)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html"&gt;All-Pairs Shortest Path：Floyd-Warshall Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;h3&gt;Flow Networks&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/flow-networksmaximum-flow-ford-fulkerson-algorithm.html"&gt;Flow Networks：Maximum Flow &amp;amp; Ford-Fulkerson Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Priority Queue系列文章&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html"&gt;Priority Queue：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="C++"></category></entry><entry><title>Hash Table：Open Addressing</title><link href="http://alrightchiu.github.io/SecondRound/hash-tableopen-addressing.html" rel="alternate"></link><updated>2016-05-29T21:32:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-05-29:SecondRound/hash-tableopen-addressing.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將延續&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html"&gt;Hash Table：Intro(簡介)&lt;/a&gt;的議題，介紹&lt;strong&gt;Open Addressing&lt;/strong&gt;來解決&lt;strong&gt;Collision&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#oa"&gt;Open Addressing的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#probing"&gt;利用Probing&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#lp"&gt;Linear Probing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#qp"&gt;Quadratic Probing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#dh"&gt;Double Hashing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#comp"&gt;比較Open Addressing與Chaining&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Hash Table系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="oa"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Open Addressing的概念&lt;/h2&gt;
&lt;p&gt;當發生&lt;strong&gt;Collision&lt;/strong&gt;時，&lt;strong&gt;Chaining&lt;/strong&gt;會將所有被Hash Function分配到同一格slot的資料透過Linked list串起來，像是在書桌的抽屜下面綁繩子般，把所有被分配到同一格抽屜的物品都用繩子吊在抽屜下面。&lt;/p&gt;
&lt;p&gt;相較於&lt;strong&gt;Chaining&lt;/strong&gt;提供額外空間(node)來存放被分配到相同slot的資料，&lt;strong&gt;Open Addressing&lt;/strong&gt;則是將每筆資料都放在書桌(Table)本身配備的抽屜(slot)，一格抽屜只能放一個物品，如果抽屜都滿了，就得換張書桌(重新配置記憶體給新的Table)。  &lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;load factor&lt;/strong&gt;(&lt;span class="math"&gt;\(\alpha=\frac{n}{m}\)&lt;/span&gt;)不能超過&lt;span class="math"&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/OpenAddressing/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：Chaining vs Open Addressing。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;既然沒有額外的空間存放資料，當Hash Function把具有不同&lt;strong&gt;Key&lt;/strong&gt;的資料分配到同一個slot時怎麼辦呢？&lt;/p&gt;
&lt;p&gt;那就繼續「尋找下一格空的slot」，直到&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;終於找到空的slot，或者&lt;/li&gt;
&lt;li&gt;所有slot都滿了為止&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如圖一，這種「尋找下一格空的slot」的方式就稱為&lt;strong&gt;Probing&lt;/strong&gt;。&lt;br /&gt;
(probe有探測的意思，在這裏可以解讀成：不斷探測下一個slot是否為空的。)&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a name="probing"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;利用Probing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Probing&lt;/strong&gt;就是「尋找下一格空的slot」，如果沒找到，就要繼續「往下找」，因此，&lt;strong&gt;Probing&lt;/strong&gt;的精髓就是要製造出「往下找的順序」，這個順序盡可能越不規則越好，如此可確保Hash Function不會一直找到同一個slot：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假設Table大小為&lt;span class="math"&gt;\(6\)&lt;/span&gt;，對於itemA而言，&lt;strong&gt;Probing&lt;/strong&gt;順序是{&lt;span class="math"&gt;\(3,5,0,1,2,4\)&lt;/span&gt;}，就表示itemA會先被分配到第&lt;span class="math"&gt;\(3\)&lt;/span&gt;個slot，如果第&lt;span class="math"&gt;\(3\)&lt;/span&gt;個slot已經有其他item，就往下找第&lt;span class="math"&gt;\(5\)&lt;/span&gt;個slot；如果第&lt;span class="math"&gt;\(5\)&lt;/span&gt;個slot也有item了，就再找第&lt;span class="math"&gt;\(0\)&lt;/span&gt;個slot，依此類推，按照其&lt;strong&gt;Probing&lt;/strong&gt;順序逐一檢查是否有空的slot，如果&lt;span class="math"&gt;\(6\)&lt;/span&gt;個slot都滿了，便宣告失敗，需要調整Table大小。&lt;/li&gt;
&lt;li&gt;若有另一個itemB，其&lt;strong&gt;Probing&lt;/strong&gt;順序與itemA完全相同({&lt;span class="math"&gt;\(3,5,0,1,2,4\)&lt;/span&gt;})，那麼在加入(insert)itemB時，必須再完整經歷一次itemA的過程，見圖二：&lt;ul&gt;
&lt;li&gt;假設itemA最後被放在第&lt;span class="math"&gt;\(1\)&lt;/span&gt;個slot，表示前面的第&lt;span class="math"&gt;\(3\)&lt;/span&gt;、第&lt;span class="math"&gt;\(5\)&lt;/span&gt;、第&lt;span class="math"&gt;\(0\)&lt;/span&gt;個slot都已經有item，那麼在加入itemB時，就需要經歷「&lt;span class="math"&gt;\(4\)&lt;/span&gt;次」失敗，才終於在第&lt;span class="math"&gt;\(2\)&lt;/span&gt;個slot找到位置存放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以想像的是，若對於所有item都只有一種&lt;strong&gt;Probing&lt;/strong&gt;順序，那麼在加入(insert)第一個item時，只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;的時間，但是再繼續加入item時，就必須考慮「現有的item數」，時間複雜度增加為&lt;span class="math"&gt;\(O(\#items\:in\:slots)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;由此可見，&lt;strong&gt;Probing&lt;/strong&gt;順序會影響到Hash Table的操作(&lt;strong&gt;insert&lt;/strong&gt;、&lt;strong&gt;delete&lt;/strong&gt;、&lt;strong&gt;search&lt;/strong&gt;)之時間複雜度。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/OpenAddressing/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖二中，&lt;strong&gt;Probing&lt;/strong&gt;之Hash Function的定義域(domain)有兩個參數，一個是&lt;strong&gt;Key&lt;/strong&gt;，另一個是&lt;strong&gt;Probing&lt;/strong&gt;的「次數」，而值域(range)即為Table的&lt;strong&gt;index&lt;/strong&gt;範圍：&lt;/p&gt;
&lt;div class="math"&gt;$$
h:U\times\{0,1,...,m-1\}\rightarrow\{0,1,...m-1\}
$$&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(U\)&lt;/span&gt;是所有可能的&lt;strong&gt;Key&lt;/strong&gt;的宇集合(universal set)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Probing&lt;/strong&gt;的次數最多不會超過Table大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;，定義從第&lt;span class="math"&gt;\(0\)&lt;/span&gt;次到第&lt;span class="math"&gt;\(m-1\)&lt;/span&gt;次。&lt;/li&gt;
&lt;li&gt;隨著「次數增加」，Hash Function的值域可以視為&lt;span class="math"&gt;\(\{0,1,...,m-1\}\)&lt;/span&gt;的排列組合(permutation)，亦即：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$
\{h(k,0),h(k,1)...,h(k,m-1)\}=permutation\:of\:\{0,1,...,m-1\}
$$&lt;/div&gt;
&lt;p&gt;如此便可確保&lt;strong&gt;Probing&lt;/strong&gt;會檢查Table中的每一個slot。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
接下來介紹三種常見的&lt;strong&gt;Probing method&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linear Probing&lt;/li&gt;
&lt;li&gt;Quadratic Probing&lt;/li&gt;
&lt;li&gt;Double Hashing&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特別注意，&lt;strong&gt;Probing&lt;/strong&gt;的Hash Function與&lt;strong&gt;Chaining&lt;/strong&gt;的Hash Function略有不同(雖然都稱為Hash Function)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Chaining&lt;/strong&gt;使用的Hash Function只有一個參數，就是資料的&lt;strong&gt;Key&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Open Addressing&lt;/strong&gt;使用的Hash Function有兩個參數，一個是資料的&lt;strong&gt;Key&lt;/strong&gt;，另一個是&lt;strong&gt;Probing&lt;/strong&gt;的「次數」。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="lp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Linear Probing&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Linear Probing&lt;/strong&gt;定義為：&lt;/p&gt;
&lt;div class="math"&gt;$$
h(k,i)=(h'(k)+i)\bmod m
$$&lt;/div&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h'(k)\)&lt;/span&gt;即可視為&lt;strong&gt;Chaining&lt;/strong&gt;用的Hash Function，其值域(range)在&lt;span class="math"&gt;\(0\sim m-1\)&lt;/span&gt;之間：&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h'(k)\)&lt;/span&gt;可以使用Division Method、Multiplication Method或Universal Hashing等等。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h'(k)\)&lt;/span&gt;的結果就是&lt;strong&gt;Probing&lt;/strong&gt;的起點。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i\)&lt;/span&gt;表示&lt;strong&gt;Probing&lt;/strong&gt;的「次數」，在此因為&lt;span class="math"&gt;\(i\)&lt;/span&gt;的係數為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，因此&lt;span class="math"&gt;\(i\)&lt;/span&gt;也會是影響到&lt;strong&gt;Probing&lt;/strong&gt;順序的參數。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於&lt;span class="math"&gt;\(i\)&lt;/span&gt;是線性成長，產生的&lt;strong&gt;Probing Sequence&lt;/strong&gt;也會是線性的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由於&lt;span class="math"&gt;\(i=0\sim m-1\)&lt;/span&gt;，對每個Key而言，&lt;strong&gt;Probing Sequence&lt;/strong&gt;為
&lt;div class="math"&gt;$$
\{h'(k),h'(k)+1,h'(k)+2,...,h'(k)+(m-1)\}\bmod m
$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以上數列確實是一種&lt;span class="math"&gt;\(\{0,1,...,m-1\}\)&lt;/span&gt;的排列組合(permutation)。&lt;br /&gt;
觀察方法：因為&lt;span class="math"&gt;\(\bmod m\)&lt;/span&gt;會循環，所以可以先忽略&lt;span class="math"&gt;\(h'(k)\)&lt;/span&gt;，看剩下的值是否沒有重複地涵蓋了&lt;span class="math"&gt;\(0\sim m-1\)&lt;/span&gt;的每一個值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;意思是若第&lt;span class="math"&gt;\(1\)&lt;/span&gt;個slot滿了，就找第&lt;span class="math"&gt;\(2\)&lt;/span&gt;個slot；若第&lt;span class="math"&gt;\(2\)&lt;/span&gt;個slot滿了，就找第&lt;span class="math"&gt;\(3\)&lt;/span&gt;個slot，依此類推，當目前的slot已經有item時，就找繼續找「下一個&lt;strong&gt;index&lt;/strong&gt;」的slot，檢查其是否是空的。&lt;/p&gt;
&lt;p&gt;舉例來說，若&lt;span class="math"&gt;\(m=8\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(k)=k\bmod m\)&lt;/span&gt;，&lt;span class="math"&gt;\(h(k,i)=((k\bmod m)+i)\bmod m\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=7\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(7)=7\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;為&lt;span class="math"&gt;\(\{7,0,1,2,3,4,5,6\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=13\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(13)=5\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;為&lt;span class="math"&gt;\(\{5,6,7,0,1,2,3,4\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=50\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(50)=2\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;為&lt;span class="math"&gt;\(\{2,3,4,5,6,7,0,1\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=74\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(74)=2\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;為&lt;span class="math"&gt;\(\{2,3,4,5,6,7,0,1\}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/OpenAddressing/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;h4&gt;缺點&lt;/h4&gt;
&lt;p&gt;由以上可以觀察出，&lt;strong&gt;Linear Probing&lt;/strong&gt;只有&lt;span class="math"&gt;\(m\)&lt;/span&gt;個&lt;strong&gt;Probing Sequence&lt;/strong&gt;，而且很規律：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要「起點」決定，&lt;strong&gt;Probing Sequence&lt;/strong&gt;就決定(&lt;span class="math"&gt;\(i\)&lt;/span&gt;不斷加一)。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h'(k)=k\bmod m\)&lt;/span&gt;會產生&lt;span class="math"&gt;\(0\sim m-1\)&lt;/span&gt;的值，一共是&lt;span class="math"&gt;\(m\)&lt;/span&gt;個值作為起點。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因為&lt;strong&gt;Linear Probing&lt;/strong&gt;是「找下一個&lt;strong&gt;index&lt;/strong&gt;」的slot，所以如果Table中某個區塊已經擠滿了item，若有某個&lt;strong&gt;Key&lt;/strong&gt;又被&lt;span class="math"&gt;\(h'(k)\)&lt;/span&gt;分配到該區塊的附近，就會使得該區塊「越來越擠」，這種現象稱為&lt;strong&gt;primary clustering&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖三，&lt;code&gt;Table[2,3,4,5]&lt;/code&gt;已經有item，再來一個&lt;span class="math"&gt;\(k=2\)&lt;/span&gt;，經過&lt;strong&gt;Probing&lt;/strong&gt;被分配到&lt;code&gt;Table[6]&lt;/code&gt;，使得&lt;code&gt;Table[2,3,4,5,6]&lt;/code&gt;的區塊變得更擠。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這使得之後被分配到這個區塊的item之&lt;strong&gt;insert&lt;/strong&gt;、&lt;strong&gt;delete&lt;/strong&gt;、&lt;strong&gt;search&lt;/strong&gt;的時間複雜度將會受到「前面擋住的item數量」影響。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;圖三的&lt;span class="math"&gt;\(k=2\)&lt;/span&gt;經過&lt;span class="math"&gt;\(5\)&lt;/span&gt;次&lt;strong&gt;Probing&lt;/strong&gt;才順利找到空的slot存進Hash Table。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，如果能夠產生一個「比較不規律」的&lt;strong&gt;Probing Sequence&lt;/strong&gt;，例如&lt;span class="math"&gt;\(\{0,1,3,6,2,7,5,4\}\)&lt;/span&gt;，就能儘量避免把「某個區塊變得更擠」，減少&lt;strong&gt;primary clustering&lt;/strong&gt;發生的可能。&lt;/p&gt;
&lt;p&gt;接下來介紹的&lt;strong&gt;Quadratic Probing&lt;/strong&gt;即可產生「比較亂的」&lt;strong&gt;Probing Sequence&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="qp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Quadratic Probing&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Quadratic Probing&lt;/strong&gt;定義為：&lt;/p&gt;
&lt;div class="math"&gt;$$
h(k,i)=(h'(k)+c_{1}i+c_{2}i^{2})\bmod m\,, c_{2}\neq 0
$$&lt;/div&gt;
&lt;p&gt;與&lt;strong&gt;Linear Probing&lt;/strong&gt;相比，多了&lt;span class="math"&gt;\(i\)&lt;/span&gt;的二次項及係數(&lt;span class="math"&gt;\(c_{2}i^{2}\)&lt;/span&gt;)，並且一次項也多了係數&lt;span class="math"&gt;\(c_{1}\)&lt;/span&gt;，有機會產生「較為分散」的&lt;strong&gt;Probing Sequence&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不過並不是任意的&lt;span class="math"&gt;\(c_{1}\)&lt;/span&gt;、&lt;span class="math"&gt;\(c_{2}\)&lt;/span&gt;及&lt;span class="math"&gt;\(m\)&lt;/span&gt;都能夠使&lt;span class="math"&gt;\(h(k,i)\)&lt;/span&gt;產生&lt;span class="math"&gt;\(\{0,1,...,m-1\}\)&lt;/span&gt;的排列組合(permutation)，以下提供兩種常見的選法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一種：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;選擇&lt;span class="math"&gt;\(c_{1}=c_{2}=0.5, m=2^{P}\)&lt;/span&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$
h(k,i)=(h'(k)+0.5i+0.5i^{2})\bmod m
$$&lt;/div&gt;
&lt;p&gt;產生的&lt;strong&gt;Probing Sequence&lt;/strong&gt;為：&lt;/p&gt;
&lt;div class="math"&gt;$$
\{h'(k),h'(k)+1,h'(k)+3,h'(k)+6,h'(k)+10,h'(k)+15,h'(k)+21,h'(k)+28...\}\bmod m
$$&lt;/div&gt;
&lt;p&gt;每一次在找下一格slot時，「跨距」都會再增加一，第一次跨「&lt;span class="math"&gt;\(1\)&lt;/span&gt;格」，下一次跨「&lt;span class="math"&gt;\(2\)&lt;/span&gt;格」，再下一次跨「&lt;span class="math"&gt;\(3\)&lt;/span&gt;格」，依此類推。&lt;/p&gt;
&lt;p&gt;例如，若考慮&lt;span class="math"&gt;\(m=8\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;為：&lt;/p&gt;
&lt;div class="math"&gt;$$
\{h'(k),h'(k)+1,h'(k)+3,h'(k)+6,h'(k)+2,h'(k)+7,h'(k)+5,h'(k)+4\}\bmod 8
$$&lt;/div&gt;
&lt;p&gt;確認其確實是&lt;span class="math"&gt;\(\{0,1,...,7\}\)&lt;/span&gt;的排列組合，並且是比&lt;strong&gt;Linear Probing&lt;/strong&gt;更跳躍的方式找下一格slot。&lt;br /&gt;
幾個範例如下，考慮&lt;span class="math"&gt;\(h'(k)=k\bmod 8\)&lt;/span&gt;，見圖四(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=2\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(k)=2\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;：&lt;span class="math"&gt;\(\{2,3,5,0,4,1,7,6\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=6\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(k)=6\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;：&lt;span class="math"&gt;\(\{6,7,1,4,0,5,3,2\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=9\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(k)=1\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;：&lt;span class="math"&gt;\(\{1,2,4,7,3,0,6,5\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=25\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(k)=1\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;：&lt;span class="math"&gt;\(\{1,2,4,7,3,0,6,5\}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/OpenAddressing/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
&lt;strong&gt;第二種：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="math"&gt;$$
h(k,i)=(h'(k)-(-1)^{i}{\lceil{\frac{i}{2}}\rceil}^{2})\bmod m\\where\:m\:be\:prime\:and\:m=4n+3,\:for\:some\:n
$$&lt;/div&gt;
&lt;p&gt;產生的&lt;strong&gt;Probing Sequence&lt;/strong&gt;為：&lt;/p&gt;
&lt;div class="math"&gt;$$
\{h'(k),h'(k)+1,h'(k)-1,h'(k)+4,h'(k)-4,h'(k)+9,h'(k)-9,h'(k)+16,h'(k)-16...\}\bmod m
$$&lt;/div&gt;
&lt;p&gt;這種方式很有創意地在正負&lt;span class="math"&gt;\(i^{2}\)&lt;/span&gt;跳躍，並且要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt;是質數；&lt;/li&gt;
&lt;li&gt;滿足&lt;span class="math"&gt;\(m=4n+3\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(n\)&lt;/span&gt;是某些能夠另&lt;span class="math"&gt;\(m\)&lt;/span&gt;成為質數的正整數。&lt;ul&gt;
&lt;li&gt;例如：&lt;span class="math"&gt;\((m,n)=(7,1),(11,2),(19,4),(23,5)...\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，選擇&lt;span class="math"&gt;\(m=7\)&lt;/span&gt;，那麼&lt;strong&gt;Probing Sequence&lt;/strong&gt;即為：&lt;/p&gt;
&lt;div class="math"&gt;$$
\{h'(k),h'(k)+1,h'(k)-1,h'(k)+4,h'(k)-4,h'(k)+9,h'(k)-9\}\bmod 7\\
=\{h'(k),h'(k)+1,h'(k)+6,h'(k)+4,h'(k)+3,h'(k)+2,h'(k)+5\}\bmod 7
$$&lt;/div&gt;
&lt;p&gt;確認其確實是&lt;span class="math"&gt;\(\{0,1,...,6\}\)&lt;/span&gt;的排列組合，並且是比&lt;strong&gt;Linear Probing&lt;/strong&gt;更跳躍的方式找下一格slot。&lt;br /&gt;
幾個範例如下，考慮&lt;span class="math"&gt;\(h'(k)=k\bmod 7\)&lt;/span&gt;，見圖四(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=2\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(k)=2\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;：&lt;span class="math"&gt;\(\{2,3,1,6,5,4,0\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=6\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(k)=6\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;：&lt;span class="math"&gt;\(\{6,0,5,3,2,1,4\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=19\)&lt;/span&gt;，&lt;span class="math"&gt;\(h'(k)=5\)&lt;/span&gt;，&lt;strong&gt;Probing Sequence&lt;/strong&gt;：&lt;span class="math"&gt;\(\{5,6,4,2,1,0,3\}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/OpenAddressing/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;整體而言，&lt;strong&gt;Quadratic Probing&lt;/strong&gt;的優缺點：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;優點：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;透過較為跳躍的方式找下一格空的slot，&lt;strong&gt;Quadratic Probing&lt;/strong&gt;可以有效避免&lt;strong&gt;primary clustering&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺點：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;並不是任意的&lt;span class="math"&gt;\(c_{1},c_{2},m\)&lt;/span&gt;都可以產生&lt;span class="math"&gt;\(\{0,1,...,m-1\}\)&lt;/span&gt;的排列組合(permutation)，所以參數需要慎選。&lt;/p&gt;
&lt;p&gt;並且，如同&lt;strong&gt;Linear Probing&lt;/strong&gt;，一旦「起點&lt;span class="math"&gt;\(h'(k)\)&lt;/span&gt;」決定好，&lt;strong&gt;Probing Sequence&lt;/strong&gt;就決定好了，因此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同樣只有&lt;span class="math"&gt;\(m\)&lt;/span&gt;個不同的&lt;strong&gt;Probing Sequence&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果&lt;span class="math"&gt;\(h'(k_{1})=h'(k_{2})\,,k_{1}\neq k_{2}\)&lt;/span&gt;，那麼這兩個item會有同樣的&lt;strong&gt;Probing&lt;/strong&gt;順序。&lt;/li&gt;
&lt;li&gt;可以想像的是，若&lt;span class="math"&gt;\(h'(k)\)&lt;/span&gt;一直把item分配到同一格slot起點，那麼較晚加入Table的item之&lt;strong&gt;insert&lt;/strong&gt;、&lt;strong&gt;search&lt;/strong&gt;、&lt;strong&gt;delete&lt;/strong&gt;的時間複雜度仍然會增加，這稱為&lt;strong&gt;secondary clustering&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="dh"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Double Hashing&lt;/h3&gt;
&lt;p&gt;根據上面兩種&lt;strong&gt;Probing Method&lt;/strong&gt;可以看出，透過調整「次數&lt;span class="math"&gt;\(i\)&lt;/span&gt;」的函式形式，也就調整了「跨距」方式，便能夠製造出「較為分散」的&lt;strong&gt;Probing Sequence&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;Double Hashing&lt;/strong&gt;就直接加入「第二個Hash Function」來影響「次數&lt;span class="math"&gt;\(i\)&lt;/span&gt;」，定義為：&lt;/p&gt;
&lt;div class="math"&gt;$$
h(k,i)=(h_{1}(k)+ih_{2}(k)) \bmod m 
$$&lt;/div&gt;
&lt;p&gt;並且要求，&lt;span class="math"&gt;\(h_{2}(k)\)&lt;/span&gt;一定要與&lt;span class="math"&gt;\(m\)&lt;/span&gt;互質(&lt;span class="math"&gt;\(h_{2}(k)\)&lt;/span&gt; be relatively prime to &lt;span class="math"&gt;\(m\)&lt;/span&gt;)。&lt;/p&gt;
&lt;p&gt;這裡有項神奇的事實：若&lt;span class="math"&gt;\(a\)&lt;/span&gt;與&lt;span class="math"&gt;\(b\)&lt;/span&gt;互質，那麼&lt;span class="math"&gt;\((a\times i)\bmod b\,,\:for\:i=0,1...,b-1\)&lt;/span&gt;，正好可以形成&lt;span class="math"&gt;\(\{0,1,...,b-1\}\)&lt;/span&gt;的排列組合(permutation)。&lt;/p&gt;
&lt;p&gt;舉例來說，若&lt;span class="math"&gt;\(a=5,b=8\)&lt;/span&gt;，那麼：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i=0\)&lt;/span&gt;，&lt;span class="math"&gt;\((5\times 0=0)\bmod 8=0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i=1\)&lt;/span&gt;，&lt;span class="math"&gt;\((5\times 1=5)\bmod 8=5\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i=2\)&lt;/span&gt;，&lt;span class="math"&gt;\((5\times 2=10)\bmod 8=2\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i=3\)&lt;/span&gt;，&lt;span class="math"&gt;\((5\times 3=15)\bmod 8=7\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i=4\)&lt;/span&gt;，&lt;span class="math"&gt;\((5\times 4=20)\bmod 8=4\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i=5\)&lt;/span&gt;，&lt;span class="math"&gt;\((5\times 5=25)\bmod 8=1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i=6\)&lt;/span&gt;，&lt;span class="math"&gt;\((5\times 6=30)\bmod 8=6\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i=7\)&lt;/span&gt;，&lt;span class="math"&gt;\((5\times 7=35)\bmod 8=3\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，要求&lt;span class="math"&gt;\(h_{2}(k)\)&lt;/span&gt;與&lt;span class="math"&gt;\(m\)&lt;/span&gt;互質確實可以產生&lt;span class="math"&gt;\(\{0,1,...,m-1\}\)&lt;/span&gt;的排列組合。&lt;/p&gt;
&lt;p&gt;以下提供幾種常見的&lt;span class="math"&gt;\(h_{2}(k)\)&lt;/span&gt;選擇：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一種：&lt;/strong&gt;&lt;span class="math"&gt;\(m=2^{P}\)&lt;/span&gt;，&lt;span class="math"&gt;\(h_{2}(k)\)&lt;/span&gt;的值域(range)為奇數(odd number)，&lt;span class="math"&gt;\(h_{2}(k)=2n+1\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為奇數一定與&lt;span class="math"&gt;\(2^{P}\)&lt;/span&gt;互質，所以滿足。&lt;/li&gt;
&lt;li&gt;不過由於&lt;span class="math"&gt;\(h_{2}(k)\)&lt;/span&gt;的值域(range)只有奇數(odd number)，可能不能視為在&lt;strong&gt;Chainine&lt;/strong&gt;所使用的Hash Function。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第二種：&lt;/strong&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt;是質數，&lt;span class="math"&gt;\(h_{2}(k)\)&lt;/span&gt;的值域(range)介於&lt;span class="math"&gt;\(1\sim m-1\)&lt;/span&gt;，&lt;span class="math"&gt;\(0&amp;lt;h_{2}(k)&amp;lt;m-1\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;span class="math"&gt;\(m\)&lt;/span&gt;是質數，那麼&lt;span class="math"&gt;\(m\)&lt;/span&gt;必定與&lt;span class="math"&gt;\(1\sim m-1\)&lt;/span&gt;的任何數互質。&lt;/li&gt;
&lt;li&gt;由圖五的範例可以觀察出，即使不同的&lt;strong&gt;Key&lt;/strong&gt;被&lt;span class="math"&gt;\(h_{1}(k)\)&lt;/span&gt;分配到相同的起點slot，但是&lt;span class="math"&gt;\(h_{2}()\)&lt;/span&gt;有很大的機會調整出不同的「跨距」(&lt;span class="math"&gt;\(i\)&lt;/span&gt;的係數)，使得兩個不同&lt;strong&gt;Key&lt;/strong&gt;的item有不同的&lt;strong&gt;Probing Sequence&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/OpenAddressing/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三種：&lt;/strong&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt;是質數，&lt;span class="math"&gt;\(h_{2}(k)=R-k%R\)&lt;/span&gt;，&lt;span class="math"&gt;\(R\)&lt;/span&gt;也是質數，並且&lt;span class="math"&gt;\(R&amp;lt;m\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;與第二種類似的概念產生&lt;span class="math"&gt;\(m\)&lt;/span&gt;與&lt;span class="math"&gt;\(h_{2}(k)\)&lt;/span&gt;互質，不過可以製造出不同的&lt;strong&gt;Probing Sequence&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
&lt;strong&gt;Double Hashing的優點：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因為同時有兩個Hash Function(&lt;span class="math"&gt;\(h_{1}(k),h_{2}(k)\)&lt;/span&gt;)，若兩者個值域都是&lt;span class="math"&gt;\(\{0,1,...,m-1\}\)&lt;/span&gt;，那麼&lt;strong&gt;Double Hashing&lt;/strong&gt;一共可以產生&lt;span class="math"&gt;\(m^{2}\)&lt;/span&gt;種不同的&lt;strong&gt;Probing Sequence&lt;/strong&gt;，因此可以大大減緩&lt;strong&gt;clustering&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除非&lt;span class="math"&gt;\((h_{1}(k_{1}),h_{2}(k_{1}))=(h_{1}(k_{2}),h_{2}(k_{2}))\)&lt;/span&gt;的情況才會發生兩個&lt;strong&gt;Key&lt;/strong&gt;有完全相同的&lt;strong&gt;Probing Sequence&lt;/strong&gt;，機率較低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;範例程式碼簡單地以&lt;strong&gt;Quadratic Probing&lt;/strong&gt;(&lt;span class="math"&gt;\(c_{1}=c_{2}=0.5\)&lt;/span&gt;，&lt;span class="math"&gt;\(m=2^{P}\)&lt;/span&gt;)實作出&lt;strong&gt;Open Addressing&lt;/strong&gt;的Hash Table。&lt;/p&gt;
&lt;p&gt;關於&lt;strong&gt;Rehashing&lt;/strong&gt;、調整Table大小的議題與&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tablechaining.html#ll"&gt;Hash Table：Chaining&lt;/a&gt;的方法大同小異，不過&lt;strong&gt;load factor&lt;/strong&gt;可能要限制得更嚴謹(請看下一小節的挑論)，這裡就不再贅述。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HashOpenAddress&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dict&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;QuadraticProbing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// TableDoubling()&lt;/span&gt;
    &lt;span class="c1"&gt;// TableShrinking()&lt;/span&gt;
    &lt;span class="c1"&gt;// Rehashing()&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;HashOpenAddress&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;HashOpenAddress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="nf"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Display&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;HashOpenAddress&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QuadraticProbing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;...data not found&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashOpenAddress&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QuadraticProbing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;...data not found&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashOpenAddress&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QuadraticProbing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hash Table Overflow&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;HashOpenAddress&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;QuadraticProbing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// c1 = c2 = 0.5&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashOpenAddress&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;slot#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: (&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;
             &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;HashOpenAddress&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// probing sequence:&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 1,2,4,7,3,0,6,5 -&amp;gt; 1&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;yellow&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// 2,3,5,0,4,1,7,6 -&amp;gt; 2&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;red&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;           &lt;span class="c1"&gt;// 5,6,0,3,7,4,2,1 -&amp;gt; 5&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;white&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 2,3,5,0,4,1,7,6 -&amp;gt; 3&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;black&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 0,1,3,6,2,7,5,4 -&amp;gt; 0&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;47&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;gray&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 7,0,2,5,1,6,4,3 -&amp;gt; 7&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;purple&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// 2,3,5,0,4,1,7,6 -&amp;gt; 4&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;deep purple&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 4,5,7,2,6,3,1,0 -&amp;gt; 6&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;green&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// hash table overflow&lt;/span&gt;

    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;number#90 is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;after deleting (90,purple):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;number#90 is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;orange&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// 4,5,7,2,6,3,1,0 -&amp;gt; 4&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Display&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;yellow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;white&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;

&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;black&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;yellow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;white&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;purple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;deep&lt;/span&gt; &lt;span class="n"&gt;purple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;47&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;Hash&lt;/span&gt; &lt;span class="n"&gt;Table&lt;/span&gt; &lt;span class="n"&gt;Overflow&lt;/span&gt;

&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;purple&lt;/span&gt;

&lt;span class="n"&gt;after&lt;/span&gt; &lt;span class="n"&gt;deleting&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;purple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt;

&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;black&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;yellow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;white&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;orange&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;deep&lt;/span&gt; &lt;span class="n"&gt;purple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;47&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="comp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;比較Open Addressing與Chaining&lt;/h2&gt;
&lt;h3&gt;time complxity&lt;/h3&gt;
&lt;p&gt;對於&lt;strong&gt;Open Addressing&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert：要找到空的slot才能&lt;code&gt;insert()&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;找到空的slot，也就是沒有找到與&lt;strong&gt;Key&lt;/strong&gt;相符合的item，稱為&lt;strong&gt;Unsuccessful Search&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;delete：要找到與&lt;strong&gt;Key&lt;/strong&gt;相符合的item才能&lt;code&gt;delete()&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;找到與&lt;strong&gt;Key&lt;/strong&gt;相符合的item，稱為&lt;strong&gt;Successful Search&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上兩者都需要進行&lt;code&gt;search&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;對於&lt;strong&gt;Chaining&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert：可以透過Linked list的&lt;code&gt;push_front()&lt;/code&gt;以&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;完成。&lt;/li&gt;
&lt;li&gt;delete：需要在Linked list進行&lt;strong&gt;traversal&lt;/strong&gt;，如同&lt;code&gt;search&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;不論是「搜尋成功」還是「搜尋不成功」，時間複雜度都與Linked list的長度有關。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表一是&lt;strong&gt;Open Addressing&lt;/strong&gt;與&lt;strong&gt;Chaining&lt;/strong&gt;針對「搜尋」的時間複雜度比較，分成「搜尋成功」與「搜尋不成功」：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;&lt;/th&gt;
&lt;th align="center"&gt;Open Addressing&lt;/th&gt;
&lt;th align="center"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Chaining&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Unsuccessful Search&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{1}{1-\alpha}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(1+\alpha\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Successful Search&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{1}{\alpha}\ln{\frac{1}{1-\alpha}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(1+\alpha\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：Open Addressing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;關於&lt;strong&gt;Open Addressing&lt;/strong&gt;之時間複雜度證明，請參考：&lt;a href="http://fmt.cs.utwente.nl/courses/adc/lec5.pdf"&gt;Joost-Pieter Katoen：Hashing/page35、36&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;效率：考慮load factor&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;以&lt;strong&gt;Open Addressing&lt;/strong&gt;之&lt;strong&gt;Unsuccessful Search&lt;/strong&gt;為例，&lt;span class="math"&gt;\(O(\frac{1}{1-\alpha})\)&lt;/span&gt;，根據其時間複雜度可以觀察出，當&lt;strong&gt;load factor&lt;/strong&gt;&lt;span class="math"&gt;\(\alpha=\frac{n}{m}\)&lt;/span&gt;趨近於&lt;span class="math"&gt;\(1\)&lt;/span&gt;時(Table快被放滿)，那麼時間複雜度會趨近無限大：&lt;span class="math"&gt;\(\lim_{\alpha\rightarrow1}O(\frac{1}{1-\alpha})\rightarrow O(\infty)\)&lt;/span&gt;，這種情況便不適合使用&lt;strong&gt;Open Addressing&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不過&lt;strong&gt;Open Addressing&lt;/strong&gt;使用Array存放資料，不需要頻繁使用動態記憶體配置(&lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt;/&lt;code&gt;malloc&lt;/code&gt;/&lt;code&gt;free&lt;/code&gt;)，所以如果&lt;strong&gt;load factor&lt;/strong&gt;沒有超過&lt;span class="math"&gt;\(0.5\)&lt;/span&gt;(有些使用&lt;span class="math"&gt;\(0.7\)&lt;/span&gt;)，那麼&lt;strong&gt;Open Addressing&lt;/strong&gt;會是不錯的選擇。&lt;/p&gt;
&lt;h3&gt;memory使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Chaining&lt;/strong&gt;使用Linked list，每個node裡面會帶一個&lt;strong&gt;pointer&lt;/strong&gt;記錄下一個node的記憶體位置，因此會比純粹使用Array存放資料的&lt;strong&gt;Open Addressing&lt;/strong&gt;多花一點記憶體空間。&lt;/p&gt;
&lt;p&gt;不過前面提到，&lt;strong&gt;Open Addressing&lt;/strong&gt;考慮&lt;strong&gt;load factor&lt;/strong&gt;儘量不要超過&lt;span class="math"&gt;\(0.5\)&lt;/span&gt;，因此將有近一半的記憶體位置閒置。&lt;/p&gt;
&lt;p&gt;所以這兩種處理&lt;strong&gt;Collision&lt;/strong&gt;的方法沒有絕對的好壞，應該要是情況而定。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是以&lt;strong&gt;Open Addressing&lt;/strong&gt;解決&lt;strong&gt;Collision&lt;/strong&gt;之介紹。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch11&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cs.ntou.edu.tw/lincc/courses/al99/pdf/Algorithm-Ch11-Hash%20Tables.pdf"&gt;林清池：Algorithms Chapter 11 Hash Tables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://faculty.kfupm.edu.sa/ICS/saquib/ICS202/Unit30_Hashing3.pdf"&gt;Collision Resolution: Open Addressing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://gki.informatik.uni-freiburg.de/teaching/ss11/theoryI/08_Open_Addressing.pdf"&gt;Jan-Georg Smaus：8 Hashing: Open addressing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fmt.cs.utwente.nl/courses/adc/lec5.pdf"&gt;Joost-Pieter Katoen：Hashing/page35、36&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Hash Table系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html"&gt;Hash Table：Intro(簡介)&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tablechaining.html"&gt;Hash Table：Chaining&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableopen-addressing.html"&gt;Hash Table：Open Addressing&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Dictionary"></category><category term="Hash Table"></category></entry><entry><title>Hash Table：Chaining</title><link href="http://alrightchiu.github.io/SecondRound/hash-tablechaining.html" rel="alternate"></link><updated>2016-05-25T21:32:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-05-25:SecondRound/hash-tablechaining.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將延續&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html"&gt;Hash Table：Intro(簡介)&lt;/a&gt;的議題，介紹&lt;strong&gt;Chaining&lt;/strong&gt;來解決&lt;strong&gt;Collision&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其中將會用到Linked list的概念，若不熟悉請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List: Intro(簡介)&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#chaining"&gt;Chaining的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#stl"&gt;偷懶：使用STL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ll"&gt;不偷懶：用pointer串出Linked list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Hash Table系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="chaining"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Chaining的概念&lt;/h2&gt;
&lt;p&gt;如果利用&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html#dm"&gt;Division Method&lt;/a&gt;實作Hash Function：&lt;/p&gt;
&lt;div class="math"&gt;$$
h(Key)=Key\bmod m
$$&lt;/div&gt;
&lt;p&gt;若選擇&lt;span class="math"&gt;\(m=6\)&lt;/span&gt;，那麼對於&lt;strong&gt;Key&lt;/strong&gt;為&lt;span class="math"&gt;\(14,16,26,36,47,50,71,90\)&lt;/span&gt;的item，進行&lt;strong&gt;Hashing&lt;/strong&gt;後將會有如圖一的&lt;strong&gt;Collision&lt;/strong&gt;發生。&lt;/p&gt;
&lt;p&gt;解決的辦法，就是將被分配到同一個slot的item用&lt;strong&gt;Linked list&lt;/strong&gt;串起來，這就是&lt;strong&gt;Chaining&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Chaining/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;有了Linked list處理被分配到同ㄧ個slot的item，Hash Table的三項資料處理分別修正成：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Insert&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先利用Hash Function取得&lt;strong&gt;Table&lt;/strong&gt;的&lt;strong&gt;index&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;接著，只要在每一個slot的list之&lt;strong&gt;front&lt;/strong&gt;加入item，即可保證在&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;的時間複雜度完成。&lt;ul&gt;
&lt;li&gt;參考：&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html#front"&gt;Linked list:push_front()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Serach&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先利用Hash Function取得&lt;strong&gt;Table&lt;/strong&gt;的&lt;strong&gt;index&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;再利用Linked list的&lt;strong&gt;traversal&lt;/strong&gt;尋找item。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Delete&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先利用Hash Function取得&lt;strong&gt;Table&lt;/strong&gt;的&lt;strong&gt;index&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;再利用Linked list的&lt;strong&gt;traversal&lt;/strong&gt;尋找欲刪除的item。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;關於&lt;strong&gt;Search&lt;/strong&gt;與&lt;strong&gt;Delete&lt;/strong&gt;的時間複雜度：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worst case&lt;/strong&gt;：&lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;，所有item都被很遜的Hash Function分配到同一個slot。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;average case&lt;/strong&gt;：&lt;span class="math"&gt;\(O(1+\alpha)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(\alpha=\frac{n}{m}\)&lt;/span&gt;稱為&lt;strong&gt;load factor&lt;/strong&gt;，其物理意義為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「資料數量(&lt;span class="math"&gt;\(n\)&lt;/span&gt;)」與「slot個數(&lt;span class="math"&gt;\(m\)&lt;/span&gt;)」的比例。&lt;/li&gt;
&lt;li&gt;也會是list的&lt;strong&gt;expected length&lt;/strong&gt;(list的平均長度)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖二為例，若&lt;span class="math"&gt;\(m=3,n=6\)&lt;/span&gt;，那麼&lt;span class="math"&gt;\(\alpha=n\m=2\)&lt;/span&gt;，也就是「平均」每個list會被分配到&lt;span class="math"&gt;\(\alpha=2\)&lt;/span&gt;個item，所以&lt;strong&gt;Search&lt;/strong&gt;的時間複雜度就是list長度&lt;span class="math"&gt;\(O(\alpha)\)&lt;/span&gt;，再加上Hash Function的時間複雜度&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;，便得到&lt;span class="math"&gt;\(O(1+\alpha)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Chaining/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：以上四種皆為可能的情形，其中右下圖為平均的/期望值結果。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若「資料數量(&lt;span class="math"&gt;\(n\)&lt;/span&gt;)」與「slot個數(&lt;span class="math"&gt;\(m\)&lt;/span&gt;)」的比例具有&lt;span class="math"&gt;\(n=O(m)\)&lt;/span&gt;的關係，再加上一個不會把所有item分配到同一個slot的正常Hash Function，那麼可以想像，&lt;strong&gt;Search&lt;/strong&gt;與&lt;strong&gt;Delete&lt;/strong&gt;的時間可以在接近&lt;/p&gt;
&lt;div class="math"&gt;$$
O(1+\alpha)=O(1+constant)=O(1)
$$&lt;/div&gt;
&lt;p&gt;的情況下完成。&lt;br /&gt;
詳細證明請參考：&lt;a href="http://users.ece.utexas.edu/~adnan/360C/hash.pdf"&gt;Adnan Aziz：Hash Tables&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;以下提供兩份基本的Hash Table實作方法：&lt;/p&gt;
&lt;p&gt;第一份用標準模板函式庫(STL)的&lt;code&gt;std::vector&amp;lt;std::list&amp;lt;struct&amp;gt;&amp;gt;&lt;/code&gt;處理Hash Table和&lt;strong&gt;Chaining&lt;/strong&gt;。&lt;br /&gt;
重點放在：&lt;code&gt;Insert()&lt;/code&gt;、&lt;code&gt;Delete()&lt;/code&gt;、&lt;code&gt;Search()&lt;/code&gt;與&lt;code&gt;Prehashing()&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;第二份很老實地用&lt;strong&gt;pointer&lt;/strong&gt;串出Linked list，重點將放在&lt;code&gt;TableDoubling()&lt;/code&gt;、&lt;code&gt;TableShrinking()&lt;/code&gt;與&lt;code&gt;Rehashing()&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="stl"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;偷懶：使用STL&lt;/h3&gt;
&lt;p&gt;以下範例程式碼包含了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct dict&lt;/code&gt;為自定義的&lt;strong&gt;dictionary&lt;/strong&gt;，其中&lt;code&gt;key&lt;/code&gt;與&lt;code&gt;value&lt;/code&gt;皆為&lt;code&gt;std::string&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class HashChain_std&lt;/code&gt;表示以&lt;code&gt;std::vector&amp;lt;std::list&amp;lt;dict&amp;gt;&amp;gt;&lt;/code&gt;建立Hash Table，其中包含了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Insert()&lt;/code&gt;、&lt;code&gt;Delete()&lt;/code&gt;、&lt;code&gt;Search()&lt;/code&gt;、&lt;code&gt;DisplayTable()&lt;/code&gt;等基本函式。&lt;ul&gt;
&lt;li&gt;涉及Linked list中的&lt;code&gt;push_front()&lt;/code&gt;與&lt;strong&gt;traversal&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;traversal&lt;/strong&gt;以&lt;code&gt;std::list::iterator&lt;/code&gt;處理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PreHashing()&lt;/code&gt;：目的是把資料形態為&lt;code&gt;string&lt;/code&gt;的key轉換成&lt;code&gt;int&lt;/code&gt;。範例程式定義成：&lt;ul&gt;
&lt;li&gt;挑選一個正整數作為「底數(&lt;span class="math"&gt;\(a\)&lt;/span&gt;)」(稍後將進行指數運算)，將字串先經由ASCII編碼轉換成正整數，再乘上&lt;span class="math"&gt;\(a^{index}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若字串&lt;code&gt;key&lt;/code&gt;為「Jordan」，&lt;span class="math"&gt;\(a=9\)&lt;/span&gt;，便轉換出&lt;br /&gt;
&lt;span class="math"&gt;\(ASCII(J)\times9^5+ASCII(o)\times9^4+ASCII(r)\times9^3+ASCII(d)\times9^2+ASCII(a)\times9^1+ASCII(n)\times9^0\\ =74\times9^5+111\times9^4+114\times9^3+100\times9^2+97\times9+110\\ =5190086\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HashFunction()&lt;/code&gt;：此處使用&lt;strong&gt;Division method&lt;/strong&gt;，將&lt;code&gt;PreHashing()&lt;/code&gt;得到的整數除以Table大小(&lt;span class="math"&gt;\(m\)&lt;/span&gt;)後取餘數。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;main()&lt;/code&gt;中以「假設NBA官網要建立球員資料，記錄每個球員所屬的球隊」為例示範Hash Table應用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;                        &lt;span class="c1"&gt;// self-defined dictionary&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                     &lt;span class="c1"&gt;//  key  for Name (eg:Jordan)&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// value for Team (eg:Bulls)&lt;/span&gt;
    &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;     
    &lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HashChain_std&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                &lt;span class="c1"&gt;// size of table&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// count: number of data&lt;/span&gt;

    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// hash table with linked list&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;PreHashing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// turn string_type_key to int_type_key&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// using Division method&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;HashChain_std&lt;/span&gt;&lt;span class="p"&gt;(){};&lt;/span&gt;                       
    &lt;span class="n"&gt;HashChain_std&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="c1"&gt;// allocate memory for each slot&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="nf"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                  
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;HashChain_std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// two steps: 1. get index from hash function&lt;/span&gt;
    &lt;span class="c1"&gt;//            2. traversal in linked list&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;...&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;no such data&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChain_std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// two steps: 1. get index from hash function&lt;/span&gt;
    &lt;span class="c1"&gt;//            2. traversal in linked list&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChain_std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// two steps: 1. get index from hash function&lt;/span&gt;
    &lt;span class="c1"&gt;//            2. insert data at the front of linked list&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;             
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;HashChain_std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PreHashing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// if   key_str = Jordan, exp = 9&lt;/span&gt;
    &lt;span class="c1"&gt;// then key_int = ASCII(J)*9^5+ASCII(o)*9^4+ASCII(r)*9^3&lt;/span&gt;
    &lt;span class="c1"&gt;//               +ASCII(d)*9^2+ASCII(a)*9^1+ASCII(n)*9^0&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;exp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="c1"&gt;// choose randomly &lt;/span&gt;
        &lt;span class="n"&gt;key_int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;key_int&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;key_int&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;HashChain_std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PreHashing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key_str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// Division method&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChain_std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;slot#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;) &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;HashChain_std&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;T-Mac&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Magic&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Bryant&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Lakers&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Webber&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Kings&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Arenas&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Wizards&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Davis&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Clippers&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Kidd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Nets&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;T-Mac is in &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;T-Mac&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;. &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Arenas is in &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Arenas&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;. &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Kidd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;T-Mac&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After deleing Kidd and T-Mac:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Kidd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Nets&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Bryant&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Lakers&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Arenas&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Wizards&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Webber&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Kings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Mac&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Magic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Davis&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Clippers&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Mac&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;Magic&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Arenas&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;Wizards&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;deleing&lt;/span&gt; &lt;span class="n"&gt;Kidd&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nl"&gt;Mac&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Bryant&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Lakers&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Arenas&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Wizards&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Webber&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Kings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;slot&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Davis&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Clippers&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="ll"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;不偷懶：用pointer串出Linked list&lt;/h3&gt;
&lt;p&gt;以下的範例程式碼紮紮實實用pointer串出Linked list，其中的&lt;code&gt;Insert()&lt;/code&gt;、&lt;code&gt;Delete()&lt;/code&gt;、&lt;code&gt;Search()&lt;/code&gt;、&lt;code&gt;DisplayTable()&lt;/code&gt;與上一小節大同小異，只是要加入Linked list的手法(改變&lt;strong&gt;pointer&lt;/strong&gt;指向)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashFunction()&lt;/code&gt;採取&lt;strong&gt;Multiplication method&lt;/strong&gt;，詳細討論請參考：&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html#mm"&gt;Hash Table：Intro(簡介)/Multiplication Method&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;比較酷的是因應&lt;strong&gt;load factor(&lt;span class="math"&gt;\(\alpha=\frac{n}{m}\)&lt;/span&gt;)&lt;/strong&gt;改變Table大小，以及改變之後把node從舊的Table搬到新的Table的&lt;code&gt;Rehashing()&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TableDoubling()&lt;/code&gt;：當&lt;span class="math"&gt;\(\alpha=\frac{n}{m}&amp;gt;1\)&lt;/span&gt;時，表示資料量大於slot數量，就把Table大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;加倍(並配置&lt;span class="math"&gt;\(m\)&lt;/span&gt;加倍後的Table)，如此在理論上可以儘量避免&lt;strong&gt;Collision&lt;/strong&gt;發生，增加搜尋資料的效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;為什麼選擇Table大小加倍(&lt;code&gt;size*=2&lt;/code&gt;)，而不是加一(&lt;code&gt;size++&lt;/code&gt;)、加二？&lt;br /&gt;
因為「加倍」的時間複雜度比較低，請參考：&lt;a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-9-table-doubling-karp-rabin/"&gt;MIT 6.006：Lecture 9: Table Doubling, Karp-Rabin，影片6分44秒開始&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;TableShrinking()&lt;/code&gt;：當&lt;span class="math"&gt;\(\alpha=\frac{n}{m}&amp;lt;\frac{1}{4}\)&lt;/span&gt;時，表示資料量減少到Table大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;的&lt;span class="math"&gt;\(\frac{1}{4}\)&lt;/span&gt;，就把Table大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;減半(並配置&lt;span class="math"&gt;\(m\)&lt;/span&gt;減半後的Table)，以節省記憶體空間。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;為什麼選擇&lt;span class="math"&gt;\(\alpha=\frac{n}{m}&amp;lt;\frac{1}{4}\)&lt;/span&gt;而不是&lt;span class="math"&gt;\(\alpha=\frac{n}{m}&amp;lt;\frac{1}{2}\)&lt;/span&gt;？&lt;br /&gt;
為了避免資料量在「臨界點」增增減減，造成不斷地動態配置記憶體(成本相當高)。&lt;/li&gt;
&lt;li&gt;例如：起初&lt;span class="math"&gt;\(n=8,m=8\)&lt;/span&gt;，現增加一筆資料，變成&lt;span class="math"&gt;\(n=9,m=8\)&lt;/span&gt;，將會觸發一次&lt;code&gt;TableDoubling()&lt;/code&gt;，變成&lt;span class="math"&gt;\(n=9,m=16\)&lt;/span&gt;。  &lt;br /&gt;
若接下來連續刪除兩筆資料，變成&lt;span class="math"&gt;\(n=7,m=16\)&lt;/span&gt;，因為&lt;span class="math"&gt;\(\frac{n}{m}&amp;lt;\frac{1}{2}\)&lt;/span&gt;，將會觸發一次&lt;code&gt;TableShrinking()&lt;/code&gt;，變成&lt;span class="math"&gt;\(n=7,m=8\)&lt;/span&gt;。&lt;br /&gt;
若接下來又連續增加兩筆資料，又將觸發一次&lt;code&gt;TableDoubling()&lt;/code&gt;...依此類推，為了避免這種不斷配置記憶體的情況發生，寧可犧牲一點記憶體空間，等到&lt;span class="math"&gt;\(\frac{n}{m}&amp;lt;\frac{1}{4}\)&lt;/span&gt;再觸發&lt;code&gt;TableShrinking()&lt;/code&gt;，重新為Table配置新的記憶體位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Rehashing()&lt;/code&gt;：當&lt;code&gt;TableDoubling()&lt;/code&gt;/&lt;code&gt;TableShrinking()&lt;/code&gt;增加/減半Table大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;後，需要把舊的Table上的資料(node)搬到新的Table上，過程將會透過Hash Function根據各筆資料的&lt;strong&gt;key&lt;/strong&gt;重新分配一次&lt;strong&gt;index&lt;/strong&gt;(因此稱為&lt;strong&gt;Rehashing&lt;/strong&gt;)，此&lt;strong&gt;index&lt;/strong&gt;即為資料在新的Table上的位置，如圖三。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;範例程式碼採取直接改變node之pointer的做法，不另外配置新的記憶體空間。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Chaining/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main()&lt;/code&gt;以「唱片行老闆想要以編號來整理各種樂風(genre)」示範Hash Table。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;math.h&amp;gt;       &lt;/span&gt;&lt;span class="c1"&gt;// floor()&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// number &lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// genre&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// pointer to remember memory address of next node&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HashChainNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                 &lt;span class="c1"&gt;// size: size of table, count: number of data&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// count/size = load factor&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// pointer to pointer, hash table  &lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// Multiplication method&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;TableDoubling&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;TableShrinking&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Rehashing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size_orig&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="p"&gt;(){};&lt;/span&gt;
    &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;           &lt;span class="c1"&gt;// allocate the first demension of table&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// initialization&lt;/span&gt;
            &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// ensure every slot points to NULL&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// consider TableDoubling()&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;           &lt;span class="c1"&gt;// consider TableShrinking()&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="nf"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;         &lt;span class="c1"&gt;// consider load factor&lt;/span&gt;
        &lt;span class="n"&gt;TableDoubling&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// if n/m &amp;gt; 1, then double the size of table&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// get index of slot&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// create new node to store data&lt;/span&gt;

    &lt;span class="c1"&gt;// push_front()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;           &lt;span class="c1"&gt;// eg: list: (empty), add4&lt;/span&gt;
        &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// eg: list: 4-&amp;gt;NULL&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                                &lt;span class="c1"&gt;// eg: list: 5-&amp;gt;9-&amp;gt;NULL  , add 4&lt;/span&gt;
        &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//     list: 5-&amp;gt;4-&amp;gt;9-&amp;gt;NULL&lt;/span&gt;
        &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// get index of slot&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;         &lt;span class="c1"&gt;// use two pointer for traversal in list&lt;/span&gt;
         &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// traversal in list, 3 cases:&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 1. data not found&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;                                     &lt;span class="c1"&gt;// 2. data found at first node in list&lt;/span&gt;
                                          &lt;span class="c1"&gt;// 3. data found at other position in list&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                    &lt;span class="c1"&gt;// eg: list:5-&amp;gt;2-&amp;gt;9-&amp;gt;NULL, want to delete 3&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;data not found.&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;               &lt;span class="c1"&gt;// eg: list:5-&amp;gt;2-&amp;gt;9-&amp;gt;NULL, want to delete 5&lt;/span&gt;
            &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// after deleting 5, list:2-&amp;gt;9-&amp;gt;NULL&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;                                     &lt;span class="c1"&gt;// current points to 5     &lt;/span&gt;

        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                                &lt;span class="c1"&gt;// eg: list:5-&amp;gt;2-&amp;gt;9-&amp;gt;NULL, want to delete 2&lt;/span&gt;
            &lt;span class="n"&gt;previous&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// after deleting 2, list:5-&amp;gt;9-&amp;gt;NULL&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;                                     &lt;span class="c1"&gt;// current points to 2&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;// consider load factor&lt;/span&gt;
        &lt;span class="n"&gt;TableShrinking&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="c1"&gt;// if n/m &amp;lt; 4, then shrink the table&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// get index of slot&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="c1"&gt;// current points to the first node in list&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;           &lt;span class="c1"&gt;// traversal in list&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;...&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;no such data&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// Multiplication method&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.6180339887&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="n"&gt;frac&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;frac&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;TableDoubling&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size_orig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// size_orig represents the original size of table&lt;/span&gt;
    &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// double the size of table&lt;/span&gt;
    &lt;span class="n"&gt;Rehashing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_orig&lt;/span&gt;&lt;span class="p"&gt;);;&lt;/span&gt;   &lt;span class="c1"&gt;// create new table with new larger size&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;TableShrinking&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size_orig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// size_orig represents the original size of table&lt;/span&gt;
    &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// shrink the size of table&lt;/span&gt;
    &lt;span class="n"&gt;Rehashing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_orig&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// create new table with new smaller size&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Rehashing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size_orig&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;newtable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;    &lt;span class="c1"&gt;// allocate memory for new table&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;       &lt;span class="c1"&gt;// initializetion &lt;/span&gt;
        &lt;span class="n"&gt;newtable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// ensure every node in slot points to NULL&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size_orig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// visit every node in the original table&lt;/span&gt;

        &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;curr_orig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;        &lt;span class="c1"&gt;// curr_orig: current node in original table&lt;/span&gt;
             &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;prev_orig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// prev_orig: following curr_orig &lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curr_orig&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;// traversal in list of each slot in original table&lt;/span&gt;

            &lt;span class="n"&gt;prev_orig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curr_orig&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// curr_orig will be directly move to new table&lt;/span&gt;
                                         &lt;span class="c1"&gt;// need prev_orig to keep pointer in original table&lt;/span&gt;

            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HashFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curr_orig&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// get index of slot in new table&lt;/span&gt;

            &lt;span class="c1"&gt;// push_front(), do not allocate new memory space for data&lt;/span&gt;
            &lt;span class="c1"&gt;// directly move node in original table to new table&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newtable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;       &lt;span class="c1"&gt;// means newtable[index] is empty&lt;/span&gt;
                &lt;span class="n"&gt;newtable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curr_orig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;newtable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// equivalent to curr_orig-&amp;gt;next = 0;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// if there is no initialization for newtable, segmentation faults might happen&lt;/span&gt;
            &lt;span class="c1"&gt;// because newtable[index] might not point to NULL &lt;/span&gt;
            &lt;span class="c1"&gt;// but newtable[index] is empty&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                                   &lt;span class="c1"&gt;// if newtable[index] is not empty&lt;/span&gt;
                &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newtable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// push_front()&lt;/span&gt;
                &lt;span class="n"&gt;newtable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curr_orig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;curr_orig&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;curr_orig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;prev_orig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// visit the next node in list in original table&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// release memory of original table&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newtable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// point table of object to new table&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// visit every node in table &lt;/span&gt;
                                        &lt;span class="c1"&gt;// and release the memory of each node &lt;/span&gt;
        &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="c1"&gt;// point *current to first node in list&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;       &lt;span class="c1"&gt;// traversal in list&lt;/span&gt;
            &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;previous&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;HashChainNode&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// visit every node in table &lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;#slot#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;) &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;HashChainNode&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;post rock&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;592&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shoegaze&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After inserting key(12),key(592):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6594&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;blues&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;        &lt;span class="c1"&gt;// evoke TableDoubling()&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After inserting key(6594), evoke TableDoubling():&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;folk&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After inserting key(7):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;123596&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hiphop&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;     &lt;span class="c1"&gt;// evoke TableDoubling()&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After inserting key(123596), evoke TableDoubling():&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;93&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;soul&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2288&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;indie&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;793&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;jazz&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After inserting key(93),key(2288),key(793):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8491&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;electro&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;      &lt;span class="c1"&gt;// evoke TableDoubling()&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After inserting key(8491), evoke TableDoubling():&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;323359&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;pop&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After inserting key(323359):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Searching: genre(8491) is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8491&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;.&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Searching: genre(7) is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;.&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After deleting key(7):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Searching: genre(7) is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;.&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;592&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After deleting key(592):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Want to  delete key(592) again:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;592&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;123596&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;323359&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;793&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;93&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After deleting key(123596),key(323359),key(793),key(93):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6594&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// evoke TableShrinking()&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After deleting key(6594), evoke TableShrinking():&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DisplayTable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;inserting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;592&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0: (12,post rock)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1: (592,shoegaze)&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;inserting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6594&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;evoke&lt;/span&gt; &lt;span class="n"&gt;TableDoubling&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1: (12,post rock) (6594,blues)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3: (592,shoegaze)&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;inserting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1: (12,post rock) (7,folk) (6594,blues)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3: (592,shoegaze)&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;inserting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;123596&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;evoke&lt;/span&gt; &lt;span class="n"&gt;TableDoubling&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2: (7,folk) (6594,blues)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3: (12,post rock)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#4: (123596,hiphop)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#5:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#6:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#7: (592,shoegaze)&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;inserting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;93&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2288&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;793&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0: (2288,indie) (793,jazz)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2: (7,folk) (6594,blues)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3: (12,post rock) (93,soul)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#4: (123596,hiphop)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#5:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#6:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#7: (592,shoegaze)&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;inserting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8491&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;evoke&lt;/span&gt; &lt;span class="n"&gt;TableDoubling&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0: (2288,indie)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1: (793,jazz)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#4:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#5: (7,folk) (6594,blues)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#6: (12,post rock)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#7: (93,soul)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#8: (123596,hiphop)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#9:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#10:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#11: (8491,electro)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#12:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#13:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#14: (592,shoegaze)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#15:&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;inserting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;323359&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0: (2288,indie)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1: (793,jazz)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#4:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#5: (7,folk) (6594,blues)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#6: (12,post rock)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#7: (93,soul)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#8: (123596,hiphop)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#9:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#10:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#11: (8491,electro)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#12:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#13: (323359,pop)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#14: (592,shoegaze)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#15:&lt;/span&gt;

&lt;span class="nl"&gt;Searching&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;genre&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8491&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;electro&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="nl"&gt;Searching&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;genre&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;folk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;deleting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;Searching&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;genre&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;no&lt;/span&gt; &lt;span class="n"&gt;such&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;deleting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;592&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0: (2288,indie)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1: (793,jazz)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#4:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#5: (6594,blues)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#6: (12,post rock)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#7: (93,soul)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#8: (123596,hiphop)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#9:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#10:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#11: (8491,electro)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#12:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#13: (323359,pop)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#14:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#15:&lt;/span&gt;

&lt;span class="n"&gt;Want&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;  &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;592&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;again&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;deleting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;123596&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;323359&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;793&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;93&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0: (2288,indie)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#4:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#5: (6594,blues)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#6: (12,post rock)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#7:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#8:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#9:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#10:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#11: (8491,electro)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#12:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#13:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#14:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#15:&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;deleting&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6594&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;evoke&lt;/span&gt; &lt;span class="n"&gt;TableShrinking&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#0: (2288,indie)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#1:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#2:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#3: (12,post rock)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#4:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#5: (8491,electro)&lt;/span&gt;
&lt;span class="cp"&gt;#slot#6:&lt;/span&gt;
&lt;span class="cp"&gt;#slot#7:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是以&lt;strong&gt;Chaining&lt;/strong&gt;解決&lt;strong&gt;Collision&lt;/strong&gt;之介紹。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch11&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/@aozturk/simple-hash-map-hash-table-implementation-in-c-931965904250#.du6lwge1u"&gt;Abdullah Ozturk：Simple Hash Map (Hash Table) Implementation in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pumpkinprogrammer.com/2014/06/21/c-tutorial-intro-to-hash-tables/"&gt;Pumpkin Programmer：C++ Tutorial: Intro to Hash Tables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://users.ece.utexas.edu/~adnan/360C/hash.pdf"&gt;Adnan Aziz：Hash Tables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-9-table-doubling-karp-rabin/"&gt;MIT 6.006：Lecture 9: Table Doubling, Karp-Rabin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Hash Table系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html"&gt;Hash Table：Intro(簡介)&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tablechaining.html"&gt;Hash Table：Chaining&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableopen-addressing.html"&gt;Hash Table：Open Addressing&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Dictionary"></category><category term="Hash Table"></category><category term="Linked List"></category></entry><entry><title>Hash Table：Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html" rel="alternate"></link><updated>2016-05-19T23:01:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-05-19:SecondRound/hash-tableintrojian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在做資料處理時，常常需要「查詢資料」，譬如線上購物平台有會員登入時，首先確認輸入的帳號密碼是否在資料庫裡，如果是，便從資料庫裡找出此會員的資料，如購物記錄、暫存購物清單等等。&lt;/p&gt;
&lt;p&gt;想到「查詢資料」，可能會想到能夠在時間複雜度為&lt;span class="math"&gt;\(O(\log{N})\)&lt;/span&gt;完成查詢的&lt;strong&gt;平衡的&lt;/strong&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree(二元搜尋樹)&lt;/a&gt;，如圖一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在圖一的BST中，要找到Key(17)的資料，需要比較&lt;span class="math"&gt;\(4=\lfloor{\log_{2}{15}\rfloor+1}\)&lt;/span&gt;次，時間複雜度可以視為&lt;strong&gt;height(樹高)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：若為平衡的BST，查詢資料之時間複雜度為&lt;span class="math"&gt;\(O(\log{N})\)&lt;/span&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;但是若資料量非常龐大(例如社交平台的註冊會員資料庫)，即使是&lt;span class="math"&gt;\(O(\log{N})\)&lt;/span&gt;也非常可觀。&lt;/p&gt;
&lt;p&gt;如果能在時間複雜度為常數的&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;完成查詢該有多好。&lt;/p&gt;
&lt;p&gt;本篇文章便要介紹能夠在&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;完成查詢的&lt;strong&gt;Hash Table(雜湊表)&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#dict"&gt;簡介：Dictionary(字典)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#dat"&gt;以Array實現的Direct Access Table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ht"&gt;Hash Table的概念&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#collision"&gt;很可能發生Collision&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#hf"&gt;Hash Function介紹&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#dm"&gt;Division Method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#mm"&gt;Multiplication Method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Hash Table系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dict"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;簡介：Dictionary(字典)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Dictionary&lt;/strong&gt;是以「鍵值-資料對」(&lt;strong&gt;Key-Value&lt;/strong&gt; pair)來描述資料的抽象資料形態(Abstract Data Type)。&lt;/p&gt;
&lt;p&gt;舉例來說：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;電話簿裡的Dictionary即是將「姓名」視為&lt;strong&gt;Key&lt;/strong&gt;，「電話號碼」視為&lt;strong&gt;Value&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;學校學籍系統的Dictionary將「學號」視為&lt;strong&gt;Key&lt;/strong&gt;，「學生資料」(如姓名、修課記錄)視為&lt;strong&gt;Value&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，任何具有辨別功能、可以用在「查詢資料」的「符號」(像是姓名、學號、網址等等)都能夠視為&lt;strong&gt;Key&lt;/strong&gt;。&lt;br /&gt;
而&lt;strong&gt;Value&lt;/strong&gt;代表著較為廣義的「資料」，例如電話號碼、學籍資料、IP位置等等。&lt;/p&gt;
&lt;p&gt;只要在系統輸入&lt;strong&gt;Key&lt;/strong&gt;，便能找到相對應的&lt;strong&gt;Value&lt;/strong&gt;，這就是&lt;strong&gt;Dictionary&lt;/strong&gt;的基本概念。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;一般&lt;strong&gt;Dictionary&lt;/strong&gt;會支援三個操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新增資料(insert)&lt;/li&gt;
&lt;li&gt;刪除資料(delete)&lt;/li&gt;
&lt;li&gt;查詢資料(search)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上三個操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若以&lt;strong&gt;平衡的BST&lt;/strong&gt;(例如AVL樹、&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree&lt;/a&gt;)便能在&lt;span class="math"&gt;\(O(\log{N})\)&lt;/span&gt;完成。&lt;/li&gt;
&lt;li&gt;「理想情況」的&lt;strong&gt;Hash Table&lt;/strong&gt;希望能夠以&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dat"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;以Array實現的Direct Access Table&lt;/h2&gt;
&lt;p&gt;若要在&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;對資料進行「新增」、「刪除」以及「查詢」，沒有比Array(矩陣)更適合的人選了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若直接把&lt;strong&gt;Key&lt;/strong&gt;當作Array的&lt;strong&gt;index&lt;/strong&gt;，並將&lt;strong&gt;Value&lt;/strong&gt;存放進Array，這樣的實作稱為&lt;strong&gt;Direct Access Table&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是&lt;strong&gt;Direct Access Table&lt;/strong&gt;有兩個重大缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Key&lt;/strong&gt;一定要是「非負整數(non-negative integer)」，才能作為Array的&lt;strong&gt;index&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;若&lt;strong&gt;Key&lt;/strong&gt;的「範圍」非常大，可是&lt;strong&gt;Key&lt;/strong&gt;的「數量」相對很少，那麼會非常浪費記憶體空間。&lt;ul&gt;
&lt;li&gt;以圖三為例，因為&lt;strong&gt;Key&lt;/strong&gt;的範圍從&lt;span class="math"&gt;\(2\)&lt;/span&gt;到&lt;span class="math"&gt;\(47\)&lt;/span&gt;，所以Array的大小(size)至少要「&lt;span class="math"&gt;\(48\)&lt;/span&gt;」，因此&lt;span class="math"&gt;\(15\)&lt;/span&gt;筆資料用了&lt;span class="math"&gt;\(48\)&lt;/span&gt;單位的記憶體空間，也就浪費超過三分之二的記憶體空間。若&lt;strong&gt;Key&lt;/strong&gt;的範圍更大，浪費的程度將非常可觀。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;關於第一點「&lt;strong&gt;Key&lt;/strong&gt;不是非負整數」的缺陷，可以先利用一個「一對一函數(one-to-one function)」將&lt;strong&gt;Key&lt;/strong&gt;對應到非負整數，問題即可解決，稱為&lt;strong&gt;prehash&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，若&lt;strong&gt;Key&lt;/strong&gt;是英文名字，那便利用「ASCII編碼」將字串轉換成非負整數。現要存放「T-MAC」與「KOBE」兩位球員的資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「T-MAC」&lt;span class="math"&gt;\(=84*10^4+45*10^3+77*10^2+65*10+67=893417\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;「KOBE」&lt;span class="math"&gt;\(=75*10^3+79*10^2+66*10+69=83629\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的範例，至少需要一個大小為&lt;span class="math"&gt;\(893418\)&lt;/span&gt;的Array，可是只有存放兩個英文名字，不划算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hash Table&lt;/strong&gt;的核心概念就是要解決第二個缺陷：避免記憶體空間浪費。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="ht"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Hash Table的概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Hash Table&lt;/strong&gt;希望能夠將存放資料的「Table」的大小(size)降到「真正會存放進Table的資料的數量」，也就是「有用到的&lt;strong&gt;Key&lt;/strong&gt;的數量」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若有用到的&lt;strong&gt;Key&lt;/strong&gt;之數量為&lt;span class="math"&gt;\(n\)&lt;/span&gt;，&lt;strong&gt;Table&lt;/strong&gt;的大小為&lt;span class="math"&gt;\(m\)&lt;/span&gt;，那麼目標就是&lt;span class="math"&gt;\(m=\Theta (n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要達到這個目標，必須引入&lt;strong&gt;Hash Function&lt;/strong&gt;，將&lt;strong&gt;Key&lt;/strong&gt;對應到符合&lt;strong&gt;Table&lt;/strong&gt;大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;的範圍內，&lt;span class="math"&gt;\(index=h(Key)\)&lt;/span&gt;，即可成為&lt;strong&gt;Hash Table&lt;/strong&gt;的&lt;strong&gt;index&lt;/strong&gt;，如圖四。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：Hash Table和Direct Access Table的差別在於Hash Function。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;可惜事與願違，因為&lt;span class="math"&gt;\(|U|\gg m\)&lt;/span&gt;，再加上&lt;strong&gt;Hash Function&lt;/strong&gt;設計不易，所以很可能發生&lt;strong&gt;Collision&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="collision"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;很可能發生Collision&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Collision&lt;/strong&gt;就是兩筆資料存進同一個&lt;strong&gt;Table&lt;/strong&gt;之&lt;strong&gt;slot&lt;/strong&gt;的情形，這將會使得查詢資料失敗(例如：使用item1的&lt;strong&gt;Key&lt;/strong&gt;，卻回傳item2的資料)。&lt;/p&gt;
&lt;p&gt;若以&lt;a href="#dm"&gt;&lt;strong&gt;Division Method&lt;/strong&gt;&lt;/a&gt;實作&lt;strong&gt;Hash Function&lt;/strong&gt;，定義&lt;span class="math"&gt;\(h(Key)=Key \bmod{m}\)&lt;/span&gt;，&lt;strong&gt;Table&lt;/strong&gt;大小為&lt;span class="math"&gt;\(m=6\)&lt;/span&gt;，目前要處理的資料之&lt;strong&gt;Key&lt;/strong&gt;有&lt;span class="math"&gt;\(67,26,50,33,16,71\)&lt;/span&gt;，那麼各個Key將被對應到的&lt;strong&gt;index&lt;/strong&gt;如下，同時參考圖五：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(67)=67 \bmod{6}=1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(26)=26 \bmod{6}=2\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(50)=50 \bmod{6}=2\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(33)=33 \bmod{6}=3\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(16)=16 \bmod{6}=4\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(71)=71 \bmod{6}=5\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;「item26」與「item50」經過&lt;strong&gt;Hash Function&lt;/strong&gt;後，同時想要將資料存進&lt;code&gt;Table[2]&lt;/code&gt;，這就是&lt;strong&gt;Collision&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collision&lt;/strong&gt;在「可能使用到的&lt;strong&gt;Key&lt;/strong&gt;」之數量遠大於&lt;strong&gt;Table&lt;/strong&gt;大小(亦即&lt;span class="math"&gt;\(|U|\gg m\)&lt;/span&gt;)的情況下，無可避免。&lt;/p&gt;
&lt;p&gt;解決的辦法有二：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Chaining&lt;/strong&gt;：使用Linked list把「Hashing到同一個slot」的資料串起來。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Open Addressing&lt;/strong&gt;：使用&lt;strong&gt;Probing Method&lt;/strong&gt;來尋找&lt;strong&gt;Table&lt;/strong&gt;中「空的slot」存放資料。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這兩個方法將分別在後續文章介紹。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="hf"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Hash Function介紹&lt;/h2&gt;
&lt;p&gt;優秀的&lt;strong&gt;Hash Function&lt;/strong&gt;(&lt;span class="math"&gt;\(h()\)&lt;/span&gt;)應具備以下特徵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義&lt;span class="math"&gt;\(h()\)&lt;/span&gt;的定義域(domain)為整個&lt;strong&gt;Key&lt;/strong&gt;的宇集合&lt;span class="math"&gt;\(U\)&lt;/span&gt;，值域(range)應小於&lt;strong&gt;Table&lt;/strong&gt;的大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;：&lt;br /&gt;
&lt;div class="math"&gt;$$
h:U\rightarrow \{\,0,1,...,m-1\,\},\:where \:|U|\gg m
$$&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;盡可能讓&lt;strong&gt;Key&lt;/strong&gt;在經過&lt;strong&gt;Hash Function&lt;/strong&gt;後，在值域(也就是&lt;strong&gt;Table&lt;/strong&gt;的&lt;strong&gt;index&lt;/strong&gt;)能夠平均分佈(uniform distributed)，如此才不會有「兩筆資料存進同一個&lt;strong&gt;Table&lt;/strong&gt;空格(稱為&lt;strong&gt;slot&lt;/strong&gt;)」的情況。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若把&lt;strong&gt;Table&lt;/strong&gt;想像成「書桌」，&lt;strong&gt;slot&lt;/strong&gt;想像成書桌的「抽屜」，那麼為了要能更快速找到物品，當然是希望「每一個抽屜只放一個物品」，如此一來，只要拿著&lt;strong&gt;Key&lt;/strong&gt;，透過&lt;strong&gt;Hash Function&lt;/strong&gt;找到對應的抽屜(&lt;strong&gt;Hash Function&lt;/strong&gt;的功能是指出「第幾個」抽屜，也就是抽屜的&lt;strong&gt;index&lt;/strong&gt;)，就能保證是該&lt;strong&gt;Key&lt;/strong&gt;所要找的物品。&lt;br /&gt;
反之，如果同一個抽屜裡有兩個以上的物品時，便有可能找錯物品。&lt;/p&gt;
&lt;p&gt;以下介紹兩種&lt;strong&gt;Hash Function&lt;/strong&gt;的基本款：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Division Method&lt;/strong&gt;：&lt;span class="math"&gt;\(m\)&lt;/span&gt;有限制，但是比較快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multiplication Method&lt;/strong&gt;：&lt;span class="math"&gt;\(m\)&lt;/span&gt;沒有限制，但是比較慢。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="dm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Division Method&lt;/h3&gt;
&lt;p&gt;要把大範圍的&lt;span class="math"&gt;\(|U|\)&lt;/span&gt;對應到較小範圍的&lt;span class="math"&gt;\(\{0,1,...,m-1\}\)&lt;/span&gt;，最直覺的做法就是利用&lt;strong&gt;Modulus&lt;/strong&gt;(mod)取餘數。&lt;br /&gt;
假設&lt;strong&gt;Table&lt;/strong&gt;大小為&lt;span class="math"&gt;\(m\)&lt;/span&gt;，定義&lt;strong&gt;Hash Function&lt;/strong&gt;為：&lt;/p&gt;
&lt;div class="math"&gt;$$
h(Key)=Key \bmod{m}
$$&lt;/div&gt;
&lt;p&gt;例如，選定&lt;strong&gt;Table&lt;/strong&gt;大小為&lt;span class="math"&gt;\(m=8\)&lt;/span&gt;，那麼以下的&lt;strong&gt;Key&lt;/strong&gt;與&lt;strong&gt;Table&lt;/strong&gt;之&lt;strong&gt;index&lt;/strong&gt;將有對應關係如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(14)=14 \bmod{8}=6\)&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;代表「編號&lt;span class="math"&gt;\(14\)&lt;/span&gt;」的物品要放進「第&lt;span class="math"&gt;\(6\)&lt;/span&gt;格」抽屜。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(23)=23 \bmod{8}=7\)&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;代表「編號&lt;span class="math"&gt;\(23\)&lt;/span&gt;」的物品要放進「第&lt;span class="math"&gt;\(7\)&lt;/span&gt;格」抽屜。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(46)=46 \bmod{8}=6\)&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;代表「編號&lt;span class="math"&gt;\(46\)&lt;/span&gt;」的物品要放進「第&lt;span class="math"&gt;\(6\)&lt;/span&gt;格」抽屜。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(50)=50 \bmod{8}=2\)&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;代表「編號&lt;span class="math"&gt;\(50\)&lt;/span&gt;」的物品要放進「第&lt;span class="math"&gt;\(2\)&lt;/span&gt;格」抽屜。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;優點&lt;/h3&gt;
&lt;p&gt;以&lt;strong&gt;Division Method&lt;/strong&gt;實現&lt;strong&gt;Hash Function&lt;/strong&gt;的優點就是非常快，只要做一次餘數(一次除法)運算即可。&lt;/p&gt;
&lt;h3&gt;缺點&lt;/h3&gt;
&lt;p&gt;較為理想的&lt;strong&gt;Table&lt;/strong&gt;大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;是「距離&lt;span class="math"&gt;\(2^{p}\)&lt;/span&gt;夠遠」的質數，像是&lt;span class="math"&gt;\(701\)&lt;/span&gt;。  &lt;/p&gt;
&lt;p&gt;換句話說，&lt;strong&gt;Table&lt;/strong&gt;大小&lt;span class="math"&gt;\(m\)&lt;/span&gt;必須慎選。  &lt;/p&gt;
&lt;p&gt;例如，要儘量避開「2的指數(&lt;span class="math"&gt;\(2^{p}\)&lt;/span&gt;)」，否則就只有「最低位的p-bit」會影響&lt;strong&gt;Hash Function&lt;/strong&gt;的結果。&lt;br /&gt;
轉換成二進位會更容易看出，以&lt;span class="math"&gt;\(m=8=2^{3}\)&lt;/span&gt;為例，&lt;span class="math"&gt;\(h(Key)=Key \bmod{2^{3}}\)&lt;/span&gt;的意思就是，只取「以二進位表示的&lt;strong&gt;Key&lt;/strong&gt;的最低位的&lt;strong&gt;&lt;span class="math"&gt;\(3\)&lt;/span&gt;個bit&lt;/strong&gt;」來決定&lt;strong&gt;Key&lt;/strong&gt;對應到的&lt;strong&gt;Table&lt;/strong&gt;之&lt;strong&gt;index&lt;/strong&gt;，見圖六。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;這種情況下，若有大量變數以相同的命名規則，例如「&lt;code&gt;a_count&lt;/code&gt;、&lt;code&gt;b_count&lt;/code&gt;、&lt;code&gt;c_count&lt;/code&gt;」，很有可能在&lt;strong&gt;prehash&lt;/strong&gt;(在&lt;strong&gt;Direct Access Table&lt;/strong&gt;提過的「T-MAC」與「KOBE」)將字串轉換成&lt;strong&gt;Key&lt;/strong&gt;時，得到「低位bit」完全相同的&lt;strong&gt;key&lt;/strong&gt;，因為以上三個變數的結尾都是&lt;code&gt;_count&lt;/code&gt;，那麼&lt;strong&gt;Division Method&lt;/strong&gt;就會把這三個變數都放進同一個&lt;strong&gt;slot&lt;/strong&gt;，造成&lt;strong&gt;Collision&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="mm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Multiplication Method&lt;/h3&gt;
&lt;p&gt;由於在實際面對資料時，時常無法預先得知「&lt;strong&gt;Key&lt;/strong&gt;的範圍」以及「在該範圍內&lt;strong&gt;Key&lt;/strong&gt;的分佈情形」，在這個前提下，不需要避開特定&lt;span class="math"&gt;\(m\)&lt;/span&gt;的&lt;strong&gt;Multiplication Method&lt;/strong&gt;可能會比較優秀。&lt;/p&gt;
&lt;p&gt;步驟如下：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七(a)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;而且這個將「&lt;strong&gt;Key&lt;/strong&gt;乘上&lt;span class="math"&gt;\(A\)&lt;/span&gt;、取小數點部分、再乘上&lt;span class="math"&gt;\(m\)&lt;/span&gt;、再取整數部分」的&lt;strong&gt;Hash Function&lt;/strong&gt;能夠儘量把更多的&lt;strong&gt;Key&lt;/strong&gt;的bit納入考慮，來得到&lt;span class="math"&gt;\(h(Key)\)&lt;/span&gt;。  &lt;/p&gt;
&lt;p&gt;轉換成二進位會更容易看出來。&lt;br /&gt;
先把圖七(a)中的「&lt;span class="math"&gt;\(constant\:A=\frac{13}{32}\)&lt;/span&gt;」轉換成二進位：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再把「&lt;span class="math"&gt;\(K\)&lt;/span&gt;乘上&lt;span class="math"&gt;\(A\)&lt;/span&gt;」以二進位表示，見圖七(b)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七(b)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;得到的&lt;span class="math"&gt;\(r_{0}=\frac{17}{32}\)&lt;/span&gt;其實就是&lt;span class="math"&gt;\(KA\)&lt;/span&gt;的小數部分(fractional part)，亦即&lt;span class="math"&gt;\(r_{0}=KA-\lfloor KA \rfloor\)&lt;/span&gt;，也就等於圖七(a)中的「f」。&lt;/p&gt;
&lt;p&gt;那麼，接下來對「&lt;span class="math"&gt;\(KA\)&lt;/span&gt;的小數部分乘上&lt;span class="math"&gt;\(m=2^{3}\)&lt;/span&gt;」，以二進位表示法解讀，就會是把「小數點往右移&lt;span class="math"&gt;\(3\)&lt;/span&gt;位」：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後一步：&lt;span class="math"&gt;\(h(K)=\lfloor m(KA-\lfloor KA \rfloor) \rfloor\)&lt;/span&gt;，其實就是取&lt;span class="math"&gt;\(m\times r_{0}\)&lt;/span&gt;的整數部分，結果與圖七(a)吻合。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;到這裡，再看一次圖七(b)，可以發現，決定出&lt;span class="math"&gt;\(h(21)=4\)&lt;/span&gt;的過程當中，以二進位表示的&lt;strong&gt;Key&lt;/strong&gt;&lt;span class="math"&gt;\(=21\)&lt;/span&gt;的「每一個部分的bit」都用上了，二進位的&lt;span class="math"&gt;\(4\)&lt;/span&gt;是由二進位的&lt;span class="math"&gt;\(Key=21\)&lt;/span&gt;之：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頭：&lt;span class="math"&gt;\(101\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;中：&lt;span class="math"&gt;\(101\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;尾：&lt;span class="math"&gt;\(01\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三者相加得到的，因為參與的「部位」變多了，那麼隨機性也就增加了，如此&lt;span class="math"&gt;\(h(Key)\)&lt;/span&gt;便能得到較為隨機的結果。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/HashTable%20series/Intro/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七(b)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上範例是將&lt;strong&gt;Key&lt;/strong&gt;以&lt;span class="math"&gt;\(5\)&lt;/span&gt;-bit表示，試想，若以&lt;span class="math"&gt;\(32\)&lt;/span&gt;-bit表示，並且增加&lt;strong&gt;Key&lt;/strong&gt;的範圍，那麼可以預期「參與並相加出最後&lt;span class="math"&gt;\(h(Key)\)&lt;/span&gt;」的部分會更加「隨機」，也就能夠將不同&lt;strong&gt;Key&lt;/strong&gt;「更隨機地」對應到不同的值(也就是不同的&lt;strong&gt;slot&lt;/strong&gt;)，有效降低&lt;strong&gt;Collision&lt;/strong&gt;的發生。&lt;/p&gt;
&lt;p&gt;還有一個小議題是，如何找到「&lt;span class="math"&gt;\(constant\:A\)&lt;/span&gt;」？&lt;br /&gt;
根據&lt;a href="https://en.wikipedia.org/wiki/Donald_Knuth"&gt;Knuth&lt;/a&gt;的說法，選擇黃金比例還不錯：&lt;/p&gt;
&lt;div class="math"&gt;$$
A=\frac{\sqrt{5}-1}{2}\approx 0.6180339887...  
$$&lt;/div&gt;
&lt;p&gt;至於程式的實作上，利用&lt;strong&gt;bit-shifting&lt;/strong&gt;會更有效率，請參考：&lt;a href="https://www.cs.hmc.edu/~geoff/classes/hmc.cs070.200101/homework10/hashfuncs.html"&gt;Geoff Kuenning：Hash Functions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
最後，在Hashing的議題裡，還有兩位大魔王叫做&lt;strong&gt;Universal Hashing&lt;/strong&gt;以及&lt;strong&gt;Perfect Hashing&lt;/strong&gt;(有鑒於筆者可能一輩子都看不懂，所以這裡就放個連結)，據說可以產生最低限度的&lt;strong&gt;Collision&lt;/strong&gt;，請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.cs.cmu.edu/~avrim/451f11/lectures/lect1004.pdf"&gt;CMU14-451,Algorithms：Universal and Perfect Hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Universal_hashing"&gt;Wikipedia：Universal Hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cs-www.bu.edu/faculty/homer/537/talks/SarahAdelBargal_UniversalHashingnotes.pdf"&gt;Sarah Adel Bargal：Universal Hashing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是&lt;strong&gt;Hash Table&lt;/strong&gt;之基本概念介紹。&lt;/p&gt;
&lt;p&gt;接下來兩篇將介紹&lt;strong&gt;Chaining&lt;/strong&gt;與&lt;strong&gt;Open Addressing&lt;/strong&gt;解決&lt;strong&gt;Collision&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch11&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cs.ntou.edu.tw/lincc/courses/al99/pdf/Algorithm-Ch11-Hash%20Tables.pdf"&gt;林清池：Algorithms Chapter 11 Hash Tables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.hmc.edu/~geoff/classes/hmc.cs070.200101/homework10/hashfuncs.html"&gt;Geoff Kuenning：Hash Functions &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-8-hashing-with-chaining/"&gt;MIT 6.006：Lecture 8: Hashing with Chaining&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Universal_hashing"&gt;Wikipedia：Universal Hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.cmu.edu/~avrim/451f11/lectures/lect1004.pdf"&gt;CMU14-451,Algorithms：Universal and Perfect Hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cs-www.bu.edu/faculty/homer/537/talks/SarahAdelBargal_UniversalHashingnotes.pdf"&gt;Sarah Adel Bargal：Universal Hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.facebook.com/profile.php?id=100000181170314&amp;amp;fref=ts"&gt;Explanation from Ou-Yang,Hui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Hash Table系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html"&gt;Hash Table：Intro(簡介)&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tablechaining.html"&gt;Hash Table：Chaining&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableopen-addressing.html"&gt;Hash Table：Open Addressing&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category><category term="Dictionary"></category><category term="Hash Table"></category></entry><entry><title>Complexity：Asymptotic Notation(漸進符號)</title><link href="http://alrightchiu.github.io/SecondRound/complexityasymptotic-notationjian-jin-fu-hao.html" rel="alternate"></link><updated>2016-05-14T17:59:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-05-14:SecondRound/complexityasymptotic-notationjian-jin-fu-hao.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將介紹&lt;strong&gt;Complexity(複雜度)&lt;/strong&gt;，以及用來分析&lt;strong&gt;Complexity(複雜度)&lt;/strong&gt;的&lt;strong&gt;Asymptotic Notation(漸進符號)&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#com"&gt;Complexity(複雜度)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#an"&gt;使用Asymptotic Notation的優點&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#tight"&gt;&lt;span class="math"&gt;\(\Theta-\)&lt;/span&gt;Notation，Big-Theta&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bo"&gt;&lt;span class="math"&gt;\(O-\)&lt;/span&gt;Notation，Big-O&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bw"&gt;&lt;span class="math"&gt;\(\Omega-\)&lt;/span&gt;Notation，Big-Omega&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#so"&gt;&lt;span class="math"&gt;\(o-\)&lt;/span&gt;Notation，Littel-o&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sw"&gt;&lt;span class="math"&gt;\(\omega-\)&lt;/span&gt;Notation，Littel-omega&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Complexity系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="com"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Complexity(複雜度)&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Concept%20series/Complexity/Asymptotic%20Notation/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;假設某間出版社想要印書，找到一間印刷廠，廠房內共有六台機器，每台機器的工作效率分別如圖一的六個函數，橫軸表示「書的數量」，縱軸表示「需要的工作天」。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;&lt;/th&gt;
&lt;th align="center"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;&lt;span class="math"&gt;\(N!\)&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th align="center"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;&lt;span class="math"&gt;\(2^N\)&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th align="center"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th align="center"&gt;&amp;nbsp;&amp;nbsp;&lt;strong&gt;&lt;span class="math"&gt;\(N\ln{N}\)&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th align="center"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;&lt;span class="math"&gt;\(N\)&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th align="center"&gt;&amp;nbsp;&amp;nbsp;&lt;strong&gt;&lt;span class="math"&gt;\(\ln{N}\)&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;span class="math"&gt;\(N=5\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(120\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(32\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(25\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(8.05\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(5\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(1.6\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;span class="math"&gt;\(N=100\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(9\times10^{157}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(1.3\times10^{30}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(10000\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(460\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&amp;nbsp;&lt;span class="math"&gt;\(100\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(4.6\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據表一可以看出，若要印&lt;span class="math"&gt;\(N=5\)&lt;/span&gt;本書：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用「機器&lt;strong&gt;&lt;span class="math"&gt;\(\ln{N}\)&lt;/span&gt;&lt;/strong&gt;」需要&lt;span class="math"&gt;\(1.6\)&lt;/span&gt;個工作天。&lt;/li&gt;
&lt;li&gt;使用「機器&lt;strong&gt;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/strong&gt;」需要&lt;span class="math"&gt;\(25\)&lt;/span&gt;個工作天；&lt;/li&gt;
&lt;li&gt;使用「機器&lt;strong&gt;&lt;span class="math"&gt;\(N!\)&lt;/span&gt;&lt;/strong&gt;」需要&lt;span class="math"&gt;\(120\)&lt;/span&gt;個工作天；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當問題的資料量不大時，「有效率」的機器和「沒有效率」的機器在成本消耗上可能差異不大，但是當資料量增加時，成本會變得非常可觀。&lt;/p&gt;
&lt;p&gt;若考慮印&lt;span class="math"&gt;\(N=100\)&lt;/span&gt;本書：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用「機器&lt;strong&gt;&lt;span class="math"&gt;\(\ln{N}\)&lt;/span&gt;&lt;/strong&gt;」需要&lt;span class="math"&gt;\(4.6\)&lt;/span&gt;個工作天。&lt;/li&gt;
&lt;li&gt;使用「機器&lt;strong&gt;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/strong&gt;」需要&lt;span class="math"&gt;\(10000\)&lt;/span&gt;個工作天，大約是&lt;span class="math"&gt;\(27\)&lt;/span&gt;年；&lt;/li&gt;
&lt;li&gt;使用「機器&lt;strong&gt;&lt;span class="math"&gt;\(N!\)&lt;/span&gt;&lt;/strong&gt;」需要&lt;span class="math"&gt;\(9\times10^{157}\)&lt;/span&gt;個工作天，是個天文數字；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據以上描述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成本(包含運算時間與記憶體空間)，通常會和「待處理的資料量」有關，當資料量越大，成本會以某種關係(線性、指數等等，見圖一)跟著提高。&lt;/li&gt;
&lt;li&gt;當資料量大時，演算法的效率很重要。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而圖一中，描述每一種&lt;strong&gt;演算法&lt;/strong&gt;(一台機器代表一種&lt;strong&gt;演算法&lt;/strong&gt;)的「工作效率之函數」，就稱為此演算法之&lt;strong&gt;Complexity(複雜度)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="an"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;使用Asymptotic Notation的優點&lt;/h2&gt;
&lt;p&gt;若能得知各個演算法的&lt;strong&gt;Complexity(複雜度)&lt;/strong&gt;，便能決定哪個演算法較有效率。 &lt;/p&gt;
&lt;p&gt;但是並非所有演算法都像&lt;a href="https://www.youtube.com/watch?v=i-SKeOcBwko"&gt;只有兩個迴圈的Insertion Sort&lt;/a&gt;那麼簡潔而容易分析，所以在評估演算法之&lt;strong&gt;Complexity(複雜度)&lt;/strong&gt;時，常使用&lt;strong&gt;Asymptotic Notation(漸進符號)&lt;/strong&gt;，其概念為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希望能以「簡單的函數」(例如：&lt;span class="math"&gt;\(N^{2}、\ln{N}\)&lt;/span&gt;等等)來描述&lt;strong&gt;Complexity(複雜度)&lt;/strong&gt;的「趨勢」，特別是針對資料量非常大的時候。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下分別介紹五個&lt;strong&gt;Asymptotic Notation(漸進符號)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="tight"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class="math"&gt;\(\Theta-\)&lt;/span&gt;Notation，Big-Theta&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Asymptotic Notation(漸進符號)&lt;/strong&gt;是所有能夠描述演算法趨勢的「函數之集合」，給定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非負函數&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;：描述演算法之趨勢。&lt;/li&gt;
&lt;li&gt;非負函數&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;：簡單函數。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若滿足以下定義：&lt;/p&gt;
&lt;div class="math"&gt;$$
\Theta(g(n))=\{\,f(n)：存在正整數\:c_1,c_2,n_0 \,,並且對於所有n\geq n_0,\,滿足 0\leq c_{1}g(n)\leq f(n) \leq c_{2}g(n)\:\}
$$&lt;/div&gt;
&lt;p&gt;表示&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;為&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;趨勢之「邊界」(bound)，即可使用&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;來描述&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;之趨勢，以&lt;span class="math"&gt;\(f(n)\in\Theta(g(n))\)&lt;/span&gt;表示(也會看到&lt;span class="math"&gt;\(f(n)=\Theta(g(n))\)&lt;/span&gt;，但切記，&lt;span class="math"&gt;\(\Theta(g(n))\)&lt;/span&gt;是一個集合)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Concept%20series/Complexity/Asymptotic%20Notation/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;舉例來說，若現有一個演算法之趨勢可以用&lt;span class="math"&gt;\(f(n)=6n+4\)&lt;/span&gt;代表，那麼以下兩個&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;都能夠在&lt;span class="math"&gt;\(\Theta(g(n))\)&lt;/span&gt;的定義下視為&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;的「邊界」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若&lt;span class="math"&gt;\(g(n)=2n\)&lt;/span&gt;，取&lt;span class="math"&gt;\(c_{1}=2,c_{2}=4,n_{0}=2\)&lt;/span&gt;，則滿足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(0\leq 2(2n)\leq 6n+4 \leq 4(2n) \,, \forall n\geq 2\)&lt;/span&gt;，見圖二左。&lt;br /&gt;
也就是說，當資料量&lt;span class="math"&gt;\(n\geq 2\)&lt;/span&gt;，&lt;span class="math"&gt;\(f(n)=6n+4\)&lt;/span&gt;的值往上不會超過&lt;span class="math"&gt;\(8n\)&lt;/span&gt;，往下不會低於&lt;span class="math"&gt;\(4n\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若&lt;span class="math"&gt;\(g(n)=5n\)&lt;/span&gt;，取&lt;span class="math"&gt;\(c_{1}=1,c_{2}=2,n_{0}=1\)&lt;/span&gt;，則滿足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(0\leq 1(5n)\leq 6n+4 \leq 2(5n) \,, \forall n\geq 1\)&lt;/span&gt;，見圖二右。&lt;br /&gt;
同理，當資料量&lt;span class="math"&gt;\(n\geq 1\)&lt;/span&gt;，&lt;span class="math"&gt;\(f(n)=6n+4\)&lt;/span&gt;的值往上不會超過&lt;span class="math"&gt;\(10n\)&lt;/span&gt;，往下不會低於&lt;span class="math"&gt;\(5n\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據定義，既然係數(&lt;span class="math"&gt;\(c_{1},c_{2}\)&lt;/span&gt;)可以任選，那麼以上兩個&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;函數其實可以把係數都提到&lt;span class="math"&gt;\(c_{1},c_{2}\)&lt;/span&gt;裡，以同一個函數：&lt;span class="math"&gt;\(g(n)=n\)&lt;/span&gt;表示即可。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由此可以確認，&lt;span class="math"&gt;\(\Theta(g(n))\)&lt;/span&gt;是多個函數的「集合」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若一個演算法之「趨勢」為&lt;span class="math"&gt;\(f(n)=6n+4\)&lt;/span&gt;，那麼其複雜度即為&lt;span class="math"&gt;\(\Theta(n)\)&lt;/span&gt;，可以表示成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(n)\in\Theta(n)\)&lt;/span&gt;，或者&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(n)=\Theta(n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上情況可以推廣至所有的&lt;strong&gt;多項式(polynomial)&lt;/strong&gt;，以&lt;span class="math"&gt;\(f(n)=3n^{3}+4n^{2}+5\)&lt;/span&gt;為例，當&lt;span class="math"&gt;\(n\)&lt;/span&gt;越來越大時，對&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;之趨勢具有決定性影響力的是「最高次項」，此例為「三次方項」，所以，&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;的複雜度為&lt;span class="math"&gt;\(\Theta(n^{3})\)&lt;/span&gt;，將係數拿進&lt;span class="math"&gt;\(c_{1},c_{2}\)&lt;/span&gt;，便以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(n)\in\Theta(n^{3})\)&lt;/span&gt;，或者&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(n)=\Theta(n^{3})\)&lt;/span&gt;表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Big-Theta(&lt;span class="math"&gt;\(\Theta(·)\)&lt;/span&gt;)&lt;/strong&gt;是同時找到&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;的「上界(upper bound)」與「下界(lower bound)」，像是三明治一樣把&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;夾住。  &lt;/p&gt;
&lt;p&gt;若把「上界」與「下界」分開來看，就是下面要介紹的&lt;strong&gt;Big-O&lt;/strong&gt;與&lt;strong&gt;Big-Omega&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="bo"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class="math"&gt;\(O-\)&lt;/span&gt;Notation，Big-O&lt;/h3&gt;
&lt;p&gt;一般談論的演算法之複雜度，經常是指&lt;strong&gt;Big-O&lt;/strong&gt;，因為在估算成本時，最想知道的是「上界(upper bound)」，以&lt;a href="#com"&gt;第一小節的範例&lt;/a&gt;來說，就是要知道印&lt;span class="math"&gt;\(N\)&lt;/span&gt;本書，每台機器「最久」要花多少時間。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Big-O&lt;/strong&gt;定義如下：&lt;/p&gt;
&lt;div class="math"&gt;$$
O(g(n))=\{\,f(n)：存在正整數\:c,n_0 \,,並且對於所有n\geq n_0,\,滿足 0\leq f(n) \leq cg(n)\:\}
$$&lt;/div&gt;
&lt;p&gt;根據定義，可以將&lt;strong&gt;Big-O&lt;/strong&gt;視為&lt;strong&gt;Big-Theta(&lt;span class="math"&gt;\(\Theta(·)\)&lt;/span&gt;)&lt;/strong&gt;的「上半部」，其以「簡單函數&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;」描述&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;在資料量夠大時，「最多」會達到怎麼樣的趨勢。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Concept%20series/Complexity/Asymptotic%20Notation/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;繼續以&lt;span class="math"&gt;\(f(n)=6n+4\)&lt;/span&gt;為例，若選&lt;span class="math"&gt;\(g(n)=n,c=7,n_{0}=4\)&lt;/span&gt;，即可滿足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(0\leq 6n+4 \leq 7n \,, \forall n\geq 4\)&lt;/span&gt;，見圖三。&lt;/li&gt;
&lt;li&gt;表示&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;之「上界」趨勢能夠以&lt;span class="math"&gt;\(g(n)=7n\)&lt;/span&gt;描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同樣的，把係數放進正整數&lt;span class="math"&gt;\(c\)&lt;/span&gt;裡面，&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;之複雜度在&lt;strong&gt;Big-O&lt;/strong&gt;的定義下，可以用簡單函數&lt;span class="math"&gt;\(g(n)=n\)&lt;/span&gt;表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(n)\in O(n)\)&lt;/span&gt;，或者&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(n)=O(n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再多看幾個例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;span class="math"&gt;\(f(n)=6n^{3}+5n^{2}-4n\log{n}+3\)&lt;/span&gt;，那麼此函數之複雜度為&lt;span class="math"&gt;\(f(n)=O(n^{3})\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若&lt;span class="math"&gt;\(f(n)=2\)&lt;/span&gt;，此函數之複雜度為&lt;strong&gt;&lt;span class="math"&gt;\(f(n)=O(1)\)&lt;/span&gt;&lt;/strong&gt;，表示此演算法之效率「與資料量多寡無關」，又稱為&lt;strong&gt;常數時間(constant time)&lt;/strong&gt;的複雜度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="bw"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class="math"&gt;\(\Omega-\)&lt;/span&gt;Notation，Big-Omega&lt;/h3&gt;
&lt;p&gt;若想知道某個演算法「至少」需要多少時間時，便可以&lt;strong&gt;Big-Omega&lt;/strong&gt;來估算「下界(lower bound)」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Big-Omega&lt;/strong&gt;的定義如下：&lt;/p&gt;
&lt;div class="math"&gt;$$
\Omega(g(n))=\{\,f(n)：存在正整數\:c,n_0 \,,並且對於所有n\geq n_0,\,滿足 0\leq  cg(n) \leq f(n)\:\}
$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Big-Omega&lt;/strong&gt;可以視為&lt;strong&gt;Big-Theta(&lt;span class="math"&gt;\(\Theta(·)\)&lt;/span&gt;)&lt;/strong&gt;的「下半部」，其以「簡單函數&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;」描述&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;在資料量夠大時，「至少」會達到怎麼樣的趨勢。&lt;/p&gt;
&lt;p&gt;繼續以&lt;span class="math"&gt;\(f(n)=6n+4\)&lt;/span&gt;為例，&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;之複雜度在&lt;strong&gt;Big-Omega&lt;/strong&gt;的定義下，可以用簡單函數&lt;span class="math"&gt;\(g(n)=n\)&lt;/span&gt;表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(n)\in \Omega(n)\)&lt;/span&gt;，或者&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(n)=\Omega(n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
以上介紹的&lt;strong&gt;Big-O(&lt;span class="math"&gt;\(O(·)\)&lt;/span&gt;)&lt;/strong&gt;與&lt;strong&gt;Big-Omega(&lt;span class="math"&gt;\(\Omega(·)\)&lt;/span&gt;)&lt;/strong&gt;是夾得「比較緊的(tight)」上界和下界，接下來還有兩個符號：&lt;strong&gt;Littel-o(&lt;span class="math"&gt;\(o(·)\)&lt;/span&gt;)&lt;/strong&gt;與&lt;strong&gt;Littel-omega(&lt;span class="math"&gt;\(\omega(·)\)&lt;/span&gt;)&lt;/strong&gt;，表示「沒有那麼緊的」上下界。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="so"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class="math"&gt;\(o-\)&lt;/span&gt;Notation，Littel-o&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Littel-o(&lt;span class="math"&gt;\(o(·)\)&lt;/span&gt;)&lt;/strong&gt;的定義如下：&lt;/p&gt;
&lt;div class="math"&gt;$$
o(g(n))=\{\,f(n)：對於所有正整數\:c,存在正整數\:n_0\,,使得對於所有n\geq n_0,\, 0\leq f(n) \leq cg(n)\:\}
$$&lt;/div&gt;
&lt;p&gt;怎麼說&lt;strong&gt;Littel-o(&lt;span class="math"&gt;\(o(·)\)&lt;/span&gt;)&lt;/strong&gt;比較「不緊」呢？因為定義中是「對於所有正整數&lt;span class="math"&gt;\(c\)&lt;/span&gt;」，因此&lt;span class="math"&gt;\(f(n)=o(g(n))\)&lt;/span&gt;務必要求&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;的「成長率」遠遠大於&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;，等同於滿足以下極限關係式：&lt;/p&gt;
&lt;div class="math"&gt;$$
\lim_{n-&amp;gt;\infty}\frac{f(n)}{g(n)}=0
$$&lt;/div&gt;
&lt;p&gt;比較&lt;strong&gt;Big-O(&lt;span class="math"&gt;\(O(·)\)&lt;/span&gt;)&lt;/strong&gt;與&lt;strong&gt;Littel-o(&lt;span class="math"&gt;\(o(·)\)&lt;/span&gt;)&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(2n=o(n^{2})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(2n=O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(2n^{2}=o(n!)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(2n^{2}=O(n^{2})\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="sw"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class="math"&gt;\(\omega-\)&lt;/span&gt;Notation，Littel-omega&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Littel-omega(&lt;span class="math"&gt;\(\omega(·)\)&lt;/span&gt;)&lt;/strong&gt;的定義如下：&lt;/p&gt;
&lt;div class="math"&gt;$$
\omega(g(n))=\{\,f(n)：對於所有正整數\:c,存在正整數\:n_0\,,使得對於所有n\geq n_0,\, 0\leq  cg(n) \leq f(n)\:\}
$$&lt;/div&gt;
&lt;p&gt;同理，&lt;span class="math"&gt;\(f(n)=\omega(g(n))\)&lt;/span&gt;要求&lt;span class="math"&gt;\(g(n)\)&lt;/span&gt;的「成長率」遠遠小於&lt;span class="math"&gt;\(f(n)\)&lt;/span&gt;，等同於滿足以下極限關係式：&lt;/p&gt;
&lt;div class="math"&gt;$$
\lim_{n-&amp;gt;\infty}\frac{f(n)}{g(n)}=\infty
$$&lt;/div&gt;
&lt;p&gt;比較&lt;strong&gt;Big-Omega(&lt;span class="math"&gt;\(\Omega(·)\)&lt;/span&gt;)&lt;/strong&gt;與&lt;strong&gt;Littel-omega(&lt;span class="math"&gt;\(\omega(·)\)&lt;/span&gt;)&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(4n^{2}=\omega(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(4n^{2}=\omega(\log{n})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(4n^{2}=\Omega(n^{2})\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是演算法之&lt;strong&gt;Complexity(複雜度)&lt;/strong&gt;以及經常使用的&lt;strong&gt;Asymptotic Notation(漸進符號)&lt;/strong&gt;之介紹。&lt;/p&gt;
&lt;p&gt;最後再看一次常見的時間複雜度之效率比較：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Concept%20series/Complexity/Asymptotic%20Notation/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據圖一，若同樣處理&lt;span class="math"&gt;\(N\)&lt;/span&gt;筆資料，那麼各個時間複雜度之成本如下：&lt;br /&gt;
(成本越高，表示效率越差)&lt;/p&gt;
&lt;div class="math"&gt;$$
O(1)&amp;lt;O(\log{N})&amp;lt;O(N)&amp;lt;O(N\log{N})&amp;lt;O(N^{2})&amp;lt;O(2^{N})&amp;lt;O(N!)
$$&lt;/div&gt;
&lt;p&gt;最有效率的是&lt;strong&gt;常數的時間複雜度&lt;/strong&gt;(&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;)，意思其「運算成本與資料量無關」，所以不管資料量多大，保證能夠在「可數(countable)、有限(finite)」的時間內完成，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不管矩陣大小(size)有多大，一定能夠利用&lt;strong&gt;index&lt;/strong&gt;在&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;時間，對矩陣的元素做存取，例如&lt;code&gt;Array[index]=5&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;不管Linked list長度有多長，一定能夠在&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;時間，在list的&lt;strong&gt;front&lt;/strong&gt;指標後新增節點(insert node at the front)，參考：&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html#front"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各個常見演算法的時間複雜度(&lt;strong&gt;Big-O&lt;/strong&gt;)可以參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://bigocheatsheet.com/"&gt;Big-O Algorithm Complexity Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch3&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation"&gt;KhanAcademy：Asymptotic notation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bigocheatsheet.com/"&gt;Big-O Algorithm Complexity Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://program-lover.blogspot.tw/2008/10/complexity-analysis.html"&gt;Infinite Loop：複雜度分析 - Complexity Analysis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=i-SKeOcBwko"&gt;MyCodeSchool：Insertion sort algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Complexity系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/complexityasymptotic-notationjian-jin-fu-hao.html"&gt;Complexity：Asymptotic Notation(漸進符號)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category><category term="Complexity"></category><category term="Big-O"></category></entry><entry><title>Set：以Array表示</title><link href="http://alrightchiu.github.io/SecondRound/setyi-arraybiao-shi.html" rel="alternate"></link><updated>2016-05-11T20:31:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-05-11:SecondRound/setyi-arraybiao-shi.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;Sequense(序列)是一組「順序有意義」的資料，例如暢銷排行榜的名次，或者到郵局等候時領的號碼牌。&lt;/p&gt;
&lt;p&gt;而Set(集合)是「順序沒有意義」的資料，例如某堂課的期末報告要分組時，組員之間不會有「順序」的差別(但是可能會有「小隊長」)，又或者買樂透時，哪個號碼「先對中」並不影響最後的中獎結果。&lt;/p&gt;
&lt;p&gt;本篇文章將介紹以Array(矩陣)表示Set(集合)的方法。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#set"&gt;Set表示法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#find"&gt;FindSet&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#Collapsing"&gt;Collapsing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#union"&gt;UnionSet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Set系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="set"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Set表示法&lt;/h2&gt;
&lt;p&gt;Set是不講求順序(order)的資料彙集(collection)，其概念可以使用類似Tree的資料結構來實現：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以&lt;strong&gt;root&lt;/strong&gt;來代表不同的Set；&lt;/li&gt;
&lt;li&gt;Set中的其餘element之&lt;strong&gt;parent/predecessor&lt;/strong&gt;指向&lt;strong&gt;root&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章介紹的表示法將以矩陣(array)處理與Set有關的兩件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判斷哪些element屬於同一個subset；&lt;/li&gt;
&lt;li&gt;判斷每個subset中各有幾個element。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：共有三個Set。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;配合圖一(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若element(X)之「矩陣值」為負值(negative value)，即表示element(X)「沒有predecessor」，element(X)就是其所屬於的subset的root。&lt;ul&gt;
&lt;li&gt;root就像每個subset的門牌，可以用來分辨某兩個element是否屬於同一個subset。&lt;/li&gt;
&lt;li&gt;見圖一(a)，element(1)、element(4)、element(7)皆為各自所代表的Set之root。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若element(Y)之「矩陣值」為正值(positive value)，該數值即為element(Y)的predecessor。&lt;ul&gt;
&lt;li&gt;見圖一(a)，element(0)之predecessor為element(7)，即表示element(0)與element(7)屬於同一個subset。&lt;/li&gt;
&lt;li&gt;從element(5)一路往predecessor方向找，會先找到element(3)，再找到element(1)，而element(2)也會找到element(1)，即表示element&lt;span class="math"&gt;\(:1、2、3、5\)&lt;/span&gt;皆屬於同一個subset。&lt;/li&gt;
&lt;li&gt;同理，element&lt;span class="math"&gt;\(:0、6、7\)&lt;/span&gt;屬於同一個subset。而element(4)自成一個subset。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若element(X)是某個subset的root，其矩陣數值的絕對值(absolute value)即代表該subset中的「element數目」。&lt;ul&gt;
&lt;li&gt;見圖一(a)，element(1)之矩陣數值為&lt;span class="math"&gt;\(-4\)&lt;/span&gt;，取絕對值為&lt;span class="math"&gt;\(4\)&lt;/span&gt;，即表示element(1)所在的subset中共有4個element。&lt;/li&gt;
&lt;li&gt;同理，element(7)所在的subset中共有&lt;span class="math"&gt;\(3\)&lt;/span&gt;個element。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
在處理&lt;strong&gt;Disjoint Set&lt;/strong&gt;的問題時，經常要處理兩個問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FindSet(element)&lt;/code&gt;：確認某個element所隸屬的subset為何。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UnionSet(X,Y)&lt;/code&gt;：將element(X)與element(Y)合併放進同一個Set。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="find"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;FindSet&lt;/h3&gt;
&lt;p&gt;若利用上述的Set表示法，當進行&lt;code&gt;FindSet(element)&lt;/code&gt;時，便以每個subset之root作為判斷的依據，只要在矩陣中一路回溯&lt;code&gt;predecessor&lt;/code&gt;，直到root(矩陣值為負值)後，回傳root，就代表了該element所在的subset。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：共有三個Set。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖一(a)為例，觀察&lt;code&gt;FindSet(6)&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Array[6]&lt;/code&gt;為&lt;span class="math"&gt;\(0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array[0]&lt;/code&gt;為&lt;span class="math"&gt;\(7\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array[7]&lt;/code&gt;為&lt;span class="math"&gt;\(-3\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可以確定：element(6)屬於「以element(7)作為代表」的subset。&lt;/p&gt;
&lt;p&gt;再看&lt;code&gt;FindSet(5)&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Array[5]&lt;/code&gt;為&lt;span class="math"&gt;\(3\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array[3]&lt;/code&gt;為&lt;span class="math"&gt;\(1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array[1]&lt;/code&gt;為&lt;span class="math"&gt;\(-4\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就表示，element(5)屬於「以element(1)作為代表」的subset。&lt;/p&gt;
&lt;p&gt;所以element(5)與element(6)屬於不同subset。&lt;br /&gt;
&lt;/br&gt;    &lt;/p&gt;
&lt;p&gt;&lt;a name="Collapsing"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Collapsing&lt;/h3&gt;
&lt;p&gt;另外，有個提升演算法效率的概念稱為&lt;strong&gt;Set Collapsing&lt;/strong&gt;，目的是要讓&lt;code&gt;FindSet()&lt;/code&gt;能夠在時間複雜度O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)完成。&lt;/p&gt;
&lt;p&gt;本篇文章的&lt;a href="#code"&gt;範例程式&lt;/a&gt;中，將「執行&lt;code&gt;FindSet()&lt;/code&gt;時，順便進行&lt;strong&gt;Set Collapsing&lt;/strong&gt;」定義成&lt;code&gt;FindSetCollapsing()&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖一(b)，&lt;code&gt;FindSetCollapsing(5)&lt;/code&gt;會將element(5)的predecessor調整成element(1)，那麼下次想要知道element(5)屬於哪個subset時，就不需要經過element(3)，便能夠以時間複雜度：&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;完成。&lt;/li&gt;
&lt;li&gt;參考&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html#algorithm"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;對&lt;code&gt;SetCollapsing()&lt;/code&gt;的介紹。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="union"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;UnionSet&lt;/h3&gt;
&lt;p&gt;進行&lt;code&gt;UnionSet(X,Y)&lt;/code&gt;時，只要將element(X)所在的Set之root指向element(Y)所在的Set之root即可(或者相反指向，將Set(Y)之root指向Set(X)之root)，見圖二。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Set/Representation/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;一般而言，&lt;code&gt;UnionSet(X,Y)&lt;/code&gt;會利用「Set中element的個數」來判斷要以Set(X)的root還是Set(Y)的root作為合併後的Set之代表root。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常「Set中element個數越多」，那麼該Set之&lt;strong&gt;height&lt;/strong&gt;會比較大(此處的height表示Set中，root與距離其最遠的vertex之間的edge數)，進行&lt;code&gt;FindSet(element)&lt;/code&gt;時的時間複雜度也較大。  &lt;/li&gt;
&lt;li&gt;因此，若把「Set中element個數較少」的Set併進「Set中element個數較多」的Set，一般情況下，最後合併好的Set之&lt;strong&gt;height&lt;/strong&gt;不會變，但是相反的情況，會使&lt;strong&gt;height&lt;/strong&gt;增加，而&lt;strong&gt;height&lt;/strong&gt;增加會影響&lt;code&gt;FindSet()&lt;/code&gt;的效率。&lt;/li&gt;
&lt;li&gt;試比較圖二中的兩種合併準則：&lt;ul&gt;
&lt;li&gt;將Set(4)併進Set(1)後，新的Set之&lt;strong&gt;height&lt;/strong&gt;不變。&lt;/li&gt;
&lt;li&gt;反之，將Set(1)併進Set(4)時，新的Set之&lt;strong&gt;height&lt;/strong&gt;比原先的Set(1)還大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;範例程式碼包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函式&lt;code&gt;FindSetCollapsing()&lt;/code&gt;與&lt;code&gt;UnionSet()&lt;/code&gt;如上一小節介紹。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PrintArray()&lt;/code&gt;印出Array元素。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;main()&lt;/code&gt;中，進行簡單的測試。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;      

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  &lt;span class="c1"&gt;// 找到root&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;             &lt;span class="c1"&gt;// 進行collapsing&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;UnionSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xroot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;yroot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 用rank比較, 負越多表示set越多element, 所以是值比較小的element比較多&lt;/span&gt;
    &lt;span class="c1"&gt;// xroot, yroot的subset[]一定都是負值&lt;/span&gt;

    &lt;span class="c1"&gt;// x比較多element或是一樣多的時候, 以x作為root&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;//  subset[xroot] &amp;gt; subset[yroot], 表示y比較多element&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;UnionSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After union(1,2):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;UnionSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After union(0,2):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;UnionSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After union(3,5):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;UnionSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After union(2,5):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;element(5) belongs to Set(&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;).&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;After collapsing:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;belongs&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="nl"&gt;collapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;main()&lt;/code&gt;中測試結果如圖三：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Set/Representation/SetUnion.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是以Array表示Set之介紹。&lt;/p&gt;
&lt;p&gt;其他表示法(不同的Array表示法，或者以Linked list表示)可以參考以下連結：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.hackerearth.com/notes/disjoint-set-union-union-find/"&gt;HackerEarth：Disjoint Set Union (Union Find)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch21&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch21&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=gcmjC-OcWpI"&gt;Dickson Tsai：Disjoint Sets - Data Structures in 5 Minutes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hackerearth.com/notes/disjoint-set-union-union-find/"&gt;HackerEarth：Disjoint Set Union (Union Find)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html#algorithm"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Set系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/setyi-arraybiao-shi.html"&gt;Set：以Array表示&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Set(Find and Union)"></category><category term="Array"></category></entry><entry><title>Queue: 以Array實作Queue</title><link href="http://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html" rel="alternate"></link><updated>2016-04-29T21:42:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-29:SecondRound/queue-yi-arrayshi-zuo-queue.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將接續&lt;a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html"&gt;Queue: Intro(簡介)，並以Linked list實作&lt;/a&gt;，介紹以Array實作Queue的方法。&lt;/p&gt;
&lt;p&gt;關於Queue對資料的基本處理方法如&lt;code&gt;Push()&lt;/code&gt;、&lt;code&gt;Pop()&lt;/code&gt;等等，請參考&lt;a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html"&gt;Intro篇&lt;/a&gt;的介紹。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sequential"&gt;浪費記憶體空間的Array實作：Sequential Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#circular"&gt;節省記憶體空間的Array實作：Circular Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Queue系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="sequential"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;浪費記憶體空間的Array實作：Sequential Queue&lt;/h2&gt;
&lt;p&gt;如圖一，以Array實作Queue(隊伍)時，需定義兩個變數來記住Array的&lt;strong&gt;index&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以&lt;strong&gt;front&lt;/strong&gt;記住隊伍的開頭&lt;strong&gt;index&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;以&lt;strong&gt;back&lt;/strong&gt;記住隊伍的尾端&lt;strong&gt;index&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;進行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Push&lt;/strong&gt;：若要新增資料，按照Array的index順序：&lt;span class="math"&gt;\(0、1、2...\)&lt;/span&gt;，從Queue的&lt;strong&gt;back&lt;/strong&gt;新增資料。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pop&lt;/strong&gt;：若要刪除資料，按照Array的index順序：&lt;span class="math"&gt;\(0、1、2...\)&lt;/span&gt;，從Queue的&lt;strong&gt;front&lt;/strong&gt;刪除資料。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pop&lt;/strong&gt;並沒有真正把Array的記憶體位置釋放，只是調整&lt;strong&gt;front&lt;/strong&gt;，使得Queue「看起來」有刪除資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/Array/SequentialQueue.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上介紹的方法會有記憶體空間浪費的問題。&lt;br /&gt;
由於圖一的&lt;strong&gt;Push&lt;/strong&gt;是不斷往Queue的&lt;strong&gt;back&lt;/strong&gt;新增資料，因此Array的前兩個位置一旦被「想像地&lt;strong&gt;Pop&lt;/strong&gt;」後，會一直閒置到整個Array的記憶體被釋放為止，無法有效利用。&lt;/p&gt;
&lt;p&gt;下一小節將提出另一種以Array實作Queue的方法，將能夠有效利用Array中曾經被&lt;strong&gt;Pop&lt;/strong&gt;過的記憶體位置。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/Array/f60.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;另外，圖二的Array顯然已經填滿，若要在此Queue繼續增加資料，就需要重新配置一個容量更大的Array，方法如圖三，將資料複製到新的Array上，並且調整&lt;strong&gt;front&lt;/strong&gt;與&lt;strong&gt;back&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/Array/f61.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;完整的程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsFull&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// 驗證用, 可有可無&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newQueue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;newQueue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 新的array從0開始, 把舊的array&amp;quot;整段平移&amp;quot;, front跟back要更新&lt;/span&gt;
    &lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newQueue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsFull&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IsFull&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;  &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;QueueArraySequential&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 24: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 8, 23: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop 24: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 13: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop 8: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 35: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 9: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Queue&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;的測試中，最重要的是執行&lt;code&gt;Push(9)&lt;/code&gt;的前後。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Push(9)&lt;/code&gt;之前，Array的狀況如圖四(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時，Queue其實只有&lt;span class="math"&gt;\(3\)&lt;/span&gt;筆資料，理論上，具有大小為&lt;span class="math"&gt;\(5\)&lt;/span&gt;的Array應該要能夠再新增一筆資料。&lt;/li&gt;
&lt;li&gt;但是因為上述的&lt;code&gt;Push()&lt;/code&gt;與&lt;code&gt;Pop()&lt;/code&gt;，Array的前兩個記憶體位置無法重複利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/Array/f60.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;因此，若要&lt;code&gt;Push(9)&lt;/code&gt;，就需要重新配置容量更大的Array，才能在Queue中新增&lt;span class="math"&gt;\(9\)&lt;/span&gt;，見圖四(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時，Queue其實只有&lt;span class="math"&gt;\(4\)&lt;/span&gt;筆資料，但是使用了&lt;code&gt;capacity&lt;/code&gt;為&lt;span class="math"&gt;\(10\)&lt;/span&gt;的Array。&lt;ul&gt;
&lt;li&gt;這裡的&lt;code&gt;capacity&lt;/code&gt;更新成&lt;span class="math"&gt;\(10\)&lt;/span&gt;是因為程式範例中&lt;code&gt;DoubleCapacity()&lt;/code&gt;的寫法。&lt;/li&gt;
&lt;li&gt;根據不同「重新配置Array」的寫法，更新後的&lt;code&gt;capacity&lt;/code&gt;大小可能會有所不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/Array/f62.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據以上說明，第一種方法不只是記憶體空間的浪費，還有「重新配置Array」的運算成本浪費。&lt;/p&gt;
&lt;p&gt;接下來便介紹第二種以Array實作Queue的方法，能夠較為有效地利用Array的記憶體位置。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="circular"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;節省記憶體空間的Array實作：Circular Queue&lt;/h2&gt;
&lt;p&gt;第二種方法做出來的Queue又稱為&lt;strong&gt;Circular Queue&lt;/strong&gt;，環狀(circular)的意思就是能夠「繞回Array的前端」，重複利用Array的記憶體空間，見圖五：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/Array/CircularQueue.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;比較圖一的&lt;strong&gt;Sequential Queue&lt;/strong&gt;與圖五的&lt;strong&gt;Circular Queue&lt;/strong&gt;之差異：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sequential Queue&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;front&lt;/strong&gt;與&lt;strong&gt;back&lt;/strong&gt;之初始值為&lt;span class="math"&gt;\(-1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;一但被&lt;strong&gt;Pop&lt;/strong&gt;後的記憶體空間將閒置到Queue的物件(object)被釋放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Circular Queue&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;front&lt;/strong&gt;與&lt;strong&gt;back&lt;/strong&gt;之初始值為&lt;span class="math"&gt;\(0\)&lt;/span&gt;，因此會犧牲Array中的其中一個記憶體位置。&lt;/li&gt;
&lt;li&gt;被&lt;strong&gt;Pop&lt;/strong&gt;後的記憶體空間將會重複使用，將會用上餘數(mod)來計算index。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;     &lt;span class="c1"&gt;// 從0開始, 第一個位置放掉&lt;/span&gt;
        &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsFull&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// 驗證用, 可有可無&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newQueue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;newQueue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newQueue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsFull&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IsFull&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;QueueArrayCircular&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 24: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 8, 23: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop 24: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 13: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop 8: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 35: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 9: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 64: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;capacity: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCapacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;  number of elements: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Queue&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;front&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;    &lt;span class="nl"&gt;back&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;
&lt;span class="nl"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nl"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;中的測試結果可以看出，&lt;strong&gt;Circular Queue&lt;/strong&gt;確實有效地利用了Array的記憶體空間，與&lt;strong&gt;Sequential Queue&lt;/strong&gt;比較，在&lt;code&gt;Push(9)&lt;/code&gt;時，並沒有呼叫&lt;code&gt;DoubleCapacity()&lt;/code&gt;，因為&lt;strong&gt;Circular Queue&lt;/strong&gt;的&lt;code&gt;Push()&lt;/code&gt;會將資料新增至Array的開頭，如圖六：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/Array/f80.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;而接續圖六的狀態後，再繼續&lt;code&gt;Push(10)&lt;/code&gt;就會呼叫&lt;code&gt;DoubleCapacity()&lt;/code&gt;，如圖七，要注意的是必須按照&lt;strong&gt;front&lt;/strong&gt;到&lt;strong&gt;back&lt;/strong&gt;的順序複製資料，並且更新&lt;strong&gt;front&lt;/strong&gt;與&lt;strong&gt;back&lt;/strong&gt;所代表的index：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/Array/f81.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是以Array實作&lt;strong&gt;Sequential Queue&lt;/strong&gt;與&lt;strong&gt;Circular Queue&lt;/strong&gt;的介紹。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch10&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Queue系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html"&gt;Queue: Intro(簡介)，並以Linked list實作&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html"&gt;Queue: 以Array實作Queue&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Queue"></category><category term="Array"></category></entry><entry><title>Queue: Intro(簡介)，並以Linked list實作</title><link href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html" rel="alternate"></link><updated>2016-04-27T18:01:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-27:SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Queue(佇列)&lt;/strong&gt;是一種概念性的抽象資料結構，可以分別使用Linked list(連結串列)與Array(陣列)來實作。&lt;/p&gt;
&lt;p&gt;本篇文章將介紹Queue的基本概念，並以Linked list實作。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#intro"&gt;簡介：Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#app"&gt;Queue的應用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ll"&gt;以Linked list實作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Queue系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="intro"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;簡介：Queue&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Queue&lt;/strong&gt;是具有「First-In-First-Out」的資料結構，如同排隊買車票的隊伍即可視為&lt;strong&gt;Queue&lt;/strong&gt;，先進入隊伍的人，可以優先離開隊伍，走向售票窗口買票，而後到的人，就需要等隊伍前面的人都買完票後才能買。  &lt;/p&gt;
&lt;p&gt;如同普遍認知的排隊隊伍，Queue也具有以下特徵：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隊伍有前方(以&lt;strong&gt;front&lt;/strong&gt;表示)以及後方(以&lt;strong&gt;back&lt;/strong&gt;表示)之分。&lt;/li&gt;
&lt;li&gt;若要進入隊伍(&lt;strong&gt;Push&lt;/strong&gt;)，一定是從&lt;strong&gt;back&lt;/strong&gt;進入。&lt;/li&gt;
&lt;li&gt;若要離開隊伍(&lt;strong&gt;Pop&lt;/strong&gt;)，一定是從&lt;strong&gt;front&lt;/strong&gt;離開。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以圖一為例，由&lt;strong&gt;front&lt;/strong&gt;(隊伍前方)和&lt;strong&gt;back&lt;/strong&gt;(隊伍後方)可以判斷，進入隊伍的順序應該是&lt;span class="math"&gt;\(23、1、3、35\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;一般的&lt;strong&gt;Queue&lt;/strong&gt;，會有以下幾個處理資料結構的功能，配合圖二：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Push(data)&lt;/strong&gt;：把資料從Queue的「後面」放進Queue，並更新成新的&lt;strong&gt;back&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;在Queue中新增資料又稱為&lt;strong&gt;enqueue&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pop&lt;/strong&gt;：把&lt;strong&gt;front&lt;/strong&gt;所指向的資料從Queue中移除，並更新&lt;strong&gt;front&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;從Queue刪除資料又稱為&lt;strong&gt;dequeue&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getFront&lt;/strong&gt;：回傳&lt;strong&gt;front&lt;/strong&gt;所指向的資料。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getBack&lt;/strong&gt;：回傳&lt;strong&gt;back&lt;/strong&gt;所指向的資料。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IsEmpty&lt;/strong&gt;：確認Queue裡是否有資料。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getSize&lt;/strong&gt;：回傳Queue裡的資料個數。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/intro/queue.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="app"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Queue的應用&lt;/h2&gt;
&lt;p&gt;因為&lt;strong&gt;Queue&lt;/strong&gt;的「First-In-First-Out」特徵，常用於先到先執行、需要排程(&lt;strong&gt;scheduling&lt;/strong&gt;)的應用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;演算法：&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Breadth-First Search(廣度優先搜尋)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#level"&gt;Tree的Level-Order Traversal&lt;/a&gt;會用到&lt;strong&gt;Queue&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;作業系統：被多個程式共享的資源(例如CPU、印表機、網站伺服器)，一次只能執行一個需求(例如request、interrupt)，因此需要有個&lt;strong&gt;Queue&lt;/strong&gt;來安排多個程式的執行順序(例如device queue、job queue)，請參考：&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.tutorialspoint.com/operating_system/os_process_scheduling.htm"&gt;Tutorialspoint：Operating System - Process Scheduling&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2392824/what-are-practical-applications-of-queues"&gt;Stack Overflow：What are practical applications of Queues?&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cs.stackexchange.com/questions/1106/which-queue-does-the-long-term-scheduler-maintain"&gt;Stack Exchange：Which queue does the long-term scheduler maintain?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ll"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;以Linked list實作&lt;/h2&gt;
&lt;p&gt;以Linked list實作Queue非常直覺，如圖三，把每筆資料視為node，並且以&lt;strong&gt;pointer&lt;/strong&gt;前後連結：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Queue的&lt;code&gt;Push()&lt;/code&gt;：在list的「尾巴」新增資料。&lt;/li&gt;
&lt;li&gt;Queue的&lt;code&gt;Pop()&lt;/code&gt;：在list的「開頭」刪除資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/intro/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;和&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;介紹的Linked list的差異在於，因為Queue需要記得&lt;strong&gt;front&lt;/strong&gt;和&lt;strong&gt;back&lt;/strong&gt;的資料，所以Linked list除了原先記錄「第一個node」的&lt;strong&gt;pointer&lt;/strong&gt;之外，要再多一個&lt;strong&gt;pointer&lt;/strong&gt;記錄「最後一個node」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有了&lt;strong&gt;back pointer&lt;/strong&gt;後，便能在時間複雜度O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)完成「在Linked list尾巴新增資料」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;QueueNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;QueueNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;QueueNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;QueueNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;QueueList&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;QueueNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;QueueNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;QueueList&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;QueueList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QueueNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;QueueNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QueueNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;back&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// update back pointer&lt;/span&gt;
    &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;QueueList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;QueueNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;deletenode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// update front pointer&lt;/span&gt;
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;deletenode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;deletenode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;QueueList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

&lt;span class="c1"&gt;//    return (size == 0);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;QueueList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;QueueList&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 24: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 8: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 23: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 13: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop the front element: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;     back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After push 35: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;     back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop the front element: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop the front element: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop the front element: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;front: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getFront&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;    back: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;After pop the front element: &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;p&gt;```cpp
Queue is empty.&lt;/p&gt;
&lt;p&gt;After push 24: 
front: 24    back: 24&lt;/p&gt;
&lt;p&gt;After push 8: 
front: 24    back: 8&lt;/p&gt;
&lt;p&gt;After push 23: 
front: 24    back: 23&lt;/p&gt;
&lt;p&gt;After push 13: 
front: 24    back: 13&lt;/p&gt;
&lt;p&gt;After pop the front element: 
front: 8     back: 13&lt;/p&gt;
&lt;p&gt;After push 35: 
front: 8     back: 35&lt;/p&gt;
&lt;p&gt;After pop the front element: 
front: 23    back: 35&lt;/p&gt;
&lt;p&gt;After pop the front element: 
front: 13    back: 35&lt;/p&gt;
&lt;p&gt;After pop the front element: 
front: 35    back: 35&lt;/p&gt;
&lt;p&gt;After pop the front element: 
Queue is empty.```&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是&lt;strong&gt;Queue&lt;/strong&gt;的基本介紹。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch10&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tutorialspoint.com/operating_system/os_process_scheduling.htm"&gt;Tutorialspoint：Operating System - Process Scheduling&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2392824/what-are-practical-applications-of-queues"&gt;Stack Overflow：What are practical applications of Queues?&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cs.stackexchange.com/questions/1106/which-queue-does-the-long-term-scheduler-maintain"&gt;Stack Exchange：Which queue does the long-term scheduler maintain?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.quora.com/What-are-the-applications-of-queues-and-stacks-in-C++"&gt;Quora：What are the applications of queues and stacks in C++?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Queue系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html"&gt;Queue: Intro(簡介)，並以Linked list實作&lt;/a&gt;  &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html"&gt;Queue: 以Array實作Queue&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category><category term="Queue"></category><category term="Linked List"></category></entry><entry><title>Stack: 能夠在O(1)取得最小值的MinStack</title><link href="http://alrightchiu.github.io/SecondRound/stack-neng-gou-zai-o1qu-de-zui-xiao-zhi-de-minstack.html" rel="alternate"></link><updated>2016-04-25T12:08:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-25:SecondRound/stack-neng-gou-zai-o1qu-de-zui-xiao-zhi-de-minstack.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;眾所皆知，若手上處理的資料結構是Stack，除了「最上面」的資料可以輕易讀取(利用&lt;code&gt;top()&lt;/code&gt;)，若要知道Stack中的其餘資料，就只能透過從Stack的最上方把資料一個一個&lt;code&gt;pop()&lt;/code&gt;後，才能檢視，時間複雜度為O(&lt;span class="math"&gt;\(N\)&lt;/span&gt;)。&lt;/p&gt;
&lt;p&gt;如果想要在O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)的時間複雜度取得Stack中的「最小值」資料，該如何設計呢？&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/MinStack/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖一為例，因為圖一是Stack的剖面圖，所以很容易可以看出，目前Stack中的最小值為&lt;span class="math"&gt;\(4\)&lt;/span&gt;。但是一般的Stack並沒有提供剖面圖這種東西，只能透過函式&lt;code&gt;top()&lt;/code&gt;來得知Stack「最上面」的&lt;span class="math"&gt;\(9\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;本篇文章要介紹的便是能夠在O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)的時間複雜度，得知目前Stack裡的「最小值」的進化版Stack，以下稱為&lt;strong&gt;MinStack&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在程式範例中將使用標準模板函式庫(STL)的&lt;code&gt;std::stack&amp;lt;int&amp;gt;&lt;/code&gt;，其基本函式功能可以參考&lt;a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html"&gt;Stack: Intro(簡介)&lt;/a&gt;，更多內容請參考：&lt;a href="http://www.cplusplus.com/reference/stack/stack/"&gt;Cplusplus：std::stack&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#minstack"&gt;以兩個Stack來實作MinStack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Stack系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="minstack"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;以兩個Stack來實作MinStack&lt;/h2&gt;
&lt;p&gt;要實作出&lt;strong&gt;MinStack&lt;/strong&gt;的關鍵就是在一個&lt;code&gt;class MinStack&lt;/code&gt;中使用「兩個Stack」，其中一個Stack用來存放資料(稱為&lt;code&gt;datastack&lt;/code&gt;)，另一個用來記錄「目前最小值」(稱為&lt;code&gt;minstack&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Push()&lt;/code&gt;新增資料時：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;datastack&lt;/code&gt;一如往常以&lt;code&gt;push()&lt;/code&gt;將資料放進Stack中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minstack&lt;/code&gt;就必須判斷「欲新增的資料」是否有比「目前最上面」還要小。&lt;ul&gt;
&lt;li&gt;如果有，就把「欲新增的資料」&lt;code&gt;push()&lt;/code&gt;進&lt;code&gt;minstack&lt;/code&gt;，此時該資料會位在Stack的「最上面」。  &lt;ul&gt;
&lt;li&gt;特例：如果原先&lt;code&gt;minstack&lt;/code&gt;裏面沒有資料，那麼就直接將「欲新增的資料」&lt;code&gt;push()&lt;/code&gt;進&lt;code&gt;minstack&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;透過這個步驟，可以保證&lt;code&gt;minstack&lt;/code&gt;的「最上面」資料就是&lt;code&gt;datastack&lt;/code&gt;中的「最小值」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果沒有，就把&lt;code&gt;minstack&lt;/code&gt;「目前最上面」的資料，再&lt;code&gt;push()&lt;/code&gt;進&lt;code&gt;minstack&lt;/code&gt;一次，表示在新增資料後，「最小值」不變。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
以圖二(a)為例，先後進行了「新增&lt;span class="math"&gt;\(6\)&lt;/span&gt;」與「新增&lt;span class="math"&gt;\(13\)&lt;/span&gt;」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在新增&lt;span class="math"&gt;\(6\)&lt;/span&gt;時：&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;push(6)&lt;/code&gt;將&lt;span class="math"&gt;\(6\)&lt;/span&gt;放進&lt;code&gt;datastack&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因為&lt;code&gt;minstack&lt;/code&gt;目前是空的，便同樣以&lt;code&gt;push(6)&lt;/code&gt;將&lt;span class="math"&gt;\(6\)&lt;/span&gt;放進&lt;code&gt;minstack&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;從&lt;code&gt;minstack&lt;/code&gt;的「最上面」資料可以得知，目前&lt;code&gt;datastack&lt;/code&gt;中的「最小值」是&lt;span class="math"&gt;\(6\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在新增&lt;span class="math"&gt;\(13\)&lt;/span&gt;時：&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;push(13)&lt;/code&gt;將&lt;span class="math"&gt;\(13\)&lt;/span&gt;放進&lt;code&gt;datastack&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;判斷出&lt;span class="math"&gt;\(13\)&lt;/span&gt;與目前&lt;code&gt;minstack&lt;/code&gt;的「最上面」資料何者較小，並將較小者&lt;code&gt;push()&lt;/code&gt;進&lt;code&gt;minstack&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;同樣地，透過&lt;code&gt;minsatck&lt;/code&gt;的「最上面」資料，可以得知目前&lt;code&gt;datastack&lt;/code&gt;中的「最小值」仍然是&lt;span class="math"&gt;\(6\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/MinStack/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著又新增了&lt;span class="math"&gt;\(4\)&lt;/span&gt;、&lt;span class="math"&gt;\(9\)&lt;/span&gt;、&lt;span class="math"&gt;\(1\)&lt;/span&gt;，觀察圖二(b)，&lt;code&gt;minstack&lt;/code&gt;的「最上面」資料，一定記錄著&lt;code&gt;datastack&lt;/code&gt;的「最小值」。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/MinStack/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt; &lt;br /&gt;
由於&lt;code&gt;Push()&lt;/code&gt;新增資料時對&lt;code&gt;minstack&lt;/code&gt;的處理，在&lt;code&gt;Pop()&lt;/code&gt;刪除資料時，&lt;code&gt;datastack&lt;/code&gt;和&lt;code&gt;minstack&lt;/code&gt;只要同步進行&lt;code&gt;pop()&lt;/code&gt;即可，觀察圖三，每一次之後，&lt;code&gt;minstack&lt;/code&gt;的「最上面」資料仍然是&lt;code&gt;datastack&lt;/code&gt;的「最小值」。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/MinStack/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/MinStack/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;完整程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stack&amp;gt;        &lt;/span&gt;&lt;span class="c1"&gt;// std::stack&amp;lt;&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MinStack&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;minstack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;MinStack&lt;/span&gt;&lt;span class="p"&gt;(){};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;MinStack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;minstack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;minstack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;minstack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;minstack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;minstack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;MinStack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stack is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;minstack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;MinStack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stack is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;minstack&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;MinStack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;MinStack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stack is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// sorry for the bad exception handling&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                          
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;MinStack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stack is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;MinStack&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;min: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nl"&gt;min&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是分別以兩個&lt;code&gt;std::stack&amp;lt;&amp;gt;&lt;/code&gt;實作&lt;strong&gt;MinStack&lt;/strong&gt;的方法。  &lt;/p&gt;
&lt;p&gt;更多相關的討論，包括更節省記憶體空間的做法，請參考：&lt;a href="http://stackoverflow.com/questions/685060/design-a-stack-such-that-getminimum-should-be-o1"&gt;Stack Overflow：design a stack such that getMinimum( ) should be O(1)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch10&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/685060/design-a-stack-such-that-getminimum-should-be-o1"&gt;Stack Overflow：design a stack such that getMinimum( ) should be O(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cplusplus.com/reference/stack/stack/"&gt;Cplusplus：std::stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Stack系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html"&gt;Stack: Intro(簡介)&lt;/a&gt;  &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html"&gt;Stack: 以Array與Linked list實作&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/stack-neng-gou-zai-o1qu-de-zui-xiao-zhi-de-minstack.html"&gt;Stack: 能夠在O(1)取得最小值的MinStack&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Stack"></category></entry><entry><title>Stack: 以Array與Linked list實作</title><link href="http://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html" rel="alternate"></link><updated>2016-04-24T10:28:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-24:SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章接續&lt;a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html"&gt;Stack: Intro(簡介)&lt;/a&gt;，介紹以Array與Linked list實作Stack的方法。&lt;/p&gt;
&lt;p&gt;如果對Linked list不太熟悉，建議讀者可以先閱讀以下連結之內容做簡單複習：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#array"&gt;以Array實作Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ll"&gt;以Linked list實作Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Stack系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="array"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;以Array實作Stack&lt;/h2&gt;
&lt;p&gt;在以Array(陣列)實作Stack的程式範例中，&lt;code&gt;class StackArray&lt;/code&gt;的&lt;code&gt;private data&lt;/code&gt;有三項：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int top&lt;/code&gt;：記錄於stack中，最上面資料的index。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int capacity&lt;/code&gt;：即為Array的size，也就是實際配置的記憶體大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int *stack&lt;/code&gt;：這裡以&lt;code&gt;int&lt;/code&gt;作為資料的形別(type)做示範，所以就以&lt;code&gt;int&lt;/code&gt;的Array來表示Stack。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及Stack的基本處理資料的函式：&lt;code&gt;Push()&lt;/code&gt;、&lt;code&gt;Pop()&lt;/code&gt;、&lt;code&gt;IsEmpty()&lt;/code&gt;、&lt;code&gt;Top()&lt;/code&gt;、&lt;code&gt;getSize()&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;比較需要注意的有：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DoubleCapacity()&lt;/code&gt;：因為利用Array來存放資料，所以有可能在不斷新增資料(&lt;code&gt;Push()&lt;/code&gt;)時，碰上一開始分配給Array的記憶體空間(&lt;code&gt;capacity&lt;/code&gt;)不夠的情況，可以透過重新配置一個&lt;code&gt;capacity&lt;/code&gt;為兩倍大的Array來解決。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更理想的做法是，能夠先對欲放進Stack處理的資料數量有個底，在初始化時，就把&lt;code&gt;capacity&lt;/code&gt;設定在差不多的範圍，如此一來，不需要重複多次&lt;code&gt;DoubleCapacity()&lt;/code&gt;，也不會過分浪費記憶體空間。&lt;/li&gt;
&lt;li&gt;本篇文章提供的範例程式碼將&lt;code&gt;capacity&lt;/code&gt;初始為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，主要是為了方便測試&lt;code&gt;DoubleCapacity()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Pop()&lt;/code&gt;：最常見的做法，是「想像地」把資料從Array中移除，意思是，當呼叫&lt;code&gt;Pop()&lt;/code&gt;時，其實只是把&lt;code&gt;int top&lt;/code&gt;減一，並沒有真的把資料從Array中移除，這麼做的原因是，等到下次&lt;code&gt;Push()&lt;/code&gt;新增資料時，自然會把該記憶體位置覆寫(overwrite)，見圖二(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當&lt;code&gt;Pop()&lt;/code&gt;時，並沒有把&lt;span class="math"&gt;\(7\)&lt;/span&gt;刪除，只是把&lt;code&gt;top&lt;/code&gt;移回到&lt;span class="math"&gt;\(3\)&lt;/span&gt;，讓Stack看起來已經把&lt;span class="math"&gt;\(7\)&lt;/span&gt;移除，此時「最上面」資料是&lt;span class="math"&gt;\(3\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;也有些寫法比較謹慎，會把原先是&lt;span class="math"&gt;\(7\)&lt;/span&gt;的記憶體位置，以&lt;span class="math"&gt;\(0\)&lt;/span&gt;覆寫，見圖二(b)。&lt;ul&gt;
&lt;li&gt;參考：&lt;a href="http://emn178.pixnet.net/blog/post/93426076-%E5%A0%86%E7%96%8A%28stack%29"&gt;小殘的程式光廊：堆疊(Stack)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;還有ㄧ些寫法會真的把&lt;span class="math"&gt;\(7\)&lt;/span&gt;移除，此時就需要呼叫&lt;code&gt;class&lt;/code&gt;的&lt;code&gt;destructor&lt;/code&gt;。但是這種寫法並不推薦，原因是「向系統要記憶體」需要成本，如果接下來Stack還會新增資料，那麼只要確實更新&lt;code&gt;top&lt;/code&gt;使得Stack「看起來」有&lt;code&gt;Pop()&lt;/code&gt;就好。&lt;ul&gt;
&lt;li&gt;參考：&lt;a href="http://stackoverflow.com/questions/13215645/freeing-last-element-of-a-dynamic-array"&gt;Stack Overflow：Freeing last element of a dynamic array&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/implement/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/implement/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;完整程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StackArray&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// index of top element&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// allocated memory space of array&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// array representing stack&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// double the capacity of stack&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;StackArray&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;    &lt;span class="c1"&gt;// constructor&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="c1"&gt;// initial state: top=-1, capacity=1&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;StackArray&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                            &lt;span class="c1"&gt;// double capacity&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newStack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;        &lt;span class="c1"&gt;// create newStack&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// copy element to newStack&lt;/span&gt;
        &lt;span class="n"&gt;newStack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// release the memory of stack&lt;/span&gt;
    &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newStack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// redirect stack to newStack&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;StackArray&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// if stack is full, double the capacity&lt;/span&gt;
        &lt;span class="n"&gt;DoubleCapacity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// update top and put x into stack&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;StackArray&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;          &lt;span class="c1"&gt;// if stack is empty, there is nothing to pop&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stack is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// update top&lt;/span&gt;
&lt;span class="c1"&gt;//    stack[top] = 0;         // (*1)&lt;/span&gt;
&lt;span class="c1"&gt;//    stack[top].~T();        // (*2)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;StackArray&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="c1"&gt;//    if (top == -1) {&lt;/span&gt;
    &lt;span class="c1"&gt;//        return true;&lt;/span&gt;
    &lt;span class="c1"&gt;//    }&lt;/span&gt;
    &lt;span class="c1"&gt;//    else {&lt;/span&gt;
    &lt;span class="c1"&gt;//        return false;&lt;/span&gt;
    &lt;span class="c1"&gt;//    }&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;StackArray&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     &lt;span class="c1"&gt;// check if stack is empty&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stack is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;   &lt;span class="c1"&gt;// return the top element&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;StackArray&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// return the number of elements in stack&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;StackArray&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;size: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;size: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;size: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;size: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;
&lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;main()&lt;/code&gt;測試的結果與圖二(c)相同：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/implement/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ll"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;以Linked list實作Stack&lt;/h2&gt;
&lt;p&gt;Stack也可以用Linked list實現，以圖三(a)的Linked list為例，原先用來記錄第一個node的指標&lt;code&gt;first&lt;/code&gt;，在Stack的實作上，就是用來記錄Stack「最上面」資料的指標&lt;code&gt;top&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/implement/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;這裡延續&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;對Linked list的實作方法，採用兩個&lt;code&gt;class&lt;/code&gt;，一個是&lt;code&gt;class StackNode&lt;/code&gt;，表示Linked list的node，一個是&lt;code&gt;class StackList&lt;/code&gt;，其記錄Stack的「最上面node」，作為整個Stack的存取入口(如同Linked list是以「第一個node」作為存取入口)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些寫法是利用&lt;code&gt;struct&lt;/code&gt;來建立node，雖然&lt;code&gt;struct StackNode&lt;/code&gt;的資料成員(data member)一定是&lt;strong&gt;public&lt;/strong&gt;，不過只要把&lt;code&gt;class StackList&lt;/code&gt;的&lt;code&gt;StackNode *top&lt;/code&gt;設成&lt;strong&gt;private&lt;/strong&gt;，那麼在&lt;code&gt;main()&lt;/code&gt;同樣無法更改每個node的資料。&lt;br /&gt;
參考：&lt;a href="http://codereview.stackexchange.com/questions/102393/c-stack-using-template"&gt;Code Review：C++ Stack using template&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
特別注意&lt;code&gt;Push()&lt;/code&gt;函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為要保持&lt;code&gt;StackNode *top&lt;/code&gt;一直在Linked list的第一個位置，所以Stack在&lt;code&gt;Push()&lt;/code&gt;新增資料時，採用Linked list的&lt;code&gt;Push_front()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在程式範例中，有這麼一行&lt;code&gt;StackNode *newnode = new StackNode(x,top);&lt;/code&gt;(目前是註解的狀態)是利用&lt;code&gt;class StackNode&lt;/code&gt;的第三個&lt;strong&gt;constructor&lt;/strong&gt;，直接把新增的node之&lt;code&gt;next pointer&lt;/code&gt;指向&lt;code&gt;top&lt;/code&gt;。&lt;br /&gt;
其功能等同於「先利用&lt;code&gt;class StackNode&lt;/code&gt;的第二個&lt;strong&gt;constructor&lt;/strong&gt;，再手動更新&lt;code&gt;newNode&lt;/code&gt;的&lt;code&gt;next pointer&lt;/code&gt;」。&lt;ul&gt;
&lt;li&gt;小結論：好好利用&lt;strong&gt;constructor&lt;/strong&gt;會更有效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StackList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StackNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;StackNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;StackNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;StackNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;StackNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;StackNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nextNode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nextNode&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StackList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StackList&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;StackNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// remember the address of top element &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// number of elements in Stack&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;                 
    &lt;span class="n"&gt;StackList&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;StackList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StackNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;StackNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newnode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StackNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// Push_front() in Linked list&lt;/span&gt;
    &lt;span class="n"&gt;newnode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    
&lt;span class="c1"&gt;//    StackNode *newnode = new StackNode(x,top);&lt;/span&gt;
    &lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newnode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;StackList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stack is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;StackNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;deletenode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;deletenode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;deletenode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;StackList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// if size==0, return true&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;StackList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stack is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;StackList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;StackList&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;size: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;size: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;size: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          
    &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;top: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;size: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
&lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;main()&lt;/code&gt;測試的結果與圖三(b)相同：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/implement/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是分別以Array和Linked list實作Stack的方法。  &lt;/p&gt;
&lt;p&gt;兩者的優劣，可以參考&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html#comp"&gt;Linked List: Intro(簡介)&lt;/a&gt;中Array與Linked list的比較。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch10&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emn178.pixnet.net/blog/post/93426076-%E5%A0%86%E7%96%8A%28stack%29"&gt;小殘的程式光廊：堆疊(Stack)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/13215645/freeing-last-element-of-a-dynamic-array"&gt;Stack Overflow：Freeing last element of a dynamic array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codereview.stackexchange.com/questions/102393/c-stack-using-template"&gt;Code Review：C++ Stack using template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Stack系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html"&gt;Stack: Intro(簡介)&lt;/a&gt;  &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html"&gt;Stack: 以Array與Linked list實作&lt;/a&gt;  &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/stack-neng-gou-zai-o1qu-de-zui-xiao-zhi-de-minstack.html"&gt;Stack: 能夠在O(1)取得最小值的MinStack&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Stack"></category><category term="Linked List"></category><category term="Array"></category></entry><entry><title>Stack: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html" rel="alternate"></link><updated>2016-04-22T20:23:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-22:SecondRound/stack-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Stack(堆疊)&lt;/strong&gt;是一種概念性的抽象資料結構，可以分別使用Array(陣列)與Linked list(連結串列)來實作。&lt;/p&gt;
&lt;p&gt;本篇文章將介紹Stack的基本概念，程式實作留在下一篇。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#intro"&gt;簡介：Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#app"&gt;Stack的應用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Stack系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="intro"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;簡介：Stack&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;是具有「Last-In-First-Out」的資料結構(可以想像成一種裝資料的容器)，「最晚進入Stack」的資料會「最先被取出」，「最早進入Stack」的資料則「最晚被取出」。  &lt;/p&gt;
&lt;p&gt;就像搬家的時候要把書(資料)裝進箱子(Stack)，假設箱子的開口大小剛剛好只能平放一本書，如果先放入《灌籃高手》，再放《笑傲江湖》，再放《搶救國文大作戰》，那麼到了新家之後，因為箱子底下沒有破洞，所以要拿到最底下的《灌籃高手》，就一定得先把上面的《搶救國文大作戰》與《笑傲江湖》拿出箱子才行。  &lt;/p&gt;
&lt;p&gt;觀察以上的敘述，《灌籃高手》符合「最早放入箱子」而且「最晚拿出來」，而《搶救國文大作戰》符合「最晚放入箱子」且「最早拿出來」，其餘的資料也勢必符合此規則(每個資料至少會位於「最上面」一次)，便能夠將這個箱子視為一個Stack。&lt;br /&gt;
由此可見，Stack是一個抽象的概念，只要符合「Last-In-First-Out」的資料結構，都可以視為Stack。&lt;/p&gt;
&lt;p&gt;一般的&lt;strong&gt;Stack&lt;/strong&gt;，會有以下幾個處理資料結構的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Push(data)&lt;/strong&gt;：把資料放進Stack。&lt;ul&gt;
&lt;li&gt;把書放進箱子。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pop&lt;/strong&gt;：把「最上面」的資料從Stack中移除。&lt;ul&gt;
&lt;li&gt;把位於箱子「最上面」的書拿出來。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Top&lt;/strong&gt;：回傳「最上面」的資料，不影響資料結構本身。&lt;ul&gt;
&lt;li&gt;確認目前位於箱子「最上面」的是哪本書。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IsEmpty&lt;/strong&gt;：確認Stack裡是否有資料，不影響資料結構本身。&lt;ul&gt;
&lt;li&gt;確認箱子裡面有沒有書。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getSize&lt;/strong&gt;：回傳Stack裡的資料個數，不影響資料結構本身。&lt;ul&gt;
&lt;li&gt;記錄目前箱子已經裝了多少本書。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖一為例，一開始Stack是空的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當&lt;code&gt;Push(6)&lt;/code&gt;後，便把&lt;span class="math"&gt;\(6\)&lt;/span&gt;放入Stack。並用一個稱為&lt;code&gt;top&lt;/code&gt;的變數，記錄Stack最上面的資料為何，在此即為&lt;span class="math"&gt;\(6\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;當&lt;code&gt;Push(3)&lt;/code&gt;、&lt;code&gt;Push(7)&lt;/code&gt;後，便把&lt;span class="math"&gt;\(3、7\)&lt;/span&gt;放入Stack。並更新&lt;code&gt;top&lt;/code&gt;，使其記錄&lt;span class="math"&gt;\(7\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;當&lt;code&gt;Pop()&lt;/code&gt;後，便把Stack中「最上面」的資料(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)給移除，所以Stack中剩下&lt;span class="math"&gt;\(6、3\)&lt;/span&gt;，並更新&lt;code&gt;top&lt;/code&gt;記錄&lt;span class="math"&gt;\(3\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;當&lt;code&gt;Push(14)&lt;/code&gt;、&lt;code&gt;Push(8)&lt;/code&gt;後，便把&lt;span class="math"&gt;\(14、8\)&lt;/span&gt;放入Stack。並更新&lt;code&gt;top&lt;/code&gt;，使其記錄&lt;span class="math"&gt;\(8\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;在以上的任何階段，只要Stack有資料，使用函式&lt;code&gt;Top()&lt;/code&gt;會回傳變數&lt;code&gt;top&lt;/code&gt;所記錄的資料。&lt;/li&gt;
&lt;li&gt;在以上的任何階段，使用&lt;code&gt;IsEmpty()&lt;/code&gt;便能判斷Stack裡是否有存放資料。&lt;/li&gt;
&lt;li&gt;在以上的任何階段，使用&lt;code&gt;getSize()&lt;/code&gt;會回傳Stack中的資料個數。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Stack還有一項重要的特徵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了最上面的資料可以使用&lt;code&gt;Top()&lt;/code&gt;來讀取，無法得知Stack裡面還有其餘哪些資料。要知道Stack裡的所有資料，只能靠&lt;code&gt;Pop()&lt;/code&gt;，把資料一個一個拿出來檢查。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="app"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Stack的應用&lt;/h2&gt;
&lt;p&gt;Stack最主要的功能是「記得先前的資訊」，所以時常用來處理需要「回復到先前的狀態」的問題，也稱為&lt;strong&gt;Back-Tracking&lt;/strong&gt;問題，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;編輯器(如word、sublime等等)中的&lt;strong&gt;undo&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;網頁瀏覽器的「回到前一頁」功能。&lt;/li&gt;
&lt;li&gt;編譯器(compiler)中的&lt;strong&gt;Parsing&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;參考：&lt;a href="http://www.tutorialspoint.com/compiler_design/compiler_design_top_down_parser.htm"&gt;Compiler Design - Top-Down Parser&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任何&lt;strong&gt;遞迴(recursion)&lt;/strong&gt;形式的演算法，都可以用Stack改寫，例如Depth-First Search(DFS，深度優先搜尋)。&lt;ul&gt;
&lt;li&gt;參考：&lt;a href="http://www.geeksforgeeks.org/iterative-depth-first-traversal/"&gt;GeeksforGeeks:Iterative Depth First Traversal of Graph&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;因為&lt;strong&gt;遞迴(recursion)&lt;/strong&gt;使用了系統的&lt;strong&gt;Call Stack&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;於記憶體管理(memory management)中的&lt;strong&gt;Call Stack&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;參考：&lt;a href="https://en.wikipedia.org/wiki/Call_stack"&gt;Wikipedia：Call stack&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;參考：&lt;a href="http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"&gt;Stack Overflow：What and where are the stack and heap?&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是&lt;strong&gt;Stack&lt;/strong&gt;的初步介紹。  &lt;/p&gt;
&lt;p&gt;下一篇文章將介紹以Array與Linked list實作Stack的方法。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch10&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tutorialspoint.com/compiler_design/compiler_design_top_down_parser.htm"&gt;Compiler Design - Top-Down Parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/iterative-depth-first-traversal/"&gt;GeeksforGeeks:Iterative Depth First Traversal of Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Call_stack"&gt;Wikipedia：Call stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"&gt;Stack Overflow：What and where are the stack and heap?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jcsites.juniata.edu/faculty/kruse/cs240/stackapps.htm"&gt;Gerald W. Kruse：Stack Applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.quora.com/What-are-the-applications-of-queues-and-stacks-in-C++"&gt;Quora：What are the applications of queues and stacks in C++?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Stack系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html"&gt;Stack: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html"&gt;Stack: 以Array與Linked list實作&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/stack-neng-gou-zai-o1qu-de-zui-xiao-zhi-de-minstack.html"&gt;Stack: 能夠在O(1)取得最小值的MinStack&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category><category term="Stack"></category></entry><entry><title>Linked List: 新增資料、刪除資料、反轉</title><link href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html" rel="alternate"></link><updated>2016-04-19T22:39:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-19:SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將延續&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List: Intro(簡介)&lt;/a&gt;，繼續介紹於Linked list中常見的操作：新增資料、刪除資料與反轉Linked list。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linked list&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class ListNode&lt;/code&gt;與&lt;code&gt;class LinkedList&lt;/code&gt;的定義如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 為了將class LinkedList設成class ListNode的friend,&lt;/span&gt;
                     &lt;span class="c1"&gt;// 需要先宣告&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// int size;                // size是用來記錄Linked list的長度, 非必要&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// list的第一個node&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// 印出list的所有資料&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Push_front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 在list的開頭新增node&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 在list的尾巴新增node&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// 刪除list中的 int x&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// 把整串list刪除&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Reverse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// 將list反轉: 7-&amp;gt;3-&amp;gt;14 =&amp;gt; 14-&amp;gt;3-&amp;gt;7&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#print"&gt;函式：PrintList&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#front"&gt;函式：Push_front&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#back"&gt;函式：Push_back&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delete"&gt;函式：Delete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#clearall"&gt;函式：Clear&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reverse"&gt;函式：Reverse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#test"&gt;測試&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Linked list系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="print"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;函式：PrintList&lt;/h2&gt;
&lt;p&gt;第一個要介紹的是&lt;code&gt;PrintList()&lt;/code&gt;，功能就是把Linked list中的所有資料依序印出。要印出所有的資料，就必須「逐一訪問(&lt;strong&gt;Visiting&lt;/strong&gt;)」Linked list中的每一個node，這樣的操作又稱為&lt;strong&gt;Traversal(尋訪)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;能夠完成這樣的操作，要歸功於node中記錄了「下一個node的記憶體位置」，如此，才能在訪問完當前的node之後，知道要繼續往哪一個記憶體位置上的node前進。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖一為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立&lt;code&gt;ListNode *current&lt;/code&gt;來表示「目前走到哪一個node」。&lt;/li&gt;
&lt;li&gt;若要對Linked list存取資料，必定是從第一個node開始，所以把&lt;code&gt;current&lt;/code&gt;指向&lt;code&gt;first&lt;/code&gt;所代表的記憶體位置，&lt;code&gt;current=first&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;目前&lt;code&gt;first&lt;/code&gt;即為node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;同時，還能夠知道「下一個node」是指向node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在印出&lt;code&gt;current-&amp;gt;data&lt;/code&gt;，也就是&lt;span class="math"&gt;\(7\)&lt;/span&gt;後，便把&lt;code&gt;current&lt;/code&gt;移動到「下一個node」。&lt;ul&gt;
&lt;li&gt;透過&lt;code&gt;current=current-&amp;gt;next&lt;/code&gt;，即可把&lt;code&gt;current&lt;/code&gt;指向node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)所在的記憶體位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重複上述步驟，直到&lt;code&gt;current&lt;/code&gt;指向Linked list的終點&lt;code&gt;NULL&lt;/code&gt;為止，便能印出所有資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可見，所有需要在Linked list中尋找特定資料的操作，都會用上&lt;strong&gt;Traversal&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintList&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                      &lt;span class="c1"&gt;// 如果first node指向NULL, 表示list沒有資料&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;List is empty.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                 &lt;span class="c1"&gt;// Traversal&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="front"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;函式：Push_front&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Push_front()&lt;/code&gt;的功能是在Linked list的開頭新增資料。  &lt;/p&gt;
&lt;p&gt;若考慮在Linked list(&lt;span class="math"&gt;\(3\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(14\)&lt;/span&gt;)的開頭加入&lt;span class="math"&gt;\(23\)&lt;/span&gt;，方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先建立一個新的節點&lt;code&gt;ListNode *newNode&lt;/code&gt;，帶有欲新增的資料(&lt;span class="math"&gt;\(23\)&lt;/span&gt;)，如圖二(a)。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;newNode&lt;/code&gt;中的&lt;strong&gt;pointer&lt;/strong&gt;，&lt;code&gt;ListNode *next&lt;/code&gt;，指向Linked list的第一個node&lt;code&gt;first&lt;/code&gt;，如圖二(b)。&lt;/li&gt;
&lt;li&gt;接著，把&lt;code&gt;first&lt;/code&gt;更新成&lt;code&gt;newNode&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;經過以上步驟(時間複雜度為O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;))便得到新的Linked list：&lt;span class="math"&gt;\(23\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(3\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(14\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Push_front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 先把first接在newNode後面&lt;/span&gt;
    &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 再把first指向newNode所指向的記憶體位置&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="back"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;函式：Push_back&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Push_back()&lt;/code&gt;的功能是在Linked list的尾巴新增資料。&lt;/p&gt;
&lt;p&gt;若考慮在Linked list(&lt;span class="math"&gt;\(7\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(3\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(14\)&lt;/span&gt;)的尾巴加入&lt;span class="math"&gt;\(23\)&lt;/span&gt;，方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先建立一個新的節點&lt;code&gt;ListNode *newNode&lt;/code&gt;，帶有欲新增的資料(&lt;span class="math"&gt;\(23\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;先利用如同&lt;code&gt;PrintList()&lt;/code&gt;中提過的&lt;strong&gt;Traversal&lt;/strong&gt;，把新建立的&lt;code&gt;ListNode *current&lt;/code&gt;移動到Linked list的尾端，node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)，如圖三(a)。&lt;ul&gt;
&lt;li&gt;有些資料結構會在&lt;code&gt;class LinkedList&lt;/code&gt;中新增一項&lt;code&gt;ListNode *last&lt;/code&gt;，記錄Linked list的最後一個node，那麼，&lt;code&gt;Push_back()&lt;/code&gt;就不需要&lt;strong&gt;Traversal&lt;/strong&gt;，可以在O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)時間內完成。&lt;/li&gt;
&lt;li&gt;若沒有&lt;code&gt;ListNode *last&lt;/code&gt;，就需要O(&lt;span class="math"&gt;\(N\)&lt;/span&gt;)的&lt;strong&gt;Traversal&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接著把&lt;code&gt;current&lt;/code&gt;的&lt;code&gt;next pointer&lt;/code&gt;指向newNode，如圖三(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即可得到新的Linked list：&lt;span class="math"&gt;\(7\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(3\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(14\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(23\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;             &lt;span class="c1"&gt;// 若list沒有node, 令newNode為first&lt;/span&gt;
        &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// Traversal&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="delete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;函式：Delete&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Delete(int x)&lt;/code&gt;的功能是要刪除Linked list中，資料為&lt;code&gt;int x&lt;/code&gt;的node。&lt;br /&gt;
會有兩種情形，第一種是Linked list中確實有&lt;code&gt;int x&lt;/code&gt;，第二種是沒有。在第一種情況中，要再把&lt;code&gt;int x&lt;/code&gt;位於&lt;code&gt;first&lt;/code&gt;的情況分開。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;case1-1&lt;/strong&gt;：要在Linked list(&lt;span class="math"&gt;\(7\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(3\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(14\)&lt;/span&gt;)中刪除具有&lt;span class="math"&gt;\(3\)&lt;/span&gt;的node，見圖四(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用&lt;strong&gt;Traversal&lt;/strong&gt;的概念，以&lt;code&gt;ListNode *current&lt;/code&gt;指向node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)，同時有&lt;code&gt;ListNode *previous&lt;/code&gt;指向node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)的「前一個node」，node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;接著，把&lt;code&gt;previsou&lt;/code&gt;的&lt;code&gt;next pointer&lt;/code&gt;指向&lt;code&gt;current&lt;/code&gt;的&lt;code&gt;next pointer&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再把&lt;code&gt;current&lt;/code&gt;的記憶體釋放(若是使用&lt;code&gt;new&lt;/code&gt;進行動態配置，就使用&lt;code&gt;delete&lt;/code&gt;釋放)，還給&lt;strong&gt;heap&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;關鍵就是，在整個&lt;code&gt;Delete()&lt;/code&gt;的過程，只有node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)知道node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)的記憶體位置，所以在把node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)刪除之前，必須先透過node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)的&lt;strong&gt;pointer&lt;/strong&gt;找到node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)，把node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)接到node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)上(也可以說是，換成用node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)的&lt;strong&gt;pointer&lt;/strong&gt;記住node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)的記憶體位置)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;case1-2&lt;/strong&gt;：若要刪除具有&lt;span class="math"&gt;\(7\)&lt;/span&gt;的node，而且Linked list只有一個node，見圖四(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要把這個情況獨立出來的原因是，這個情況不會進行&lt;strong&gt;Traversal&lt;/strong&gt;，所以&lt;code&gt;ListNode *previous&lt;/code&gt;始終指向&lt;code&gt;NULL&lt;/code&gt;，便不能呼叫其private data，若進行&lt;code&gt;previous-&amp;gt;next&lt;/code&gt;將會因為意圖對「無效的」記憶體位置進行存取，而產生像是「EXC_BAD_ACCESS」的錯誤(error)。&lt;/li&gt;
&lt;li&gt;所以只要直接釋放&lt;code&gt;first&lt;/code&gt;的記憶體位置即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;case2&lt;/strong&gt;：若Linked list中沒有要刪除的node，見圖四(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若想要刪除&lt;span class="math"&gt;\(8\)&lt;/span&gt;，但是Linked list(&lt;span class="math"&gt;\(7\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(3\)&lt;/span&gt;-&amp;gt;&lt;span class="math"&gt;\(14\)&lt;/span&gt;)沒有&lt;span class="math"&gt;\(8\)&lt;/span&gt;，那麼在&lt;strong&gt;Traversal&lt;/strong&gt;後，&lt;code&gt;ListNode *current&lt;/code&gt;會一路走到Linked list的結尾，也就是&lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;若Linked list本來就是空的，那麼建立的&lt;code&gt;ListNode *current = first&lt;/code&gt;，&lt;code&gt;current&lt;/code&gt;也會指向&lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;以上這兩種情況，直接結束&lt;code&gt;Delete()&lt;/code&gt;函式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      
             &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// Traversal&lt;/span&gt;
        &lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                       &lt;span class="c1"&gt;// 如果current指向NULL&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 或是current-&amp;gt;data == x&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;                                             &lt;span class="c1"&gt;// 即結束while loop&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;             &lt;span class="c1"&gt;// list沒有要刪的node, 或是list為empty&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;There is no &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; in list.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// list只有一個node&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               
        &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 當指標被delete後, 將其指向NULL, &lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 可以避免不必要bug&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                     
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                          &lt;span class="c1"&gt;// 其餘情況, previous不為NULL&lt;/span&gt;
        &lt;span class="n"&gt;previous&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="clear"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;函式：Clear&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Clear()&lt;/code&gt;的功能是清除整個Linked list。方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;從Linked list的「第一個node」&lt;code&gt;first&lt;/code&gt;開始，進行&lt;strong&gt;Traversal&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;利用&lt;code&gt;first=first-&amp;gt;next&lt;/code&gt;即可不斷移動&lt;code&gt;first&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立一個&lt;code&gt;ListNode *current&lt;/code&gt;記錄「要刪除的node」之記憶體位置。&lt;/li&gt;
&lt;li&gt;重複上述步驟，直到&lt;code&gt;first&lt;/code&gt;指向Linked list的尾巴&lt;code&gt;NULL&lt;/code&gt;為止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;見圖五(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原先&lt;code&gt;first&lt;/code&gt;記錄的是node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;建立&lt;code&gt;ListNode *current&lt;/code&gt;記錄&lt;code&gt;first&lt;/code&gt;，也就是node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;first&lt;/code&gt;移動到node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;刪除&lt;code&gt;current&lt;/code&gt;指向的node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此，便把node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)從Linked list移除。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖五(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前&lt;code&gt;first&lt;/code&gt;記錄的是node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;建立&lt;code&gt;ListNode *current&lt;/code&gt;記錄&lt;code&gt;first&lt;/code&gt;，也就是node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;first&lt;/code&gt;移動到node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;刪除&lt;code&gt;current&lt;/code&gt;指向的node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此，便把node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)從Linked list移除。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖五(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前&lt;code&gt;first&lt;/code&gt;記錄的是node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;建立&lt;code&gt;ListNode *current&lt;/code&gt;記錄&lt;code&gt;first&lt;/code&gt;，也就是node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;first&lt;/code&gt;移動到&lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;刪除&lt;code&gt;current&lt;/code&gt;指向的node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣便把Linked list的node刪除完畢。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Clear&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;            &lt;span class="c1"&gt;// Traversal&lt;/span&gt;
        &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="reverse"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;函式：Reverse&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Reverse()&lt;/code&gt;的功能是反轉Linked list，以圖六(a)的Linked list為例，經過&lt;code&gt;Reverse()&lt;/code&gt;之後，預期得到圖六(b)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f23.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;要倒轉Linked list，其實就是把每個node的&lt;strong&gt;pointer&lt;/strong&gt;的方向前後對調，但是因為每個node都只有被Linked list中的「一個node」記得，例如圖六(a)，只有node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)記得node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)的記憶體位置，只有node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)記得node(&lt;span class="math"&gt;\(8\)&lt;/span&gt;)的記憶體位置，所以，如果把node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)的&lt;code&gt;ListNode *next&lt;/code&gt;(原本指向node(&lt;span class="math"&gt;\(8\)&lt;/span&gt;))更新成指向node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)，那麼整個Linked list中，就再也無法存取node(&lt;span class="math"&gt;\(8\)&lt;/span&gt;)。  &lt;/p&gt;
&lt;p&gt;所以在更新任何一個node之&lt;strong&gt;pointer&lt;/strong&gt;之前，除了要知道「新的要指向的node」之記憶體位置，也要記錄「原先記錄的node」之記憶體位置，這裡使用三個指向node的指標，分別為&lt;code&gt;previous&lt;/code&gt;、&lt;code&gt;current&lt;/code&gt;、&lt;code&gt;preceding&lt;/code&gt;，以圖六(c)為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前&lt;code&gt;current&lt;/code&gt;為node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)，其指標&lt;code&gt;current-&amp;gt;next&lt;/code&gt;指向的是node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;目前&lt;code&gt;previous&lt;/code&gt;為node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)，是&lt;code&gt;current-&amp;gt;next&lt;/code&gt;最後要指向的記憶體位置。&lt;/li&gt;
&lt;li&gt;目前&lt;code&gt;preceding&lt;/code&gt;為node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)，避免&lt;code&gt;current-&amp;gt;next&lt;/code&gt;更新成node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)後，再也找不到node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f24.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;有了這三個指標後，要執行的步驟只有兩個：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;將&lt;code&gt;current-&amp;gt;next&lt;/code&gt;從原本指向&lt;code&gt;preceding&lt;/code&gt;更新成指向&lt;code&gt;previous&lt;/code&gt;，如圖六(c)中圖。&lt;ul&gt;
&lt;li&gt;執行&lt;code&gt;current-&amp;gt;next=previous&lt;/code&gt;，就把node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)的指向node(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把三個指標「按照順序」往前移動，然後進行下一個node之&lt;strong&gt;pointer&lt;/strong&gt;調整，如圖六(c)下圖。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;previous=current&lt;/code&gt;，將&lt;code&gt;previous&lt;/code&gt;移動到node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;current=preceding&lt;/code&gt;，將&lt;code&gt;current&lt;/code&gt;移動到node(&lt;span class="math"&gt;\(14\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preceding=preceding-&amp;gt;next&lt;/code&gt;，將&lt;code&gt;preceding&lt;/code&gt;移動到node(&lt;span class="math"&gt;\(8\)&lt;/span&gt;)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重複上述步驟，直到&lt;code&gt;preceding&lt;/code&gt;更新成&lt;code&gt;NULL&lt;/code&gt;，調整Linked list的&lt;code&gt;first&lt;/code&gt;所指向的記憶體位置，即完成Linked list之反轉。&lt;/p&gt;
&lt;p&gt;完整圖示見圖六(d)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Insert_Delete_Reverse/f25.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Reverse&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// list is empty or list has only one node&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
             &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
             &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;preceding&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;preceding&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 把current-&amp;gt;next轉向&lt;/span&gt;
        &lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// previous往前挪&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;preceding&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// current往前挪&lt;/span&gt;
        &lt;span class="n"&gt;preceding&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;preceding&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// preceding往前挪&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;                                  &lt;span class="c1"&gt;// preceding更新成NULL即跳出while loop&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;previous&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 此時current位於最後一個node, 將current-&amp;gt;next轉向&lt;/span&gt;
    &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// 更新first為current&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="test"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;測試&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;測試前面所介紹的各個函式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;LinkedList&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 建立LinkedList的object&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// 目前list是空的&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// list是空的, 沒有4&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// list: 5&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// list: 5 3&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push_front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// list: 9 5 3&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// 印出: 9 5 3&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// list: 9 3&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// list: 9 3 4&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Push_front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// list: 8 9 3 4&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// 印出: 8 9 3 4&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Reverse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="c1"&gt;// list: 4 3 9 8&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// 印出: 4 3 9 8&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// 清空list&lt;/span&gt;
    &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// 印出: List is empty.&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;There&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; 
&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; 
&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; 
&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是在&lt;strong&gt;Linked List&lt;/strong&gt;中新增資料、刪除資料與反轉Linked list的方法介紹。  &lt;/p&gt;
&lt;p&gt;程式的實作方式根據&lt;code&gt;class LinkedList&lt;/code&gt;的建立方式會有所不同，不過使用&lt;strong&gt;pointer&lt;/strong&gt;的邏輯應該是大同小異的。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch10&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emn178.pixnet.net/blog/post/93557502-%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97%28linked-list%29"&gt;小殘的程式光廊：連結串列(Linked List)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Linked List系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Linked List"></category></entry><entry><title>Linked List: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html" rel="alternate"></link><updated>2016-04-17T21:51:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-17:SecondRound/linked-list-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;要了解Linked list，一定要先看懂&lt;strong&gt;pointer(指標)&lt;/strong&gt;，建議讀者可以先閱讀以下連結內容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://openhome.cc/Gossip/CppGossip/Pointer.html"&gt;語言技術：C++ Gossip：指標與記憶體位址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://openhome.cc/Gossip/CppGossip/newDelete.html"&gt;語言技術：C++ Gossip：new 運算子與 delete 運算子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章介紹的是最基本的&lt;strong&gt;Singly linked list&lt;/strong&gt;，其餘還有&lt;strong&gt;Doubly linked list&lt;/strong&gt;、&lt;strong&gt;Circular linked list&lt;/strong&gt;，請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Doubly_linked_list"&gt;Wikipedia：Doubly linked list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm"&gt;Tutorials Point：Data Structure - Circular Linked List&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#intro"&gt;簡介：Linked list&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#repre"&gt;以兩個class(類別)表示Linked list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#comp"&gt;比較：Array與Linked list&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#array"&gt;Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ll"&gt;Linked list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Linked list系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="intro"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;簡介：Linked list&lt;/h2&gt;
&lt;p&gt;Linked list(連結串列)是一種常見的資料結構，其使用&lt;strong&gt;node(節點)&lt;/strong&gt;來記錄、表示、儲存資料(data)，並利用每個node中的&lt;strong&gt;pointer&lt;/strong&gt;指向下一個node，藉此將多個node串連起來，形成Linked list，並以&lt;code&gt;NULL&lt;/code&gt;來代表Linked list的終點，見圖一(a)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Intro/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若實際打開每個node的內部，至少會包含(1)&lt;strong&gt;data&lt;/strong&gt;來代表資料，與(2)&lt;strong&gt;pointer&lt;/strong&gt;指向下一個node，見圖一(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node1：&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;int&lt;/code&gt;的data，記錄正整數&lt;span class="math"&gt;\(7\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;本身的記憶體位置為&lt;code&gt;0x1001042f0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;以「node之&lt;strong&gt;pointer&lt;/strong&gt;」，記錄(指向)下一個node之記憶體位置(&lt;code&gt;0x100104300&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Node2：&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;int&lt;/code&gt;的data，記錄正整數&lt;span class="math"&gt;\(3\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;本身的記憶體位置為&lt;code&gt;0x100104300&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;由於在Node1中的「node之&lt;strong&gt;pointer&lt;/strong&gt;」指向了Node2之記憶體位置，因此，便能夠經由Node1「找到」Node2。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以「node之&lt;strong&gt;pointer&lt;/strong&gt;」，記錄(指向)下一個node之記憶體位置(&lt;code&gt;0x100104310&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Node3：&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;int&lt;/code&gt;的data，記錄正整數&lt;span class="math"&gt;\(14\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;本身的記憶體位置為&lt;code&gt;0x100104310&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;由於在Node2中的「node之&lt;strong&gt;pointer&lt;/strong&gt;」指向了Node3之記憶體位置，因此，便能夠經由Node2「找到」Node3。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以「node之&lt;strong&gt;pointer&lt;/strong&gt;」，記錄(指向)&lt;code&gt;NULL&lt;/code&gt;，表示Linked list的最後一個node。    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常在面對一個Linked list時，能夠公開存取(access)的node只有「第一個node」，以&lt;code&gt;ListNode *first&lt;/code&gt;表示，不過因為node中有&lt;strong&gt;pointer&lt;/strong&gt;記錄下一個node的記憶體位置，便能夠讀取下一個node的&lt;strong&gt;data&lt;/strong&gt;與&lt;strong&gt;pointer&lt;/strong&gt;，換句話說，有了node中的&lt;strong&gt;pointer&lt;/strong&gt;就可以在Linked list中「移動(&lt;strong&gt;traversal&lt;/strong&gt;)」，更進一步，便能進行諸如「新增節點」、「刪除節點」、「印出Linked list」等等的資料處理，這些函式將在後續文章一一介紹。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="repre"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;以兩個class(類別)表示Linked list&lt;/h3&gt;
&lt;p&gt;若以C++的&lt;strong&gt;class(類別)&lt;/strong&gt;來實作Linked list，可以利用兩個class，使得node的資料不會被任意更動(也就是封裝(Encapsulation)的概念)。 &lt;br /&gt;
使用&lt;code&gt;struct&lt;/code&gt;來代表node也是常見的做法，差別在於，&lt;code&gt;struct&lt;/code&gt;的資料成員(data member)一定是&lt;strong&gt;公開的(public)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class ListNode&lt;/code&gt;的private data有兩項，一項代表著資料項目(在此以&lt;code&gt;int&lt;/code&gt;示範)，一項是「指向型別(type)為ListNode之指標」，以&lt;code&gt;ListNode *next&lt;/code&gt;表示，用來記錄「下一個node」的記憶體位置。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;class LinkedList&lt;/code&gt;的private data中，最基本一定會有代表「第一個node」的&lt;code&gt;ListNode *first&lt;/code&gt;，其餘資料項目可以視情況增加，像是&lt;code&gt;int size&lt;/code&gt;用來記錄Linked list的長度等等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 為了將class LinkedList設成class ListNode的friend,&lt;/span&gt;
                     &lt;span class="c1"&gt;// 需要先宣告&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// int size;                // size是用來記錄Linked list的長度, 非必要&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// list的第一個node&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// 印出list的所有資料&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Push_front&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 在list的開頭新增node&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 在list的尾巴新增node&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// 刪除list中的 int x&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// 把整串list刪除&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Reverse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// 將list反轉: 7-&amp;gt;3-&amp;gt;14 =&amp;gt; 14-&amp;gt;3-&amp;gt;7&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="comp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;比較：Array與Linked list&lt;/h2&gt;
&lt;p&gt;Array(矩陣)也是常見的用來記錄一連串「具有相同形態的資料」的資料結構，以下便列舉Array與Linked list各自的優缺點，以及各自適合的問題情境。&lt;/p&gt;
&lt;p&gt;&lt;a name="array"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;h3&gt;Array&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;優點&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;random access：只要利用&lt;strong&gt;index&lt;/strong&gt;即可在O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)時間對Array的資料做存取。&lt;/li&gt;
&lt;li&gt;較Linked list為節省記憶體空間：因為Linked list需要多一個&lt;strong&gt;pointer&lt;/strong&gt;來記錄下一個node的記憶體位置。&lt;ul&gt;
&lt;li&gt;假設node之&lt;strong&gt;data&lt;/strong&gt;項目為&lt;span class="math"&gt;\(1\)&lt;/span&gt;byte的&lt;code&gt;char&lt;/code&gt;，但是&lt;strong&gt;pointer&lt;/strong&gt;項目卻要&lt;span class="math"&gt;\(4\)&lt;/span&gt;bytes，這樣的資料結構就多花了4倍的記憶體空間在與真正要處理的資料無關的部分上，是個沒有效率的做法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺點&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增/刪除資料很麻煩：若要在第一個位置新增資料，就需要O(&lt;span class="math"&gt;\(N\)&lt;/span&gt;)時間把矩陣中所有元素往後移動。同理，若要刪除第一個位置的資料，也需要O(&lt;span class="math"&gt;\(N\)&lt;/span&gt;)時間把矩陣中剩餘的元素往前移動。&lt;/li&gt;
&lt;li&gt;若資料數量時常在改變，要時常調整矩陣的大小，會花費O(&lt;span class="math"&gt;\(N\)&lt;/span&gt;)的時間在搬動資料(把資料從舊的矩陣移動到新的矩陣)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;適用時機&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希望能夠快速存取資料。&lt;/li&gt;
&lt;li&gt;已知欲處理的資料數量，便能確認矩陣的大小。&lt;/li&gt;
&lt;li&gt;要求記憶體空間的使用越少越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="ll"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;h3&gt;Linked list&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;優點&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增/刪除資料較Array簡單，只要對O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)個node(所有與欲新增/刪除的node有&lt;strong&gt;pointer&lt;/strong&gt;相連的node)調整&lt;strong&gt;pointer&lt;/strong&gt;即可，不需要如同Array般搬動其餘元素。&lt;ul&gt;
&lt;li&gt;若是在Linked list的「開頭」新增node，只要O(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;若要刪除特定node，或者在特定位置新增node，有可能需要先執行O(&lt;span class="math"&gt;\(N\)&lt;/span&gt;)的「搜尋」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Linked list的資料數量可以是動態的，不像Array會有&lt;strong&gt;resize&lt;/strong&gt;的問題。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺點&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為Linked list沒有&lt;strong&gt;index&lt;/strong&gt;，若要找到特定node，需要從頭(&lt;code&gt;ListNode *first&lt;/code&gt;)開始找起，搜尋的時間複雜度為O(&lt;span class="math"&gt;\(N\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;需要額外的記憶體空間來儲存&lt;strong&gt;pointer&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;適用時機&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無法預期資料數量時，使用Linked list就沒有&lt;strong&gt;resize&lt;/strong&gt;的問題。&lt;/li&gt;
&lt;li&gt;需要頻繁地新增/刪除資料時。&lt;/li&gt;
&lt;li&gt;不需要快速查詢資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是&lt;strong&gt;Linked list&lt;/strong&gt;的初步介紹。&lt;br /&gt;
接下來的文章將逐一介紹&lt;code&gt;class LinkedList&lt;/code&gt;的成員函式(member function)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch10&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/166884/array-versus-linked-list"&gt;Stack Overflow：Array versus linked-list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/393556/when-to-use-a-linked-list-over-an-array-array-list"&gt;Stack Overflow：When to use a linked list over an array/array list?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/linked-list-vs-array/"&gt;GeeksforGeeks：Linked List vs Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://openhome.cc/Gossip/CppGossip/Pointer.html"&gt;語言技術：C++ Gossip：指標與記憶體位址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://openhome.cc/Gossip/CppGossip/newDelete.html"&gt;語言技術：C++ Gossip：new 運算子與 delete 運算子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Doubly_linked_list"&gt;Wikipedia：Doubly linked list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tutorialspoint.com/data_structures_algorithms/circular_linked_list_algorithm.htm"&gt;Tutorials Point：Data Structure - Circular Linked List&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Linked List系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category><category term="Linked List"></category><category term="Pointer"></category><category term="Array"></category></entry><entry><title>Comparison Sort: Merge Sort(合併排序法)</title><link href="http://alrightchiu.github.io/SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html" rel="alternate"></link><updated>2016-04-13T17:46:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-13:SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;Sorting(排序)是基本的資料處理，舉例來說，進入圖書館的查詢系統，不論是想按照「出版日期」或是「相關程度」找書，都會得到「排序過」的結果。&lt;/p&gt;
&lt;p&gt;常見的&lt;strong&gt;Comparison Sort&lt;/strong&gt;及其時間複雜度如表一，假設問題有&lt;span class="math"&gt;\(N\)&lt;/span&gt;筆資料：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Quick Sort &amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Merge Sort &amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Heap Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Insertion Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Selection Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;best case&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;average case &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;worst case&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：五種排序法之時間複雜度比較&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;本篇文章將介紹&lt;strong&gt;Merge Sort(合併排序法)&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#ms"&gt;Merge Sort(合併排序法)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#merge"&gt;函式：Merge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Comparison Sort系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ms"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Merge Sort(合併排序法)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Merge Sort&lt;/strong&gt;屬於&lt;strong&gt;Divide and Conquer&lt;/strong&gt;演算法，把問題先拆解(divide)成子問題，並在逐一處理子問題後，將子問題的結果合併(conquer)，如此便解決了原先的問題。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖一為例，要把數列{&lt;span class="math"&gt;\(5,3,8,6,2,7,1,4\)&lt;/span&gt;}排序成{&lt;span class="math"&gt;\(1,2,3,4,5,6,7,8\)&lt;/span&gt;}，&lt;strong&gt;Merge Sort&lt;/strong&gt;的方法為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Divide&lt;/strong&gt;：把數列「對半拆解」成兩個小數列。&lt;ul&gt;
&lt;li&gt;先把{&lt;span class="math"&gt;\(5,3,8,6,2,7,1,4\)&lt;/span&gt;}分成{&lt;span class="math"&gt;\(5,3,8,6\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(2,7,1,4\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;再把{&lt;span class="math"&gt;\(5,3,8,6\)&lt;/span&gt;}分解成{&lt;span class="math"&gt;\(5,3\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(8,6\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;{&lt;span class="math"&gt;\(2,7,1,4\)&lt;/span&gt;}分解成{&lt;span class="math"&gt;\(2,7\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(1,4\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;依此類推，直到每個數列剩下一個元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conquer&lt;/strong&gt;：按照「由小到大」的順序，「合併」小數列。&lt;ul&gt;
&lt;li&gt;考慮數列{&lt;span class="math"&gt;\(5\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(3\)&lt;/span&gt;}，比較大小後，合併成數列{&lt;span class="math"&gt;\(3,5\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;考慮數列{&lt;span class="math"&gt;\(8\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(6\)&lt;/span&gt;}，比較大小後，合併成數列{&lt;span class="math"&gt;\(6,8\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;考慮數列{&lt;span class="math"&gt;\(3,5\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(6,8\)&lt;/span&gt;}，比較大小後，合併成數列{&lt;span class="math"&gt;\(3,5,6,8\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;依此類推，最後，考慮數列{&lt;span class="math"&gt;\(3,5,6,8\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(1,2,4,7\)&lt;/span&gt;}，比較大小後，合併成數列{&lt;span class="math"&gt;\(1,2,3,4,5,6,7,8\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即完成&lt;strong&gt;Merge Sort&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由圖一可以看出，在排序過程，需要先把{&lt;span class="math"&gt;\(5\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(3\)&lt;/span&gt;}「記下來」，才能用來比較、合併出{&lt;span class="math"&gt;\(3,5\)&lt;/span&gt;}，需要先把{&lt;span class="math"&gt;\(3,5\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(6,8\)&lt;/span&gt;}「記下來」，才能用來比較、合併出{&lt;span class="math"&gt;\(3,5,6,8\)&lt;/span&gt;}，因此，最直覺的方式，便是利用&lt;strong&gt;遞迴(recursion)&lt;/strong&gt;來「記錄先前的狀態」：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;MergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                                         &lt;span class="c1"&gt;// front與end為矩陣範圍&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                   &lt;span class="c1"&gt;// 表示目前的矩陣範圍是有效的&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// mid即是將矩陣對半分的index&lt;/span&gt;
        &lt;span class="n"&gt;MergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 繼續divide矩陣的前半段subarray&lt;/span&gt;
        &lt;span class="n"&gt;MergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 繼續divide矩陣的後半段subarray&lt;/span&gt;
        &lt;span class="n"&gt;Merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 將兩個subarray做比較, 並合併出排序後的矩陣&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以，關鍵就是&lt;code&gt;Merge()&lt;/code&gt;的方法。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="merge"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：Merge&lt;/h3&gt;
&lt;p&gt;以圖一中，合併數列{&lt;span class="math"&gt;\(2,7\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(1,4\)&lt;/span&gt;}為例，見圖二(a)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Merge()&lt;/code&gt;的大前提：若要由小數列合併出大數列，那麼各自的小數列必須「已經排好序」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如數列{&lt;span class="math"&gt;\(2,7\)&lt;/span&gt;}，已經「由小到大」排好序(&lt;span class="math"&gt;\(2\)&lt;/span&gt;在&lt;span class="math"&gt;\(7\)&lt;/span&gt;前面)，數列{&lt;span class="math"&gt;\(1,4\)&lt;/span&gt;}也已經排好序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Merge()&lt;/code&gt;的詳細步驟如下，見圖二(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立兩個新的矩陣(稱為&lt;code&gt;LeftSub[]&lt;/code&gt;與&lt;code&gt;RightSub[]&lt;/code&gt;)，分別記錄數列{&lt;span class="math"&gt;\(2,7\)&lt;/span&gt;}與{&lt;span class="math"&gt;\(1,4\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;並在兩個新矩陣的最後一個位置，新增一個值為「無限大」的元素。&lt;ul&gt;
&lt;li&gt;這個「無限大」的元素是為了「比較」用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著便開始「比較兩個矩陣的元素」，挑選「較小的元素」放進原矩陣&lt;code&gt;Array&lt;/code&gt;中。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前要更新的是介於&lt;code&gt;Array[4]&lt;/code&gt;~&lt;code&gt;Array[7]&lt;/code&gt;的矩陣元素。&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;int front&lt;/code&gt;代表&lt;span class="math"&gt;\(4\)&lt;/span&gt;，以&lt;code&gt;int end&lt;/code&gt;代表&lt;span class="math"&gt;\(7\)&lt;/span&gt;，表示此範圍的頭尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;首先，替&lt;code&gt;LeftSub[]&lt;/code&gt;與&lt;code&gt;RightSub[]&lt;/code&gt;設立個別的index，稱為&lt;code&gt;int idxLeft=0&lt;/code&gt;與&lt;code&gt;int idxRight=0&lt;/code&gt;，見圖二(c)的紅色箭頭。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著比較&lt;code&gt;LeftSub[idxLeft=0]&lt;/code&gt;與&lt;code&gt;RightSub[idxRight=0]&lt;/code&gt;，發現後者較小，便將&lt;code&gt;Array[front=4]&lt;/code&gt;更新成&lt;code&gt;RightSub[idxRight=0]&lt;/code&gt;的&lt;span class="math"&gt;\(1\)&lt;/span&gt;，見圖二(d)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由於目前的&lt;code&gt;RightSub[idxRight=0]&lt;/code&gt;已經放進&lt;code&gt;Array&lt;/code&gt;裡，表示該元素&lt;span class="math"&gt;\(1\)&lt;/span&gt;已經被調整完畢，於是便把&lt;code&gt;idxRight&lt;/code&gt;往後移，繼續調整&lt;code&gt;RightSub[]&lt;/code&gt;的其餘元素，見圖二(e)左。&lt;/p&gt;
&lt;p&gt;以上便完成一次「比較兩個小矩陣之元素大小」並「更新原矩陣元素」之過程。  &lt;/p&gt;
&lt;p&gt;重複上述步驟，繼續更新&lt;code&gt;Array[front+1]&lt;/code&gt;的矩陣元素值，直到&lt;code&gt;Array[end=7]&lt;/code&gt;，即可完成&lt;code&gt;Array[4]&lt;/code&gt;~&lt;code&gt;Array[7]&lt;/code&gt;的排序，見圖二(e)至圖二(g)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(f)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;此時，&lt;code&gt;idxRight&lt;/code&gt;移動到&lt;span class="math"&gt;\(2\)&lt;/span&gt;，而&lt;code&gt;RightSub[2]&lt;/code&gt;為「無限大」，如此一來便表示，&lt;code&gt;RightSub[]&lt;/code&gt;裡的元素都已經成功地排序進&lt;code&gt;Array[]&lt;/code&gt;裡。&lt;br /&gt;
接下來在比較&lt;code&gt;LeftSub[]&lt;/code&gt;與&lt;code&gt;RightSub[]&lt;/code&gt;時，一定會選擇&lt;code&gt;LeftSub[]&lt;/code&gt;的元素放進&lt;code&gt;Array[]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(g)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;到目前為止，已經將&lt;code&gt;Array[4]&lt;/code&gt;~&lt;code&gt;Array[7]&lt;/code&gt;排序完成。&lt;br /&gt;
只要再將其與「排好序的」&lt;code&gt;Array[0]&lt;/code&gt;~&lt;code&gt;Array[3]&lt;/code&gt;進行「比較、合併」，即可完成&lt;strong&gt;Merge Sort&lt;/strong&gt;，見圖二(h)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/MergeSort/merge.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(h)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;範例程式碼包含幾個部分：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MergeSort()&lt;/code&gt;：以遞迴形式對數列進行&lt;strong&gt;Divide and Conquer&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Merge()&lt;/code&gt;：合併數列的主要函式，其中使用了&lt;code&gt;std::vector&lt;/code&gt;的成員函式(member function)：&lt;strong&gt;constructor&lt;/strong&gt;與&lt;code&gt;insert()&lt;/code&gt;，來創造如圖二(b)的&lt;code&gt;LeftSub[]&lt;/code&gt;與&lt;code&gt;RightSub[]&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;關於&lt;code&gt;std::vector&lt;/code&gt;，請參考：&lt;a href="http://www.cplusplus.com/reference/vector/vector/"&gt;Cplusplus：std::vector&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;，建立矩陣，並執行&lt;code&gt;MergeSort()&lt;/code&gt;，驗證結果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="c1"&gt;// 利用 std::vector 的constructor, &lt;/span&gt;
    &lt;span class="c1"&gt;// 把array[front]~array[mid]放進 LeftSub[]&lt;/span&gt;
    &lt;span class="c1"&gt;// 把array[mid+1]~array[end]放進 RightSub[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;LeftSub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                     &lt;span class="n"&gt;RightSub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;LeftSub&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LeftSub&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;Max&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 在LeftSub[]尾端加入值為 Max 的元素&lt;/span&gt;
    &lt;span class="n"&gt;RightSub&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RightSub&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;Max&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 在RightSub[]尾端加入值為 Max 的元素&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idxLeft&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idxRight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LeftSub&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idxLeft&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;RightSub&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idxRight&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LeftSub&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idxLeft&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;idxLeft&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RightSub&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idxRight&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;idxRight&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;MergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                                         &lt;span class="c1"&gt;// front與end為矩陣範圍&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                   &lt;span class="c1"&gt;// 表示目前的矩陣範圍是有效的&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// mid即是將矩陣對半分的index&lt;/span&gt;
        &lt;span class="n"&gt;MergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 繼續divide矩陣的前半段subarray&lt;/span&gt;
        &lt;span class="n"&gt;MergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 繼續divide矩陣的後半段subarray&lt;/span&gt;
        &lt;span class="n"&gt;Merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 將兩個subarray做比較, 並合併出排序後的矩陣&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;original:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;MergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sorted:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;original&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="nl"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是&lt;strong&gt;Merge Sort&lt;/strong&gt;之介紹。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch2&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emn178.pixnet.net/blog/post/87965707-%E5%90%88%E4%BD%B5%E6%8E%92%E5%BA%8F%E6%B3%95%28merge-sort%29"&gt;小殘的程式光廊：合併排序法(Merge Sort)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://program-lover.blogspot.tw/2008/10/mergesort.html"&gt;Infinite Loop：【演算】合併排序法 - Mergesort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cplusplus.com/reference/vector/vector/"&gt;Cplusplus：std::vector&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Comparison Sort系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-insertion-sortcha-ru-pai-xu-fa.html"&gt;Comparison Sort: Insertion Sort(插入排序法)&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-quick-sortkuai-su-pai-xu-fa.html"&gt;Comparison Sort: Quick Sort(快速排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-heap-sortdui-ji-pai-xu-fa.html"&gt;Comparison Sort: Heap Sort(堆積排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html"&gt;Comparison Sort: Merge Sort(合併排序法)&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Comparison Sort"></category><category term="Sort"></category><category term="Divide and Conquer"></category></entry><entry><title>Comparison Sort: Heap Sort(堆積排序法)</title><link href="http://alrightchiu.github.io/SecondRound/comparison-sort-heap-sortdui-ji-pai-xu-fa.html" rel="alternate"></link><updated>2016-04-10T16:30:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-04-10:SecondRound/comparison-sort-heap-sortdui-ji-pai-xu-fa.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;Sorting(排序)是基本的資料處理，舉例來說，進入圖書館的查詢系統，不論是想按照「出版日期」或是「相關程度」找書，都會得到「排序過」的結果。&lt;/p&gt;
&lt;p&gt;常見的&lt;strong&gt;Comparison Sort&lt;/strong&gt;及其時間複雜度如表一，假設問題有&lt;span class="math"&gt;\(N\)&lt;/span&gt;筆資料：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Quick Sort &amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Merge Sort &amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Heap Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Insertion Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Selection Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;best case&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;average case &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;worst case&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：五種排序法之時間複雜度比較&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
&lt;strong&gt;Binary Heap&lt;/strong&gt;可以分為Min Heap與Max Heap兩種。兩者用在排序上，僅僅是順序「由大到小」和「由小到大」的差別。  &lt;/p&gt;
&lt;p&gt;本篇文章將介紹以Max Heap實現&lt;strong&gt;Heap Sort(堆積排序法)&lt;/strong&gt;的方法。&lt;/p&gt;
&lt;p&gt;有關Min Heap的內容，請參考&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bh"&gt;Binary Heap(二元堆積)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#heapify"&gt;函式：MaxHeapify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#build"&gt;函式：BuildMaxHeap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#hs"&gt;Heap Sort(堆積排序法)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Comparison Sort系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bh"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Binary Heap(二元堆積)&lt;/h2&gt;
&lt;p&gt;Binary Heap有兩項基本特徵：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特徵一&lt;/strong&gt;：Binary Heap之結構可以視作&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖一(a)，數值&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(9\)&lt;/span&gt;，一共有9個元素，按照&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;之順序規則，填滿位置&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(9\)&lt;/span&gt;，以index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)~index(&lt;span class="math"&gt;\(9\)&lt;/span&gt;)表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣的優點是方便尋找「parent-child」之關係，以index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)的node為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其&lt;strong&gt;left child&lt;/strong&gt;必定位在&lt;strong&gt;index(&lt;span class="math"&gt;\(2i\)&lt;/span&gt;)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;其&lt;strong&gt;right child&lt;/strong&gt;必定位在&lt;strong&gt;index(&lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;其&lt;strong&gt;parent&lt;/strong&gt;必定位在&lt;strong&gt;index(&lt;span class="math"&gt;\(\lfloor i/2 \rfloor\)&lt;/span&gt;)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖一(a)中位於index(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)之node(&lt;span class="math"&gt;\(8\)&lt;/span&gt;)為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其&lt;strong&gt;left child&lt;/strong&gt;為index(&lt;span class="math"&gt;\(6\)&lt;/span&gt;)之node(&lt;span class="math"&gt;\(2\)&lt;/span&gt;)；&lt;/li&gt;
&lt;li&gt;其&lt;strong&gt;right child&lt;/strong&gt;為index(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)之node(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)；&lt;/li&gt;
&lt;li&gt;其&lt;strong&gt;parent&lt;/strong&gt;為index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)之node(&lt;span class="math"&gt;\(9\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：黑色數字是index，藍色數字是value。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特徵二&lt;/strong&gt;：若將位於index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)之node視為subtree之&lt;strong&gt;root&lt;/strong&gt;，那麼，可將此Binary Heap分為兩類：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Max Heap&lt;/strong&gt;：在每一個subtree中，&lt;strong&gt;root&lt;/strong&gt;之「數值」要比兩個&lt;strong&gt;child&lt;/strong&gt;之「數值」還要大，見圖一(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(value(i)&amp;gt;value(2i)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(value(i)&amp;gt;value(2i+1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Min Heap&lt;/strong&gt;：在每一個subtree中，&lt;strong&gt;root&lt;/strong&gt;之「數值」要比兩個&lt;strong&gt;child&lt;/strong&gt;之「數值」還要小，見圖一(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(value(i)&amp;lt;value(2i)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(value(i)&amp;lt;value(2i+1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;特別注意：在同一個subtree裡，&lt;strong&gt;leftchild&lt;/strong&gt;(index(&lt;span class="math"&gt;\(2i\)&lt;/span&gt;))與&lt;strong&gt;rightchild&lt;/strong&gt;(index(&lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;))的「數值」大小順序不重要，只要和&lt;strong&gt;root&lt;/strong&gt;(index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;))比較即可。&lt;br /&gt;
這也是Binary Heap與Binary Search Tree其中一項區別。&lt;/p&gt;
&lt;p&gt;要滿足Binary Heap特有的「parent-child」之關係，只要讓矩陣中index(&lt;span class="math"&gt;\(0\)&lt;/span&gt;)的位置閒置，從index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)開始存放資料，即可使用矩陣(array)來表示Binary Heap。&lt;/p&gt;
&lt;p&gt;接著介紹兩個函式，把任意矩陣轉換成Max Heap。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="heapify"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：MaxHeapify&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MaxHeapify()&lt;/code&gt;的功能，是要「由上而下」地，以Max Heap的規則(&lt;strong&gt;root&lt;/strong&gt;的數值「大於」兩個&lt;strong&gt;child&lt;/strong&gt;的數值)，調整矩陣。&lt;/p&gt;
&lt;p&gt;以圖二(a)為例，觀察subtree「index(&lt;span class="math"&gt;\(2\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(4\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(5\)&lt;/span&gt;)」之「數值」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root：index(&lt;span class="math"&gt;\(i=2\)&lt;/span&gt;)為&lt;span class="math"&gt;\(1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;leftchild：index(&lt;span class="math"&gt;\(2i=4\)&lt;/span&gt;)為&lt;span class="math"&gt;\(9\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;rightchild：index(&lt;span class="math"&gt;\(2i+1=5\)&lt;/span&gt;)為&lt;span class="math"&gt;\(4\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不符合Max Heap規則，所以要想辦法把這三個數值中的「最大值」，調整到index(&lt;span class="math"&gt;\(i=2\)&lt;/span&gt;)，也就是這棵subtree的&lt;strong&gt;root&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到這三者的最大值，並以&lt;code&gt;int largest&lt;/code&gt;記錄該最大值的index。&lt;ul&gt;
&lt;li&gt;圖二(a)中，把&lt;code&gt;largest&lt;/code&gt;記錄為index(&lt;span class="math"&gt;\(4\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;將index(root)與index(largest)這兩個node互換位置，如此一來，當前的subtree必定能滿足Max Heap規則。&lt;ul&gt;
&lt;li&gt;圖二(b)中，將index(&lt;span class="math"&gt;\(2\)&lt;/span&gt;)與index(&lt;span class="math"&gt;\(4\)&lt;/span&gt;)的node互換。&lt;/li&gt;
&lt;li&gt;subtree「index(&lt;span class="math"&gt;\(2\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(4\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(5\)&lt;/span&gt;)」的數值分別為「&lt;span class="math"&gt;\(9-1-4\)&lt;/span&gt;」，符合Max Heap。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;繼續以index(largest)當作新的subtree的root，檢查新的subtree是否符合Max Heap規則。&lt;ul&gt;
&lt;li&gt;圖二(b)中，subtree「index(&lt;span class="math"&gt;\(4\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(8\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(9\)&lt;/span&gt;)」再次不滿足Max Heap，便重複上述步驟，得到圖二(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如此一來，有被&lt;code&gt;MaxHeapify()&lt;/code&gt;檢查過的subtree，都會符合Max Heap規則。&lt;/p&gt;
&lt;p&gt;因此，只要對所有「具有child的node」檢查一次&lt;code&gt;MaxHeapify()&lt;/code&gt;，便能夠把一個任意矩陣調整成Max Heap，這就是下一個函式&lt;code&gt;BuildMaxHeap()&lt;/code&gt;的功能。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="build"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：BuildMaxHeap&lt;/h3&gt;
&lt;p&gt;有了&lt;code&gt;MaxHeapify()&lt;/code&gt;之後，只要對所有「具有child的node」進行&lt;code&gt;MaxHeapify()&lt;/code&gt;，也就是位於index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)&lt;span class="math"&gt;\(~\)&lt;/span&gt;index(&lt;span class="math"&gt;\(\lfloor N/2 \rfloor\)&lt;/span&gt;)的node，就能夠將任意矩陣調整成Max Heap。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖三為例，Binary Heap共有&lt;span class="math"&gt;\(9\)&lt;/span&gt;個node，便從index(&lt;span class="math"&gt;\(4\)&lt;/span&gt;)往index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)，逐一對node進行&lt;code&gt;MaxHeapify()&lt;/code&gt;，即可得到Max Heap。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;為什麼只要對「具有child的node」調整呢？&lt;br /&gt;
因為Max Heap的規則是「比較root的數值與child的數值」，如果是沒有child的node(屬於&lt;strong&gt;leaf node&lt;/strong&gt;)，就一定不會違反Max Heap的規則。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/BuildMaxHeap.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="hs"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Heap Sort(堆積排序法)&lt;/h2&gt;
&lt;p&gt;經過&lt;code&gt;BuildMaxHeap()&lt;/code&gt;之後，便能將任意矩陣調整成Max Heap。&lt;/p&gt;
&lt;p&gt;那麼要如何將此Max Heap做排序呢？&lt;/p&gt;
&lt;p&gt;Max Heap的特徵是「第一個node具有最大值」，如果要將資料「由小到大」排序，步驟如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把「第一個node」和「最後一個node」互換位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;假裝heap的「最後一個node」從此消失不見&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;對「第一個node」進行&lt;code&gt;MaxHeapify()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重複以上步驟，從heap的最後一個node開始，一路往上，直到root，便能得到排好序的矩陣。&lt;/p&gt;
&lt;p&gt;以圖四(a)的Max Heap為例，現要將其調整成「由小到大」排好序的矩陣。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;首先，從「最後一個位置」開始，將index(&lt;span class="math"&gt;\(9\)&lt;/span&gt;)的node與index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)的node互換位置，見圖四(b)。&lt;br /&gt;
如此，便把「最大值」的node(&lt;span class="math"&gt;\(9\)&lt;/span&gt;)給放到最後一個位置，以及「不是最大值」的node(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)換到第一個位置。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，最重要的概念就是「假裝最後一個node消失不見」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為此時，heap的「最後一個node」一定是「最大值」的node，也就表示，如果要得到「由小到大」的排序，那麼，此時便已經完成「最大值node」的調整。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同時，目前的index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)的node一定不是「最大值」，所以要利用&lt;code&gt;MaxHeapify()&lt;/code&gt;重新調整「矩陣」，使其符合Max Heap規則。&lt;/p&gt;
&lt;p&gt;又因為「假裝最後一個node消失不見」，所以，接下來要調整的「矩陣」，是「忽略index(&lt;span class="math"&gt;\(9\)&lt;/span&gt;)」的矩陣，因此只要考慮由「index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)~index(&lt;span class="math"&gt;\(8\)&lt;/span&gt;)」所形成的矩陣即可。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;圖四(c)中的&lt;code&gt;size&lt;/code&gt;，即表示&lt;code&gt;MaxHeapify()&lt;/code&gt;要處理的矩陣之&lt;strong&gt;size&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;此次的&lt;code&gt;MaxHeapify()&lt;/code&gt;將會碰到subtree(index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(2\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(3\)&lt;/span&gt;))與subtree(index(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(6\)&lt;/span&gt;)-index(&lt;span class="math"&gt;\(7\)&lt;/span&gt;))。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過圖四(c)的&lt;code&gt;MaxHeapify()&lt;/code&gt;調整，由「index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)~index(&lt;span class="math"&gt;\(8\)&lt;/span&gt;)」形成的矩陣，又再次滿足Max Heap，見圖四(d)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/f20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，再繼續重複上述步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交換「目前考慮的矩陣」的「最後一個位置node」與「第一個node」；&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;MaxHeapify()&lt;/code&gt;調整「目前考慮的矩陣」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;便能得到「由小到大」排好序的矩陣，見圖四(e)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/HeapSort/HeapSort.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(e)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;範例程式碼包含幾個部分：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swap()&lt;/code&gt;：執行「交換node」。因為要實質交換&lt;code&gt;array&lt;/code&gt;中的資料，所以必須使用&lt;strong&gt;reference&lt;/strong&gt;或使&lt;strong&gt;pointer&lt;/strong&gt;作為函式的參數(argument)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MaxHeapify()&lt;/code&gt;：「由上而下」，逐一檢查subtree，使subtree滿足Max Heap規則。函式的參數分別為&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt;：記錄heap的矩陣。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root&lt;/code&gt;：當前的subtree之root的index。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;length&lt;/code&gt;：這是「目前要處理的矩陣」的長度，同時也用來判斷&lt;strong&gt;child&lt;/strong&gt;是否超過矩陣長度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;BuildMaxHeap()&lt;/code&gt;：對所有「具有&lt;strong&gt;child&lt;/strong&gt;的node」進行&lt;code&gt;MaxHeapify()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HeapSort()&lt;/code&gt;：將Max Heap轉換成「由小到大」排好序的矩陣。小細節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為heap是從index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)開始儲存資料，所以要先把index(&lt;span class="math"&gt;\(0\)&lt;/span&gt;)給空下來，最後再將其刪除。&lt;/li&gt;
&lt;li&gt;這裡是利用&lt;code&gt;std::vector&amp;lt;int&amp;gt;&lt;/code&gt;的成員函式(member function)「&lt;code&gt;insert()&lt;/code&gt;」與「&lt;code&gt;erase()&lt;/code&gt;」處理。
關於&lt;code&gt;std::vector&lt;/code&gt;，請參考：&lt;a href="http://www.cplusplus.com/reference/vector/vector/"&gt;Cplusplus：std::vector&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;，建立矩陣，並執行&lt;code&gt;HeapSort()&lt;/code&gt;，驗證結果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;MaxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="c1"&gt;// 取得left child&lt;/span&gt;
    &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="c1"&gt;// 取得right child&lt;/span&gt;
    &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// largest用來記錄包含root與child, 三者之中Key最大的node&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                         &lt;span class="c1"&gt;// 如果目前root的Key不是三者中的最大&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;         &lt;span class="c1"&gt;// 就調換root與三者中Key最大的node之位置&lt;/span&gt;
        &lt;span class="n"&gt;MaxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// 調整新的subtree成Max Heap&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BuildMaxHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MaxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// length要減一, 因為heap從1開始存放資料&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;HeapSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                     &lt;span class="c1"&gt;// 將index(0)閒置&lt;/span&gt;

    &lt;span class="n"&gt;BuildMaxHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                                &lt;span class="c1"&gt;// 將array調整成Max Heap&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// size用來記錄「目前要處理的矩陣」之長度&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;                       &lt;span class="c1"&gt;// 將最大值放到array的最後一個位置&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;MaxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                     &lt;span class="c1"&gt;// 調整「忽略最後一個位置」的矩陣&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;                         &lt;span class="c1"&gt;// 將index(0)刪除&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;original:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;HeapSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sorted:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;original&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="nl"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是以Max Heap實現&lt;strong&gt;Heap Sort&lt;/strong&gt;之介紹。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch6&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5, Ch7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie-binary-heap.html"&gt;Priority Queue：Intro(簡介) &amp;amp; Binary Heap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cplusplus.com/reference/vector/vector/"&gt;Cplusplus：std::vector&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Comparison Sort系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-insertion-sortcha-ru-pai-xu-fa.html"&gt;Comparison Sort: Insertion Sort(插入排序法)&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-quick-sortkuai-su-pai-xu-fa.html"&gt;Comparison Sort: Quick Sort(快速排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-heap-sortdui-ji-pai-xu-fa.html"&gt;Comparison Sort: Heap Sort(堆積排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html"&gt;Comparison Sort: Merge Sort(合併排序法)&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Comparison Sort"></category><category term="Sort"></category><category term="Heap"></category></entry><entry><title>Comparison Sort: Quick Sort(快速排序法)</title><link href="http://alrightchiu.github.io/SecondRound/comparison-sort-quick-sortkuai-su-pai-xu-fa.html" rel="alternate"></link><updated>2016-03-26T17:51:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-26:SecondRound/comparison-sort-quick-sortkuai-su-pai-xu-fa.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;Sorting(排序)是基本的資料處理，舉例來說，進入圖書館的查詢系統，不論是想按照「出版日期」或是「相關程度」找書，都會得到「排序過」的結果。&lt;/p&gt;
&lt;p&gt;常見的&lt;strong&gt;Comparison Sort&lt;/strong&gt;及其時間複雜度如表一，假設問題有&lt;span class="math"&gt;\(N\)&lt;/span&gt;筆資料：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Quick Sort &amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Merge Sort &amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Heap Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Insertion Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Selection Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;best case&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;average case &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;worst case&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：五種排序法之時間複雜度比較&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
本篇文章將介紹&lt;strong&gt;Quick Sort(快速排序法)&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#insertionsort"&gt;Quick Sort(快速排序法)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#partition"&gt;介紹：Partition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Comparison Sort系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="insertionsort"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Quick Sort(快速排序法)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Quick Sort&lt;/strong&gt;是一種「把大問題分成小問題處理」的&lt;strong&gt;Divide and Conquer&lt;/strong&gt;方法，概念如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在數列中任意挑選一個數，稱為&lt;strong&gt;pivot&lt;/strong&gt;，然後&lt;strong&gt;調整數列&lt;/strong&gt;，使得「所有在&lt;strong&gt;pivot&lt;/strong&gt;左邊的數，都比&lt;strong&gt;pivot&lt;/strong&gt;還小」，而「在&lt;strong&gt;pivot&lt;/strong&gt;右邊的數都比&lt;strong&gt;pivot&lt;/strong&gt;大」。&lt;/li&gt;
&lt;li&gt;接著，將所有在&lt;strong&gt;pivot&lt;/strong&gt;左邊的數視為「新的數列」，所有在&lt;strong&gt;pivot&lt;/strong&gt;右邊的數視為「另一個新的數列」，「分別」重複上述步驟(選&lt;strong&gt;pivot&lt;/strong&gt;、調整數列)，直到分不出「新的數列」為止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖一(a)為例，考慮數列{&lt;span class="math"&gt;\(9、4、1、6、7、3、8、2、5\)&lt;/span&gt;}，先任意選定&lt;span class="math"&gt;\(5\)&lt;/span&gt;為&lt;strong&gt;pivot&lt;/strong&gt;，接著調整數列，使得&lt;strong&gt;pivot&lt;/strong&gt;左邊的數{&lt;span class="math"&gt;\(4、1、3、2\)&lt;/span&gt;}皆小於&lt;span class="math"&gt;\(5\)&lt;/span&gt;，而&lt;strong&gt;pivot&lt;/strong&gt;右邊的數{&lt;span class="math"&gt;\(9、8、6、7\)&lt;/span&gt;}皆大於&lt;span class="math"&gt;\(5\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前為止，{&lt;span class="math"&gt;\(4、1、3、2\)&lt;/span&gt;}之間的大小順序還不必理會，{&lt;span class="math"&gt;\(9、8、6、7\)&lt;/span&gt;}之間的大小順序也不必理會。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著，分別將&lt;strong&gt;pivot&lt;/strong&gt;左邊的數列{&lt;span class="math"&gt;\(4、1、3、2\)&lt;/span&gt;}與&lt;strong&gt;pivot&lt;/strong&gt;右邊的數列{&lt;span class="math"&gt;\(9、8、6、7\)&lt;/span&gt;}視為新的數列處理，重複上述步驟(選&lt;strong&gt;pivot&lt;/strong&gt;、調整數列)，直到分不出「新的數列」為止，見圖一(b)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上的步驟中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pivot&lt;/strong&gt;可以任意挑選，在此是固定挑選數列(矩陣)的最後一個元素。&lt;/li&gt;
&lt;li&gt;在「新的數列」上只是重複相同的步驟(選&lt;strong&gt;pivot&lt;/strong&gt;、調整數列)，可以利用&lt;strong&gt;遞迴(recursion)&lt;/strong&gt;處理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，最關鍵的就是如何「調整數列」，江湖上尊稱其為：&lt;strong&gt;Partition&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="partition"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;介紹：Partition&lt;/h3&gt;
&lt;p&gt;如同圖一(a)，&lt;strong&gt;Partition&lt;/strong&gt;的功能就是把數列「區分」成「小於&lt;strong&gt;pivot&lt;/strong&gt;」與「大於&lt;strong&gt;pivot&lt;/strong&gt;」兩半。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;詳細步驟如下：&lt;/p&gt;
&lt;p&gt;定義變數(variable)，見圖二(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int front&lt;/code&gt;為數列的「最前端」index。&lt;ul&gt;
&lt;li&gt;此例，&lt;code&gt;front&lt;/code&gt;為index(&lt;span class="math"&gt;\(0\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int end&lt;/code&gt;為數列的「最尾端」index。&lt;ul&gt;
&lt;li&gt;此例，&lt;code&gt;end&lt;/code&gt;為index(&lt;span class="math"&gt;\(8\)&lt;/span&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int i&lt;/code&gt;為所有小於&lt;strong&gt;pivot&lt;/strong&gt;的數所形成的數列的「最後位置」。&lt;ul&gt;
&lt;li&gt;一開始將index(&lt;code&gt;i&lt;/code&gt;)初始化為&lt;code&gt;front-1&lt;/code&gt;，因為有可能數列中，所有數都比&lt;strong&gt;pivot&lt;/strong&gt;大。&lt;/li&gt;
&lt;li&gt;一旦發現有數比&lt;strong&gt;pivot&lt;/strong&gt;小，index(&lt;code&gt;i&lt;/code&gt;)便往後移動(&lt;code&gt;i++&lt;/code&gt;)，表示「所有小於&lt;strong&gt;pivot&lt;/strong&gt;的數所形成的數列」又增加了一名成員。&lt;/li&gt;
&lt;li&gt;當演算法結束時，所有在index(&lt;code&gt;i&lt;/code&gt;)左邊的數，都比&lt;strong&gt;pivot&lt;/strong&gt;小，所有在index(&lt;code&gt;i&lt;/code&gt;)右邊的數，都比&lt;strong&gt;pivot&lt;/strong&gt;大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int j&lt;/code&gt;是讓&lt;strong&gt;pivot&lt;/strong&gt;與其餘數值逐一比較的index，從&lt;code&gt;front&lt;/code&gt;檢查到&lt;code&gt;end-1&lt;/code&gt;(因為&lt;code&gt;end&lt;/code&gt;是&lt;strong&gt;pivot&lt;/strong&gt;自己)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int pivot=array[end]&lt;/code&gt;，以數列最後一個數做為&lt;strong&gt;pivot&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;此例，&lt;code&gt;pivot&lt;/code&gt;為&lt;span class="math"&gt;\(5\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pivot&lt;/strong&gt;的「數值」可以是任意的，挑選矩陣的最後一個位置是為了方便index(&lt;code&gt;j&lt;/code&gt;)的移動，也可以挑選任意位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，開始移動index(&lt;code&gt;j&lt;/code&gt;)，從index(&lt;span class="math"&gt;\(0\)&lt;/span&gt;)到index(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)，將數列(矩陣)元素逐一與&lt;code&gt;pivot&lt;/code&gt;比較，並進行調整(用&lt;code&gt;swap()&lt;/code&gt;調整)。&lt;/p&gt;
&lt;p&gt;見圖二(b)，一開始，&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=0\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=-1\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;pivot&lt;/code&gt;與&lt;code&gt;array[j=0]&lt;/code&gt;，發現&lt;code&gt;pivot&lt;/code&gt;&lt;span class="math"&gt;\(=5&amp;lt;\)&lt;/span&gt;&lt;code&gt;array[0]&lt;/code&gt;&lt;span class="math"&gt;\(=9\)&lt;/span&gt;，所以不需要移動index(&lt;code&gt;i&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;移動index(&lt;code&gt;j&lt;/code&gt;)，&lt;code&gt;j++&lt;/code&gt;，繼續往後比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖二(c)，此時&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=1\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=-1\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;pivot&lt;/code&gt;與&lt;code&gt;array[j=1]&lt;/code&gt;，發現&lt;code&gt;pivot&lt;/code&gt;&lt;span class="math"&gt;\(=5&amp;gt;\)&lt;/span&gt;&lt;code&gt;array[1]&lt;/code&gt;&lt;span class="math"&gt;\(=4\)&lt;/span&gt;，便執行：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i++&lt;/code&gt;：移動index(&lt;code&gt;i&lt;/code&gt;)，表示又找到一個比&lt;strong&gt;pivot&lt;/strong&gt;小的數。此時，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=0\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap(array[i=0],array[j=1])&lt;/code&gt;：透過這個&lt;code&gt;swap()&lt;/code&gt;，便能把比&lt;strong&gt;pivot&lt;/strong&gt;小的數，放到比&lt;strong&gt;pivot&lt;/strong&gt;大的數的「前面」(也就是矩陣的左邊)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移動index(&lt;code&gt;j&lt;/code&gt;)，&lt;code&gt;j++&lt;/code&gt;，繼續往後比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖二(d)，此時&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=2\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=0\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;pivot&lt;/code&gt;與&lt;code&gt;array[j=2]&lt;/code&gt;，發現&lt;code&gt;pivot&lt;/code&gt;&lt;span class="math"&gt;\(=5&amp;gt;\)&lt;/span&gt;&lt;code&gt;array[2]&lt;/code&gt;&lt;span class="math"&gt;\(=1\)&lt;/span&gt;，便執行：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i++&lt;/code&gt;：移動index(&lt;code&gt;i&lt;/code&gt;)，表示又找到一個比&lt;strong&gt;pivot&lt;/strong&gt;小的數。此時，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap(array[i=1],array[j=2])&lt;/code&gt;：透過這個&lt;code&gt;swap()&lt;/code&gt;，便能把比&lt;strong&gt;pivot&lt;/strong&gt;小的數({&lt;span class="math"&gt;\(4、1\)&lt;/span&gt;})，放到比&lt;strong&gt;pivot&lt;/strong&gt;大的數({&lt;span class="math"&gt;\(9\)&lt;/span&gt;})的「前面」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移動index(&lt;code&gt;j&lt;/code&gt;)，&lt;code&gt;j++&lt;/code&gt;，繼續往後比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖二(e)，此時&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=3\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=1\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;pivot&lt;/code&gt;與&lt;code&gt;array[j=3]&lt;/code&gt;，發現&lt;code&gt;pivot&lt;/code&gt;&lt;span class="math"&gt;\(=5&amp;lt;\)&lt;/span&gt;&lt;code&gt;array[3]&lt;/code&gt;&lt;span class="math"&gt;\(=6\)&lt;/span&gt;，所以不需要移動index(&lt;code&gt;i&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;移動index(&lt;code&gt;j&lt;/code&gt;)，&lt;code&gt;j++&lt;/code&gt;，繼續往後比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖二(f)，此時&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=4\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=1\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;pivot&lt;/code&gt;與&lt;code&gt;array[j=4]&lt;/code&gt;，發現&lt;code&gt;pivot&lt;/code&gt;&lt;span class="math"&gt;\(=5&amp;lt;\)&lt;/span&gt;&lt;code&gt;array[4]&lt;/code&gt;&lt;span class="math"&gt;\(=7\)&lt;/span&gt;，所以不需要移動index(&lt;code&gt;i&lt;/code&gt;)。&lt;ul&gt;
&lt;li&gt;到目前為止，漸漸可以看出，「比&lt;strong&gt;pivot&lt;/strong&gt;小」的數形成一個數列({&lt;span class="math"&gt;\(4、1\)&lt;/span&gt;})，「比&lt;strong&gt;pivot&lt;/strong&gt;大」的數形成另一個數列({&lt;span class="math"&gt;\(9、6、7\)&lt;/span&gt;})，最後只要把&lt;strong&gt;pivot&lt;/strong&gt;插入這兩個數列中間，就完成的&lt;code&gt;Partition()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移動index(&lt;code&gt;j&lt;/code&gt;)，&lt;code&gt;j++&lt;/code&gt;，繼續往後比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(f)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖二(g)，此時&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=5\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=1\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;pivot&lt;/code&gt;與&lt;code&gt;array[j=5]&lt;/code&gt;，發現&lt;code&gt;pivot&lt;/code&gt;&lt;span class="math"&gt;\(=5&amp;gt;\)&lt;/span&gt;&lt;code&gt;array[5]&lt;/code&gt;&lt;span class="math"&gt;\(=3\)&lt;/span&gt;，便執行：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i++&lt;/code&gt;：移動index(&lt;code&gt;i&lt;/code&gt;)，表示又找到一個比&lt;strong&gt;pivot&lt;/strong&gt;小的數。此時，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=2\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap(array[i=2],array[j=5])&lt;/code&gt;：透過這個&lt;code&gt;swap()&lt;/code&gt;，便能把比&lt;strong&gt;pivot&lt;/strong&gt;小的數({&lt;span class="math"&gt;\(4、1、3\)&lt;/span&gt;})，放到比&lt;strong&gt;pivot&lt;/strong&gt;大的數({&lt;span class="math"&gt;\(6、7、9\)&lt;/span&gt;})的「前面」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移動index(&lt;code&gt;j&lt;/code&gt;)，&lt;code&gt;j++&lt;/code&gt;，繼續往後比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(g)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖二(h)，此時&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=6\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=2\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;pivot&lt;/code&gt;與&lt;code&gt;array[j=6]&lt;/code&gt;，發現&lt;code&gt;pivot&lt;/code&gt;&lt;span class="math"&gt;\(=5&amp;lt;\)&lt;/span&gt;&lt;code&gt;array[6]&lt;/code&gt;&lt;span class="math"&gt;\(=8\)&lt;/span&gt;，所以不需要移動index(&lt;code&gt;i&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;移動index(&lt;code&gt;j&lt;/code&gt;)，&lt;code&gt;j++&lt;/code&gt;，繼續往後比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(h)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖二(i)，此時&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=7\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=2\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;pivot&lt;/code&gt;與&lt;code&gt;array[j=7]&lt;/code&gt;，發現&lt;code&gt;pivot&lt;/code&gt;&lt;span class="math"&gt;\(=5&amp;gt;\)&lt;/span&gt;&lt;code&gt;array[7]&lt;/code&gt;&lt;span class="math"&gt;\(=2\)&lt;/span&gt;，便執行：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i++&lt;/code&gt;：移動index(&lt;code&gt;i&lt;/code&gt;)，表示又找到一個比&lt;strong&gt;pivot&lt;/strong&gt;小的數。此時，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=3\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap(array[i=3],array[j=7])&lt;/code&gt;：透過這個&lt;code&gt;swap()&lt;/code&gt;，便能把比&lt;strong&gt;pivot&lt;/strong&gt;小的數({&lt;span class="math"&gt;\(4、1、3、2\)&lt;/span&gt;})，放到比&lt;strong&gt;pivot&lt;/strong&gt;大的數({&lt;span class="math"&gt;\(6、7、9、8\)&lt;/span&gt;})的「前面」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移動index(&lt;code&gt;j&lt;/code&gt;)，&lt;code&gt;j++&lt;/code&gt;，繼續往後比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(i)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖二(j)，此時&lt;code&gt;j&lt;/code&gt;&lt;span class="math"&gt;\(=8\)&lt;/span&gt;，&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=3\)&lt;/span&gt;。&lt;br /&gt;
因為index(&lt;code&gt;j&lt;/code&gt;)只需要從&lt;code&gt;front&lt;/code&gt;移動到&lt;code&gt;end-1&lt;/code&gt;即可。當index(&lt;code&gt;j&lt;/code&gt;)走到&lt;code&gt;end&lt;/code&gt;時，便結束此&lt;strong&gt;迴圈&lt;/strong&gt;，表示數列中的所有數都已經和&lt;strong&gt;pivot&lt;/strong&gt;比較過了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i++&lt;/code&gt;，把index(&lt;code&gt;i&lt;/code&gt;)從「所有比&lt;strong&gt;pivot&lt;/strong&gt;小的數列」的最後一個位置，移動到「所有比&lt;strong&gt;pivot&lt;/strong&gt;大的數列」的第一個位置，此時&lt;code&gt;i&lt;/code&gt;&lt;span class="math"&gt;\(=4\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;接著執行&lt;code&gt;swap(array[i=4],array[end])&lt;/code&gt;：便成功把&lt;strong&gt;pivot&lt;/strong&gt;插入兩個數列之間了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(j)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過以上步驟，便把數列分成三部分，如圖一(a)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比&lt;strong&gt;pivot&lt;/strong&gt;小的數所形成的數列；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pivot&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;比&lt;strong&gt;pivot&lt;/strong&gt;大的數所形成的數列。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，只要再對「左數列」與「右數列」，分別重複上述的「選&lt;strong&gt;pivot&lt;/strong&gt;、調整數列」步驟，如圖三，直到新數列只剩下一個元素或者沒有元素(亦即：&lt;code&gt;front&lt;/code&gt;&lt;span class="math"&gt;\(\geq\)&lt;/span&gt;&lt;code&gt;end&lt;/code&gt;)，便能完成對數列的排序。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/QuickSort/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：以遞迴的方式，對新的數列做排序。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;程式碼很直觀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;swap()&lt;/code&gt;：交換矩陣元素之位置，使用時機：&lt;ul&gt;
&lt;li&gt;當&lt;code&gt;Partition()&lt;/code&gt;中條件式&lt;code&gt;if(pivot&amp;lt;array[j])&lt;/code&gt;時；&lt;/li&gt;
&lt;li&gt;當index(&lt;code&gt;j&lt;/code&gt;)檢查完除了&lt;code&gt;pivot=array[end]&lt;/code&gt;之外的元素時。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Partition()&lt;/code&gt;：將數列調整成「比&lt;strong&gt;pivot&lt;/strong&gt;小」、「&lt;strong&gt;pivot&lt;/strong&gt;」、「比&lt;strong&gt;pivot&lt;/strong&gt;大」的主要函式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuickSort()&lt;/code&gt;：進行&lt;strong&gt;Quick Sort&lt;/strong&gt;的主要函式，以&lt;strong&gt;遞迴(recursion)&lt;/strong&gt;的形式，將數列(矩陣)不斷拆解成更小的數列，藉此排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;，以矩陣表示如圖一(a)的數列，進行&lt;code&gt;QuickSort()&lt;/code&gt;，並將矩陣元素以&lt;code&gt;PrintArray()&lt;/code&gt;印出。&lt;/p&gt;
&lt;p&gt;完整程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;original:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sorted:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;original&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; 
&lt;span class="nl"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是&lt;strong&gt;Quick Sort&lt;/strong&gt;的介紹。&lt;br /&gt;
因為不需要額外的記憶體空間，因此，只要能避免&lt;strong&gt;worst case&lt;/strong&gt;，那麼&lt;strong&gt;Quick Sort&lt;/strong&gt;會非常有效率。&lt;/p&gt;
&lt;p&gt;關於時間複雜度的部分，請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/analysis-of-quicksort"&gt;Khan Academy：Analysis of quicksort&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;優化的方法，請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/12454866/how-to-optimize-quicksort"&gt;Stackoverflow：How to optimize quicksort&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch7&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Comparison_sort"&gt;Wikipedia：Comparison sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Sorting_algorithm"&gt;Wikipedia：Sorting algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/12454866/how-to-optimize-quicksort"&gt;Stackoverflow：How to optimize quicksort&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/analysis-of-quicksort"&gt;Khan Academy：Analysis of quicksort&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Comparison Sort系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-insertion-sortcha-ru-pai-xu-fa.html"&gt;Comparison Sort: Insertion Sort(插入排序法)&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-quick-sortkuai-su-pai-xu-fa.html"&gt;Comparison Sort: Quick Sort(快速排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-heap-sortdui-ji-pai-xu-fa.html"&gt;Comparison Sort: Heap Sort(堆積排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html"&gt;Comparison Sort: Merge Sort(合併排序法)&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Comparison Sort"></category><category term="Sort"></category><category term="Divide and Conquer"></category></entry><entry><title>Comparison Sort: Insertion Sort(插入排序法)</title><link href="http://alrightchiu.github.io/SecondRound/comparison-sort-insertion-sortcha-ru-pai-xu-fa.html" rel="alternate"></link><updated>2016-03-22T23:49:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-22:SecondRound/comparison-sort-insertion-sortcha-ru-pai-xu-fa.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;Sorting(排序)是基本的資料處理，舉例來說，進入圖書館的查詢系統，不論是想按照「出版日期」或是「相關程度」找書，都會得到「排序過」的結果。&lt;/p&gt;
&lt;p&gt;常見的&lt;strong&gt;Comparison Sort&lt;/strong&gt;及其時間複雜度如表一，假設問題有&lt;span class="math"&gt;\(N\)&lt;/span&gt;筆資料：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Quick Sort &amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Merge Sort &amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Heap Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Insertion Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;Selection Sort&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;best case&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;average case &amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;worst case&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N\log N\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(N^2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：五種排序法之時間複雜度比較&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;br /&gt;
本篇文章將介紹&lt;strong&gt;Insertion Sort(插入排序法)&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#insertionsort"&gt;Insertion Sort(插入排序法)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Comparison Sort系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="insertionsort"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Insertion Sort(插入排序法)&lt;/h2&gt;
&lt;p&gt;想像手上有一副撲克牌，若想要將紙牌從左到右按照「小到大」排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Insertion Sort&lt;/strong&gt;的方法為：將第&lt;span class="math"&gt;\(i\)&lt;/span&gt;張紙牌加入「前&lt;span class="math"&gt;\(i-1\)&lt;/span&gt;張排序過」的紙牌組合，得到&lt;span class="math"&gt;\(i\)&lt;/span&gt;張排序過的紙牌組合。&lt;/p&gt;
&lt;p&gt;以圖一為例，從左邊數來的前三張紙牌已經排好序：index(0)、index(1)、index(2)分別為&lt;span class="math"&gt;\(1、3、5\)&lt;/span&gt;，現在要將第四張紙牌(index(3)，數值為&lt;span class="math"&gt;\(2\)&lt;/span&gt;)加入前三張牌，想要得到「前四張排好序」的紙牌組合。&lt;br /&gt;
經由觀察，最終結果的紙牌順序為&lt;span class="math"&gt;\(1、2、3、5\)&lt;/span&gt;，可以透過以下步驟完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原先index(2)的&lt;span class="math"&gt;\(5\)&lt;/span&gt;搬到index(3)；&lt;/li&gt;
&lt;li&gt;原先index(1)的&lt;span class="math"&gt;\(3\)&lt;/span&gt;搬到index(2)；&lt;/li&gt;
&lt;li&gt;原先index(3)的&lt;span class="math"&gt;\(2\)&lt;/span&gt;搬到index(1)；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此便能把第&lt;span class="math"&gt;\(4\)&lt;/span&gt;張紙牌加入(&lt;strong&gt;insert&lt;/strong&gt;)「前&lt;span class="math"&gt;\(3\)&lt;/span&gt;張排序過」的紙牌組合，得到「前&lt;span class="math"&gt;\(4\)&lt;/span&gt;張排序過」的紙牌組合。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/InsertionSort/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：想像這是撲克牌。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由以上說明可以看出，&lt;strong&gt;Insertion Sort&lt;/strong&gt;要求，在處理第&lt;span class="math"&gt;\(i\)&lt;/span&gt;筆資料時，第&lt;span class="math"&gt;\(1\)&lt;/span&gt;筆至第&lt;span class="math"&gt;\(i-1\)&lt;/span&gt;筆資料必須先排好序。&lt;br /&gt;
那麼，只要按照順序，從第&lt;span class="math"&gt;\(1\)&lt;/span&gt;筆資料開始處理，便能確保「處理第&lt;span class="math"&gt;\(2\)&lt;/span&gt;筆資料時，第&lt;span class="math"&gt;\(1\)&lt;/span&gt;筆資料已經排好序」，「處理第&lt;span class="math"&gt;\(3\)&lt;/span&gt;筆資料時，第&lt;span class="math"&gt;\(1\)&lt;/span&gt;筆、第&lt;span class="math"&gt;\(2\)&lt;/span&gt;筆資料已經排好序」，依此類推，若共有&lt;span class="math"&gt;\(N\)&lt;/span&gt;筆資料，必定能夠在處理第&lt;span class="math"&gt;\(N\)&lt;/span&gt;筆資料時，將第&lt;span class="math"&gt;\(1\)&lt;/span&gt;筆至第&lt;span class="math"&gt;\(N-1\)&lt;/span&gt;筆資料排序過。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/InsertionSort/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以下將以圖二的矩陣資料為例，進行&lt;strong&gt;Insertion Sort&lt;/strong&gt;，見圖三。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/InsertionSort/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
那麼，第&lt;span class="math"&gt;\(i\)&lt;/span&gt;筆資料要怎麼知道其在前&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(i-1\)&lt;/span&gt;筆資料之間的順序位置？以圖三為例，當要將&lt;code&gt;array[3]&lt;/code&gt;的&lt;span class="math"&gt;\(2\)&lt;/span&gt;，加入&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[2]&lt;/code&gt;的數列時，要怎麼得知，其將被換到&lt;code&gt;array[1]&lt;/code&gt;的位置？  &lt;br /&gt;
就是要透過&lt;strong&gt;comparison&lt;/strong&gt;(比較)。&lt;/p&gt;
&lt;p&gt;詳細步驟如下：&lt;/p&gt;
&lt;p&gt;現考慮將&lt;code&gt;array[1]&lt;/code&gt;的&lt;span class="math"&gt;\(3\)&lt;/span&gt;加入&lt;code&gt;array[1]&lt;/code&gt;之前的數列，也就是與&lt;code&gt;array[0]&lt;/code&gt;的&lt;span class="math"&gt;\(5\)&lt;/span&gt;，一起形成「排好序」的&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[1]&lt;/code&gt;，見圖四(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義變數&lt;code&gt;int i&lt;/code&gt;為「目前欲處理」的資料的index。&lt;ul&gt;
&lt;li&gt;在此&lt;code&gt;i=1&lt;/code&gt;，&lt;code&gt;array[i]=3&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定義變數&lt;code&gt;int j&lt;/code&gt;來表示「已經排好序」的數列的「最後一個」元素之index。&lt;ul&gt;
&lt;li&gt;在此&lt;code&gt;j=0&lt;/code&gt;，&lt;code&gt;array[j]=5&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int j&lt;/code&gt;會不斷遞減，&lt;code&gt;j--&lt;/code&gt;，來檢查&lt;code&gt;array[j]&lt;/code&gt;是否比「目前欲處理」的資料還大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定義變數&lt;code&gt;int key=array[i]&lt;/code&gt;，把「目前欲處理」的&lt;code&gt;array[i]&lt;/code&gt;以&lt;code&gt;key&lt;/code&gt;儲存，避免&lt;code&gt;array[i]&lt;/code&gt;被覆蓋掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/InsertionSort/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，比較&lt;code&gt;key&lt;/code&gt;與&lt;code&gt;array[j]&lt;/code&gt;的大小，同時確認index(j)沒有超出矩陣範圍。  &lt;/p&gt;
&lt;p&gt;若&lt;code&gt;key&amp;lt;array[j]&lt;/code&gt;(並且&lt;code&gt;j&amp;gt;-1&lt;/code&gt;)，就表示「目前欲處理」的資料(原先位在index(i)的資料)，比&lt;code&gt;array[j]&lt;/code&gt;(也就是index(i-1)的資料)還要小，於是將&lt;code&gt;array[j]&lt;/code&gt;「往後移」，見圖四(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;換位置的方式類似&lt;code&gt;swap()&lt;/code&gt;，先執行&lt;code&gt;array[j+1]=array[j]&lt;/code&gt;，也就是將原先的&lt;code&gt;array[j]&lt;/code&gt;「往後移一個位置」。&lt;ul&gt;
&lt;li&gt;在此，把&lt;span class="math"&gt;\(5\)&lt;/span&gt;放進&lt;code&gt;array[1]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;可以預期，原先&lt;span class="math"&gt;\(5\)&lt;/span&gt;在的位置array[0]會被&lt;code&gt;key&lt;/code&gt;給補上。如此便完成&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[1]&lt;/code&gt;的排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接著，因為不確定前&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(i-1\)&lt;/span&gt;筆資料中，是否還有資料比&lt;code&gt;key&lt;/code&gt;大，所以執行&lt;code&gt;j--&lt;/code&gt;，繼續「往前」比較。&lt;ul&gt;
&lt;li&gt;在此例，因為&lt;code&gt;j--&lt;/code&gt;後，&lt;code&gt;j&lt;/code&gt;等於&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，已經超過矩陣範圍，所以便結束程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/InsertionSort/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;當兩項條件：&lt;code&gt;j&amp;gt;-1&lt;/code&gt;與&lt;code&gt;key&amp;lt;array[j]&lt;/code&gt;中，有任何一項條件不滿足時，便表示「已經檢查到前&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(i-1\)&lt;/span&gt;筆資料的盡頭」，或是「已經沒有比&lt;code&gt;key&lt;/code&gt;還小的資料」，於是便執行&lt;code&gt;array[j+1]=key&lt;/code&gt;，把&lt;code&gt;key&lt;/code&gt;放回矩陣裡，見圖四(c)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當不滿足上述兩項條件時，&lt;code&gt;j+1&lt;/code&gt;就會是&lt;code&gt;key&lt;/code&gt;的位置。&lt;br /&gt;
在此，&lt;code&gt;j&lt;/code&gt;等於&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，&lt;code&gt;j+1&lt;/code&gt;等於&lt;span class="math"&gt;\(0\)&lt;/span&gt;，表示&lt;code&gt;key&lt;/code&gt;是&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(i\)&lt;/span&gt;筆資料中，最小的資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上步驟，便完成&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[1]&lt;/code&gt;的排序。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/InsertionSort/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;目前為止，可以確定&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[1]&lt;/code&gt;已經排好序，便能夠再接著將&lt;code&gt;array[2]&lt;/code&gt;加入前面兩項，完成&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[2]&lt;/code&gt;的排序，見圖四(d)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/InsertionSort/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(d)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再看一次，要把&lt;code&gt;array[3]&lt;/code&gt;放入&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[2]&lt;/code&gt;的排序中，形成&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[3]&lt;/code&gt;的排序。&lt;/p&gt;
&lt;p&gt;其中，在比較&lt;code&gt;key&lt;/code&gt;是否比&lt;code&gt;array[0]&lt;/code&gt;還小時，發現&lt;code&gt;key&amp;gt;array[j]&lt;/code&gt;(&lt;code&gt;key&lt;/code&gt;為&lt;span class="math"&gt;\(2\)&lt;/span&gt;，&lt;code&gt;array[j]&lt;/code&gt;為&lt;span class="math"&gt;\(1\)&lt;/span&gt;)，便不需要把&lt;code&gt;array[0]&lt;/code&gt;「往後移」，並把&lt;code&gt;key&lt;/code&gt;放進&lt;code&gt;array[j+1]&lt;/code&gt;，完成&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[3]&lt;/code&gt;的排序。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Sorting%20series/ComparisonSort_fig/InsertionSort/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(e)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;重複上述步驟，便可完成&lt;code&gt;array[0]&lt;/code&gt;~&lt;code&gt;array[5]&lt;/code&gt;的排序，如圖三所示。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;程式碼很直觀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int i&lt;/code&gt;是「目前要處理」的資料index(i)；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int j=i-1&lt;/code&gt;是用來指出前&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(i-1\)&lt;/span&gt;筆資料的index；&lt;/li&gt;
&lt;li&gt;第一個&lt;code&gt;for&lt;/code&gt;迴圈，用意是把每一個矩陣元素都視為「目前要處理」的資料一次；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;for&lt;/code&gt;迴圈裡的&lt;code&gt;while&lt;/code&gt;迴圈，用意是把「目前要處理」的資料與前&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(i-1\)&lt;/span&gt;筆資料做比較，並找到適當的位置，將&lt;span class="math"&gt;\(1\)&lt;/span&gt;~&lt;span class="math"&gt;\(i\)&lt;/span&gt;筆資料做排序。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;，建立如圖二的矩陣，進行&lt;code&gt;InsertionSort()&lt;/code&gt;，並將矩陣元素以&lt;code&gt;PrintArray()&lt;/code&gt;印出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InsertionSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;original:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;InsertionSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sorted:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;original&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; 
&lt;span class="nl"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是&lt;strong&gt;Insertion Sort&lt;/strong&gt;的介紹。&lt;/p&gt;
&lt;p&gt;關於時間複雜度的部分：&lt;br /&gt;
(欲將資料由左至右以「小到大」排序)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;best case&lt;/strong&gt;：若要處理的序列是&lt;span class="math"&gt;\(1、2、...、N\)&lt;/span&gt;，那麼只要比較&lt;span class="math"&gt;\(N\)&lt;/span&gt;次即可完成排序，時間複雜度為&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;，此即為。&lt;ul&gt;
&lt;li&gt;依此推論，當問題已經「接近完成排序」的狀態時，使用&lt;strong&gt;Insertion Sort&lt;/strong&gt;會非常有效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;worst case&lt;/strong&gt;：若要處理的序列恰好是顛倒順序，&lt;span class="math"&gt;\(N、N-1、...、2、1\)&lt;/span&gt;，那麼位於index(i)的元素，需要比較「&lt;span class="math"&gt;\(i-1\)&lt;/span&gt;次」，完成演算法總共要比較&lt;span class="math"&gt;\(frac{N(N-1)}{2}\)&lt;/span&gt;次，時間複雜度為&lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;average case&lt;/strong&gt;：時間複雜度也是&lt;span class="math"&gt;\(O(N^2)\)&lt;/span&gt;。&lt;ul&gt;
&lt;li&gt;詳情請參考：&lt;a href="http://home.cse.ust.hk/faculty/golin/COMP271Sp03/Notes/Ins_Sort_Average_Case.pdf"&gt;Mordecai Golin：Average Case Analysis of Insertionsort&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當問題的資料量較小時(欲排序的元素之數目較小)，使用&lt;strong&gt;Insertion Sort&lt;/strong&gt;會很有效率，這是因為和&lt;strong&gt;Quick Sort&lt;/strong&gt;、&lt;strong&gt;Merge Sort&lt;/strong&gt;、&lt;strong&gt;Heap Sort&lt;/strong&gt;相比，&lt;strong&gt;Insertion Sort&lt;/strong&gt;不具有「遞迴」形式，因此不需要&lt;strong&gt;系統的stack&lt;/strong&gt;，詳情請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2651112/is-recursion-ever-faster-than-looping"&gt;Stackoverflow：Is recursion ever faster than looping?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/72209/recursion-or-iteration"&gt;Stackoverflow：Recursion or Iteration?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再加上前面提到的&lt;strong&gt;best case&lt;/strong&gt;特徵，有些演算法會在&lt;strong&gt;Quick Sort&lt;/strong&gt;中加入&lt;strong&gt;Insertion Sort&lt;/strong&gt;，讓剩下的「接近完成排序」的資料以&lt;strong&gt;Insertion Sort&lt;/strong&gt;處理，使排序更有效率，詳情請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/12454866/how-to-optimize-quicksort"&gt;Stackoverflow：How to optimize quicksort&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch1&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Comparison_sort"&gt;Wikipedia：Comparison sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Sorting_algorithm"&gt;Wikipedia：Sorting algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://home.cse.ust.hk/faculty/golin/COMP271Sp03/Notes/Ins_Sort_Average_Case.pdf"&gt;Mordecai Golin：Average Case Analysis of Insertionsort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2651112/is-recursion-ever-faster-than-looping"&gt;Stackoverflow：Is recursion ever faster than looping?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/72209/recursion-or-iteration"&gt;Stackoverflow：Recursion or Iteration?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/12454866/how-to-optimize-quicksort"&gt;Stackoverflow：How to optimize quicksort&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Comparison Sort系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-insertion-sortcha-ru-pai-xu-fa.html"&gt;Comparison Sort: Insertion Sort(插入排序法)&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-quick-sortkuai-su-pai-xu-fa.html"&gt;Comparison Sort: Quick Sort(快速排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-heap-sortdui-ji-pai-xu-fa.html"&gt;Comparison Sort: Heap Sort(堆積排序法)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html"&gt;Comparison Sort: Merge Sort(合併排序法)&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Comparison Sort"></category><category term="Sort"></category></entry><entry><title>Flow Networks：Maximum Flow &amp; Ford-Fulkerson Algorithm</title><link href="http://alrightchiu.github.io/SecondRound/flow-networksmaximum-flow-ford-fulkerson-algorithm.html" rel="alternate"></link><updated>2016-03-20T17:39:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-20:SecondRound/flow-networksmaximum-flow-ford-fulkerson-algorithm.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;考慮如下情境：&lt;/p&gt;
&lt;p&gt;在某個污水處理廠的某一道程序裡，有一個「進水孔」，和一個「排水孔」，中間由許多「孔徑不一」的水管連接起來，因為水管的「孔徑大小」會影響到「每單位時間的流量」，因此要解決的問題，就是找到每單位時間可以排放「最大流量(&lt;strong&gt;flow&lt;/strong&gt;)」的「排水方法」。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖一為例，進水孔為vertex(S)，排水孔為vertex(T)，中間要經過污水處理站vertex(A)與vertex(C)。&lt;br /&gt;
edge代表水管，edge之weight(以下將稱為&lt;strong&gt;capacity&lt;/strong&gt;)表示水管的「孔徑」。  &lt;/p&gt;
&lt;p&gt;考慮兩種「排水方法」的&lt;strong&gt;flow&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一種「分配水流」的方法，每單位時間總流量為&lt;span class="math"&gt;\(20\)&lt;/span&gt;：&lt;ol&gt;
&lt;li&gt;在&lt;span class="math"&gt;\(Path:S-A-T\)&lt;/span&gt;上每單位時間流了&lt;span class="math"&gt;\(5\)&lt;/span&gt;單位的水；&lt;/li&gt;
&lt;li&gt;在&lt;span class="math"&gt;\(Path:S-A-C-T\)&lt;/span&gt;上每單位時間流了&lt;span class="math"&gt;\(10\)&lt;/span&gt;單位的水(問題出在這，占去了edge(C,T)的容量)；&lt;/li&gt;
&lt;li&gt;在&lt;span class="math"&gt;\(Path:S-C-T\)&lt;/span&gt;上，因為edge(C,T)上只剩下「&lt;span class="math"&gt;\(5\)&lt;/span&gt;單位的容量」，因此每單位時間流了&lt;span class="math"&gt;\(5\)&lt;/span&gt;單位的水；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第二種「分配水流」的方法，每單位時間總流量為&lt;span class="math"&gt;\(25\)&lt;/span&gt;：&lt;ol&gt;
&lt;li&gt;在&lt;span class="math"&gt;\(Path:S-A-T\)&lt;/span&gt;上每單位時間流了&lt;span class="math"&gt;\(10\)&lt;/span&gt;單位的水；&lt;/li&gt;
&lt;li&gt;在&lt;span class="math"&gt;\(Path:S-A-C-T\)&lt;/span&gt;上每單位時間流了&lt;span class="math"&gt;\(5\)&lt;/span&gt;單位的水；&lt;/li&gt;
&lt;li&gt;在&lt;span class="math"&gt;\(Path:S-C-T\)&lt;/span&gt;上，因為edge(C,T)上剛好還有「&lt;span class="math"&gt;\(10\)&lt;/span&gt;單位的容量」，因此每單位時間流了&lt;span class="math"&gt;\(10\)&lt;/span&gt;單位的水；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;從以上兩種「排水方式」可以看得出來，解決問題的精神，就是如何有效利用水管的「孔徑容量」，讓最多的水可以從「進水孔」流到「排水孔」。&lt;/p&gt;
&lt;p&gt;這就是在&lt;strong&gt;Flow Networks&lt;/strong&gt;上找到&lt;strong&gt;Maximum Flow&lt;/strong&gt;(最大流量)的問題。&lt;/p&gt;
&lt;p&gt;以下將介紹&lt;strong&gt;Ford-Fulkerson Algorithm&lt;/strong&gt;(若使用&lt;strong&gt;BFS&lt;/strong&gt;搜尋路徑，又稱為&lt;strong&gt;Edmonds-Karp Algorithm&lt;/strong&gt;)來回應此問題。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#property"&gt;Flow Networks基本性質&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ff"&gt;Ford-Fulkerson Algorithm&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#residual"&gt;Residual Networks(剩餘網路)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#aug"&gt;Augmenting Paths(增廣路徑)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bfs"&gt;利用BFS的優點&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Flow Networks系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="property"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Flow Networks基本性質&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Flow Networks&lt;/strong&gt;是一個weighted,directed graph，其edge(X,Y)具有非負的&lt;strong&gt;capacity&lt;/strong&gt;，&lt;span class="math"&gt;\(c(X,Y)\geq 0\)&lt;/span&gt;，如圖二(a)。&lt;br /&gt;
(此處以&lt;strong&gt;capacity&lt;/strong&gt;取代&lt;strong&gt;weight&lt;/strong&gt;，&lt;strong&gt;capacity&lt;/strong&gt;就是「水管孔徑」。)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若不存在edge(X,Y)，則定義&lt;span class="math"&gt;\(c(X,Y)=0\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;特別區分兩個vertex：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;source&lt;/strong&gt;：表示Flow Networks的「流量源頭」，以&lt;strong&gt;s&lt;/strong&gt;表示；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sink&lt;/strong&gt;：表示Flow Networks的「流量終點」，也稱為&lt;strong&gt;termination&lt;/strong&gt;，以&lt;strong&gt;t&lt;/strong&gt;表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;而水管裡的「水流」，&lt;strong&gt;flow&lt;/strong&gt;，必須滿足以下條件，見圖二(b)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Capacity constraint&lt;/strong&gt;：從vertex(X)流向vertex(Y)的&lt;strong&gt;flow&lt;/strong&gt;，不能比edge(X,Y)的&lt;strong&gt;capacity&lt;/strong&gt;還大，&lt;span class="math"&gt;\(f(X,Y)\leq c(X,Y)\)&lt;/span&gt;。  &lt;ul&gt;
&lt;li&gt;若每單位時間內，水管孔徑只能容納&lt;span class="math"&gt;\(5\)&lt;/span&gt;單位，那&lt;strong&gt;flow&lt;/strong&gt;最多就是&lt;span class="math"&gt;\(5\)&lt;/span&gt;單位。&lt;/li&gt;
&lt;li&gt;以圖二(b)為例，在&lt;span class="math"&gt;\(Path:S-A-C-D-T\)&lt;/span&gt;上的edge之&lt;strong&gt;capacity&lt;/strong&gt;皆大於&lt;span class="math"&gt;\(6\)&lt;/span&gt;，因此在此路徑上流入&lt;span class="math"&gt;\(6\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;是可行的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Skew symmetry&lt;/strong&gt;：若定義「從vertex(X)指向vertex(Y)」之edge(X,Y)上，有&lt;span class="math"&gt;\(5\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;，&lt;span class="math"&gt;\(f(X,Y)=5\)&lt;/span&gt;，這就等價於，從vertex(Y)到vertex(X)之edge(Y,X)上，有&lt;span class="math"&gt;\(-5\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;，&lt;span class="math"&gt;\(f(Y,X)=-5\)&lt;/span&gt;。&lt;ul&gt;
&lt;li&gt;與「電子流(負電荷)」與「電流(正電荷)」之概念雷同，從「左到右的電流」與「從右到左的電子流」具有等價的物理意義。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flow conservation&lt;/strong&gt;：對Graph中除了&lt;strong&gt;source&lt;/strong&gt;與&lt;strong&gt;sink&lt;/strong&gt;以外的vertex(X)而言，所有「流進&lt;strong&gt;flow&lt;/strong&gt;」之總和要等於所有「流出&lt;strong&gt;flow&lt;/strong&gt;」的總和。  &lt;ul&gt;
&lt;li&gt;也就是水流不會無故增加或無故減少，可視為一種&lt;strong&gt;能量守恆&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;以圖二(b)為例，流入vertex(A)的&lt;strong&gt;flow&lt;/strong&gt;為&lt;span class="math"&gt;\(6\)&lt;/span&gt;，流出vertex(A)的&lt;strong&gt;flow&lt;/strong&gt;也是&lt;span class="math"&gt;\(6\)&lt;/span&gt;，對vertex(C)、vertex(D)也是。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ff"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Ford-Fulkerson Algorithm&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Ford-Fulkerson Algorithm&lt;/strong&gt;需要兩個輔助工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Residual Networks&lt;/strong&gt;(剩餘網路)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Augmenting Paths&lt;/strong&gt;(增廣路徑)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="residual"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Residual Networks(剩餘網路)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Residual Networks&lt;/strong&gt;的概念為，記錄Graph上之edge還有多少「剩餘的容量」可以讓&lt;strong&gt;flow&lt;/strong&gt;流過。  &lt;/p&gt;
&lt;p&gt;以圖三(a)為例，若在&lt;span class="math"&gt;\(Path:S-A-C-D-T\)&lt;/span&gt;上的所有edge都有&lt;span class="math"&gt;\(6\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;流過，那麼這些edge(edge(S,A)、edge(A,C)、edge(C,D)、edge(D,T))的可用「剩餘&lt;strong&gt;capacity&lt;/strong&gt;」，都應該要「減&lt;span class="math"&gt;\(6\)&lt;/span&gt;」，例如，edge(S,A)只能「再容納&lt;span class="math"&gt;\(9-6=3\)&lt;/span&gt;單位」的&lt;strong&gt;flow&lt;/strong&gt;，edge(C,D)只能「再容納&lt;span class="math"&gt;\(7-6=1\)&lt;/span&gt;單位」的&lt;strong&gt;flow&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;這些「剩餘&lt;strong&gt;capacity&lt;/strong&gt;」就稱為&lt;strong&gt;residual capacity&lt;/strong&gt;，以&lt;span class="math"&gt;\(c_f\)&lt;/span&gt;表示。&lt;br /&gt;
若edge(X,Y)上有&lt;strong&gt;flow&lt;/strong&gt;流過，&lt;span class="math"&gt;\(f(X,Y)\)&lt;/span&gt;，便將edge(X,Y)上的&lt;strong&gt;residual capacity&lt;/strong&gt;定義為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(X,Y)=c(X,Y)-f(X,Y)\)&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c(X,Y)\)&lt;/span&gt;為原來水管孔徑大小；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(f(X,Y)\)&lt;/span&gt;表示目前水管已經有多少流量；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(X,Y)\)&lt;/span&gt;表示水管還能再容納多少流量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Residual Networks&lt;/strong&gt;也是一個directed graph，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vertex集合與原directed graph完全相同；&lt;/li&gt;
&lt;li&gt;edge之&lt;strong&gt;capacity&lt;/strong&gt;以&lt;strong&gt;residual capacity&lt;/strong&gt;取代，見圖三(a)右。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最關鍵的是，若「從vertex(A)指向vertex(C)」之edge(A,C)上，有&lt;span class="math"&gt;\(6\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;流過，&lt;span class="math"&gt;\(f(A,C)=6\)&lt;/span&gt;，那麼在其&lt;strong&gt;Residual Networks&lt;/strong&gt;上，會因應產生出一條「從vertex(C)指向vertex(A)」的edge(C,A)，並具有&lt;span class="math"&gt;\(6\)&lt;/span&gt;單位的&lt;strong&gt;residual capacity&lt;/strong&gt;，&lt;span class="math"&gt;\(c_f(C,A)=6\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為&lt;strong&gt;Skew symmetry&lt;/strong&gt;，&lt;span class="math"&gt;\(f(C,A)=-f(A,C)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;再根據定義，&lt;span class="math"&gt;\(c_f(C,A)=c(C,A)-f(C,A)=c(C,A)+f(A,C)=0+6=6\)&lt;/span&gt;，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其物理意義呢？可以用「如果想要重新配置水流方向」來理解。&lt;/p&gt;
&lt;p&gt;舉例來說，如果現在想經過&lt;span class="math"&gt;\(Path:S-C-A-B-T\)&lt;/span&gt;流過&lt;span class="math"&gt;\(2\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;，若觀察最一開始「還沒有&lt;strong&gt;flow&lt;/strong&gt;經過」的directed graph(圖二(a))，其實並不存在從vertex(C)指向vertex(A)的edge(C,A)，因此&lt;span class="math"&gt;\(c(C,A)=0\)&lt;/span&gt;，但是因為在圖三(a)已經有&lt;span class="math"&gt;\(6\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;從vertex(A)流向vertex(C)，使得現在可以從edge(A,C)上把&lt;span class="math"&gt;\(2\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;「收回」，轉而分配到edge(A,B)上，而edge(A,C)上，就剩下&lt;span class="math"&gt;\(4\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;，最後的結果如圖三(b)左所示。&lt;br /&gt;
在新增一條「增加&lt;strong&gt;flow&lt;/strong&gt;的Path」後，&lt;strong&gt;Residual Networks&lt;/strong&gt;更新如圖三(b)右。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過圖三(a)以及圖三(b)之後，流入&lt;strong&gt;sink&lt;/strong&gt;(或稱&lt;strong&gt;termination&lt;/strong&gt;)的&lt;strong&gt;flow&lt;/strong&gt;累加到&lt;span class="math"&gt;\(8\)&lt;/span&gt;單位。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="aug"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Augmenting Paths(增廣路徑)&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;Residual Networks&lt;/strong&gt;裡，所有能夠「從&lt;strong&gt;source&lt;/strong&gt;走到&lt;strong&gt;termination&lt;/strong&gt;」的路徑，也就是所有能夠「增加&lt;strong&gt;flow&lt;/strong&gt;的path」，就稱為&lt;strong&gt;Augmenting Paths&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若以圖四(a)的&lt;strong&gt;Residual Networks&lt;/strong&gt;為例，見圖四(b)，&lt;strong&gt;Augmenting Paths&lt;/strong&gt;有許多可能，例如：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:S-A-B-T\)&lt;/span&gt;，&lt;span class="math"&gt;\(3\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;因為在路徑上，所有edge中最小的&lt;strong&gt;capacity&lt;/strong&gt;為&lt;span class="math"&gt;\(c(A,B)=3\)&lt;/span&gt;，因此，&lt;strong&gt;flow&lt;/strong&gt;可以容許從&lt;span class="math"&gt;\(1\)&lt;/span&gt;單位到&lt;span class="math"&gt;\(3\)&lt;/span&gt;單位。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:S-C-B-D-T\)&lt;/span&gt;，&lt;span class="math"&gt;\(2\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;同理，因為在路徑上，所有edge中最小的&lt;strong&gt;capacity&lt;/strong&gt;為&lt;span class="math"&gt;\(c(B,D)=c(D,T)=2\)&lt;/span&gt;，因此，&lt;strong&gt;flow&lt;/strong&gt;可以容許&lt;span class="math"&gt;\(1\)&lt;/span&gt;單位或&lt;span class="math"&gt;\(2\)&lt;/span&gt;單位。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以及其他。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;綜合以上可以確定，以圖四(c)為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若要看當前流入&lt;strong&gt;termination&lt;/strong&gt;的「總流量」，要在圖四(c)左，edge上標示「flow/capacity」的Graph上找。&lt;ul&gt;
&lt;li&gt;如圖四(c)，流入vertex(T)的&lt;strong&gt;總flow&lt;/strong&gt;為&lt;span class="math"&gt;\(8\)&lt;/span&gt;單位。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若要找「還能夠增加多少流量」，也就是找&lt;strong&gt;Augmenting Paths&lt;/strong&gt;，需要在&lt;strong&gt;Residual Networks&lt;/strong&gt;上找，如圖四(c)右。&lt;ul&gt;
&lt;li&gt;若在&lt;span class="math"&gt;\(Path:S-A-B-T\)&lt;/span&gt;、&lt;span class="math"&gt;\(Path:S-A-C-D-T\)&lt;/span&gt;、&lt;span class="math"&gt;\(Path:S-C-B-T\)&lt;/span&gt;流入「不超過該路徑上最低&lt;strong&gt;residual capacity&lt;/strong&gt;」之&lt;strong&gt;flow&lt;/strong&gt;，都是圖四(c)上的&lt;strong&gt;Augmenting Paths&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f5_1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;演算法概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Ford-Fulkerson Algorithm&lt;/strong&gt;(若使用&lt;strong&gt;BFS&lt;/strong&gt;搜尋路徑，又稱為&lt;strong&gt;Edmonds-Karp Algorithm&lt;/strong&gt;的方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;Residual Networks&lt;/strong&gt;上尋找&lt;strong&gt;Augmenting Paths&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;若以&lt;code&gt;BFS()&lt;/code&gt;尋找，便能確保每次找到的&lt;strong&gt;Augmenting Paths&lt;/strong&gt;一定經過「最少的edge」。&lt;/li&gt;
&lt;li&gt;找到&lt;strong&gt;Augmenting Paths&lt;/strong&gt;上的「最小&lt;strong&gt;residual capacity&lt;/strong&gt;」加入&lt;strong&gt;總flow&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;再以「最小&lt;strong&gt;residual capacity&lt;/strong&gt;」更新&lt;strong&gt;Residual Networks&lt;/strong&gt;上的edge之&lt;strong&gt;residual capacity&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重複上述步驟，直到再也沒有&lt;strong&gt;Augmenting Paths&lt;/strong&gt;為止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;便能找到&lt;strong&gt;Maximum Flow&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以圖二(a)之&lt;strong&gt;Flow Networks&lt;/strong&gt;作為範例，尋找&lt;strong&gt;Maximum Flow&lt;/strong&gt;之步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先以「&lt;strong&gt;flow&lt;/strong&gt;為零」對&lt;strong&gt;residual networks&lt;/strong&gt;進行初始化，如圖五(a)。&lt;br /&gt;
觀察後發現，&lt;strong&gt;G&lt;sub&gt;f&lt;/sub&gt;&lt;/strong&gt;就是&lt;strong&gt;Adjacency Matrix&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;G&lt;sub&gt;f&lt;/sub&gt;&lt;/strong&gt;上，以&lt;code&gt;BFS()&lt;/code&gt;找到能夠從vertex(S)走到vertex(T)，且「egde數最少」的路徑：&lt;span class="math"&gt;\(Path:S-A-B-T\)&lt;/span&gt;，見圖五(b)。&lt;ul&gt;
&lt;li&gt;根據「Graph上建立vertex的順序」，&lt;code&gt;BFS()&lt;/code&gt;有可能找到都是&lt;span class="math"&gt;\(3\)&lt;/span&gt;條edge的&lt;span class="math"&gt;\(Path:S-A-B-T\)&lt;/span&gt;或是&lt;span class="math"&gt;\(Path:S-C-D-T\)&lt;/span&gt;。這裡以前者為例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;觀察&lt;span class="math"&gt;\(Path:S-A-B-T\)&lt;/span&gt;上之edge，發現edge(A,B)具有「最小&lt;strong&gt;residual capacity&lt;/strong&gt;」，&lt;span class="math"&gt;\(c_f(A,B)=3\)&lt;/span&gt;，便更新「總&lt;strong&gt;flow&lt;/strong&gt;新增&lt;span class="math"&gt;\(3\)&lt;/span&gt;」。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;G&lt;sub&gt;f&lt;/sub&gt;&lt;/strong&gt;上，更新edge之&lt;strong&gt;residual capacity&lt;/strong&gt;，見圖五(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(S,A)=c(S,A)-f(S,A)=9-3=6\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(A,S)=c(A,S)-f(A,S)=0+3=3\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(A,B)=c(A,B)-f(A,B)=3-3=0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(B,A)=c(B,A)-f(B,A)=0+3=3\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(B,T)=c(B,T)-f(B,T)=9-3=6\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(T,B)=c(T,B)-f(T,B)=0+3=3\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;G&lt;sub&gt;f&lt;/sub&gt;&lt;/strong&gt;上，以&lt;code&gt;BFS()&lt;/code&gt;找到能夠從vertex(S)走到vertex(T)，且「egde數最少」的路徑：&lt;span class="math"&gt;\(Path:S-C-D-T\)&lt;/span&gt;，見圖五(d)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;觀察&lt;span class="math"&gt;\(Path:S-A-B-T\)&lt;/span&gt;上之edge，發現edge(C,D)具有「最小&lt;strong&gt;residual capacity&lt;/strong&gt;」，&lt;span class="math"&gt;\(c_f(C,D)=7\)&lt;/span&gt;，便更新「總&lt;strong&gt;flow&lt;/strong&gt;新增&lt;span class="math"&gt;\(7\)&lt;/span&gt;」。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;G&lt;sub&gt;f&lt;/sub&gt;&lt;/strong&gt;上，更新edge之&lt;strong&gt;residual capacity&lt;/strong&gt;，見圖五(e)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(S,C)=c(S,C)-f(S,C)=9-7=2\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(C,S)=c(C,S)-f(C,S)=0+7=7\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(C,D)=c(C,D)-f(C,D)=7-7=0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(D,C)=c(D,C)-f(D,C)=0+7=7\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(D,T)=c(D,T)-f(D,T)=8-7=1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(c_f(T,D)=c(T,D)-f(T,D)=0+7=7\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(e)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著繼續重複上述步驟：「更新&lt;strong&gt;Residual Networks&lt;/strong&gt;，尋找&lt;strong&gt;Augmenting Paths&lt;/strong&gt;」，見圖五(f)-(l)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(f)：找到&lt;span class="math"&gt;\(Path:S-C-B-T\)&lt;/span&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(g)：更新Residual Networks。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(h)：找到&lt;span class="math"&gt;\(Path:S-A-C-B-T\)&lt;/span&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(i)：更新Residual Networks。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(j)：找到&lt;span class="math"&gt;\(Path:S-A-C-B-D-T\)&lt;/span&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(k)：更新Residual Networks。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(l)：找到Maximum Flow。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;當執行到圖五(l)，在&lt;strong&gt;Residual Networks&lt;/strong&gt;上再也找不到任何一條&lt;strong&gt;Augmenting Paths&lt;/strong&gt;，便完成演算法。&lt;br /&gt;
&lt;strong&gt;Maximum Flow&lt;/strong&gt;為&lt;span class="math"&gt;\(17\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;程式碼包含幾個部分：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Graph_FlowNetWorks&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;AdjMatrix&lt;/code&gt;建立Graph，並利用&lt;code&gt;AdjMatrix[X][Y]&lt;/code&gt;儲存edge(X,Y)的weight。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BFSfindExistingPath()&lt;/code&gt;：利用&lt;strong&gt;Breadth-First Search&lt;/strong&gt;尋找「從&lt;strong&gt;source&lt;/strong&gt;走到&lt;strong&gt;termination&lt;/strong&gt;」的路徑，而且是edge數最少的路徑。&lt;ul&gt;
&lt;li&gt;關於&lt;strong&gt;Breadth-First Search&lt;/strong&gt;，請參考&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FordFulkerson()&lt;/code&gt;：進行&lt;strong&gt;Ford-Fulkerson Algorithm&lt;/strong&gt;的主要函式，內容如前一小節所述。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MinCapacity()&lt;/code&gt;：用來找到從&lt;code&gt;BFSfindExistingPath()&lt;/code&gt;找到的路徑上，最小的&lt;strong&gt;residual capacity&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;：建立如圖二(a)之&lt;code&gt;AdjMatrix&lt;/code&gt;，並進行&lt;code&gt;FordFulkerson()&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;FordFulkerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;termination&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;BFSfindExistingPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;graphResidual&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                             &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;termination&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;MinCapacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;graphResidual&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;termination&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// constructor&lt;/span&gt;
    &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BFSfindExistingPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                                             &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 0 表示還沒有被找到&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// BFS 從 s 開始, 也可以規定s一律訂成vertex(0)&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;exploring&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;exploring&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exploring&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 若t有被visited, 表示有path從s到t&lt;/span&gt;
                                &lt;span class="c1"&gt;// 也可以用 if (predecessor[t] != -1) 判斷&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;MinCapacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                                    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 確保min會更新, 假設graph上的capacity都小於100&lt;/span&gt;

    &lt;span class="c1"&gt;// 用predecessor[idx] 和 idx 表示一條edge&lt;/span&gt;
    &lt;span class="c1"&gt;// 找到在從s到t的path上, capacity最小的值, 存入min&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]][&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]][&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]][&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FordFulkerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;termination&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="c1"&gt;// residual networks的初始狀態等於AdjMatrix, 見圖五(a)&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;graphResidual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxflow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                           
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="c1"&gt;// BFS finds augmenting path,&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BFSfindExistingPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graphResidual&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;termination&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mincapacity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MinCapacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graphResidual&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;termination&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;maxflow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;maxflow&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;mincapacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;termination&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;]){&lt;/span&gt;
            &lt;span class="c1"&gt;// 更新 residual graph&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;graphResidual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;mincapacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;graphResidual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;mincapacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Possible Maximum Flow: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;maxflow&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph_FlowNetWorks&lt;/span&gt; &lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g11&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FordFulkerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 指定source為vertex(0), termination為vertex(5)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Possible&lt;/span&gt; &lt;span class="n"&gt;Maximum&lt;/span&gt; &lt;span class="nl"&gt;Flow&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;結果與圖五(k)相同。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt; 
&lt;a name="bfs"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;利用BFS的優點&lt;/h2&gt;
&lt;p&gt;若在&lt;strong&gt;Residual Networks&lt;/strong&gt;尋找&lt;strong&gt;Augmenting Paths&lt;/strong&gt;的方法中，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;沒有用上&lt;strong&gt;BFS&lt;/strong&gt;，稱為&lt;strong&gt;Ford-Fulkerson Algorithm&lt;/strong&gt;，時間複雜度&lt;span class="math"&gt;\(O(E|f|)\)&lt;/span&gt;。&lt;ul&gt;
&lt;li&gt;其中，&lt;span class="math"&gt;\(E\)&lt;/span&gt;為Graph上的edge數；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(|f|\)&lt;/span&gt;為「最大流量」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有用上&lt;strong&gt;BFS&lt;/strong&gt;，稱為&lt;strong&gt;Edmonds-Karp Algorithm&lt;/strong&gt;，時間複雜度&lt;span class="math"&gt;\(O(VE^2)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顯然，使用&lt;strong&gt;BFS&lt;/strong&gt;的優勢在於時間複雜度。&lt;br /&gt;
嚴謹證明請參考&lt;a href="https://people.cs.umass.edu/~barring/cs611/lecture/11.pdf"&gt;David Mix Barrington：The Edmonds-Karp Heuristic&lt;/a&gt;。&lt;br /&gt;
以下僅以一個簡單的例子，奉勸讀者使用&lt;strong&gt;BFS&lt;/strong&gt;沒有害處。&lt;/p&gt;
&lt;p&gt;以圖六(a)為例，若使用&lt;strong&gt;BFS&lt;/strong&gt;，&lt;strong&gt;Maximum Flow&lt;/strong&gt;只需要「找兩次」&lt;strong&gt;Augmenting Paths&lt;/strong&gt;，&lt;span class="math"&gt;\(Path:S-A-T\)&lt;/span&gt;以及&lt;span class="math"&gt;\(Path:S-C-T\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;但如果使用&lt;strong&gt;DFS()&lt;/strong&gt;或其他方法，很有可能找到&lt;span class="math"&gt;\(Path:S-A-C-T\)&lt;/span&gt;，因為edge(A,C)的&lt;strong&gt;capacity&lt;/strong&gt;只有&lt;span class="math"&gt;\(1\)&lt;/span&gt;，&lt;span class="math"&gt;\(c(A,C)=1\)&lt;/span&gt;，便限制了每單位時間的流量，見圖六(b)。&lt;/p&gt;
&lt;p&gt;若不幸，在下一次挑選&lt;strong&gt;Augmenting Paths&lt;/strong&gt;時，選到&lt;span class="math"&gt;\(Path:S-C-A-T\)&lt;/span&gt;，又只能流入&lt;span class="math"&gt;\(1\)&lt;/span&gt;單位的&lt;strong&gt;flow&lt;/strong&gt;。&lt;br /&gt;
若每次都挑選到&lt;strong&gt;capacity&lt;/strong&gt;只有&lt;span class="math"&gt;\(1\)&lt;/span&gt;的edge，那麼，總共尋找&lt;strong&gt;Augmenting Paths&lt;/strong&gt;的次數恰等於「&lt;strong&gt;總flow&lt;/strong&gt;」的量，以圖六(b)為例，需要找&lt;span class="math"&gt;\(20000\)&lt;/span&gt;次&lt;strong&gt;Augmenting Paths&lt;/strong&gt;，不算有效率的方法。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Flow_Networks_fig/Maximum_Flow/f21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是&lt;strong&gt;Ford-Fulkerson Algorithm&lt;/strong&gt;(說是&lt;strong&gt;Edmonds-Karp Algorithm&lt;/strong&gt;也可以)的介紹。&lt;br /&gt;
關於&lt;strong&gt;Maximum Flow&lt;/strong&gt;的應用，請參考&lt;a href="https://en.wikipedia.org/wiki/Maximum_flow_problem#Application"&gt;Wikipedia：Maximum flow problem&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch26&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=hmIrJCGPPG4"&gt;LILD：Ford Fulkerson algorithm for Max Flow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/"&gt;GeeksforGeeks：Ford-Fulkerson Algorithm for Maximum Flow Problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://people.cs.umass.edu/~barring/cs611/lecture/11.pdf"&gt;David Mix Barrington：The Edmonds-Karp Heuristic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Maximum_flow_problem#Application"&gt;Wikipedia：Maximum flow problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mropengate.blogspot.tw/2015/01/algorithm-ch4-network-flow.html"&gt;Mr. Opengate：Algorithm - Ch5 網路流 與 最大流最小割定理 Network Flow and Maximum Flow Minimum Cut Theorem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&amp;amp;file=f3cec71910d4a0106624e839f2891b17198ef58be"&gt;CK6125姜俊宇：網路流(Network Flow)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Flow Networks系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/flow-networksmaximum-flow-ford-fulkerson-algorithm.html"&gt;Flow Networks：Maximum Flow &amp;amp; Ford-Fulkerson Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Flow Networks"></category><category term="Intro"></category><category term="BFS"></category><category term="Edmonds-Karp Algorithm"></category></entry><entry><title>All-Pairs Shortest Path：Floyd-Warshall Algorithm</title><link href="http://alrightchiu.github.io/SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html" rel="alternate"></link><updated>2016-03-14T18:10:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-14:SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將介紹&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;來解決&lt;strong&gt;All-Pairs Shortest Path&lt;/strong&gt;問題。  &lt;/p&gt;
&lt;p&gt;由於是&lt;strong&gt;All Pairs&lt;/strong&gt;，每個vertex都將視為起點，尋找以該vertex走到其他vertex之最短路徑，可以想見，在&lt;strong&gt;Single-Source Shortest Path&lt;/strong&gt;中使用的一維矩陣&lt;code&gt;distance[]&lt;/code&gt;與&lt;code&gt;predecessor[]&lt;/code&gt;，需要再增加一個維度成二維矩陣，以&lt;code&gt;Distance[][]&lt;/code&gt;與&lt;code&gt;Predecessor[][]&lt;/code&gt;表示。&lt;br /&gt;
連帶地，在建立Graph時，也將使用&lt;strong&gt;Adjacency Matrix&lt;/strong&gt;，並以其陣列元素值代表edge之weight。&lt;br /&gt;
(這並不表示不能使用&lt;strong&gt;Adjacency List&lt;/strong&gt;實現，只是較為費工。)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#ss"&gt;若使用Single-Source Shortest Path之演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#floyd"&gt;Floyd-Warshall Algorithm&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#inter"&gt;引入中繼點(intermediate vertex)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#explain"&gt;以數學符號表示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#example"&gt;觀察Distance與Predecessor的變化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Shortest Path系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ss"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;若使用Single-Source Shortest Path之演算法&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathintrojian-jie.html"&gt;Single-Source Shortest Path：Intro(簡介)&lt;/a&gt;曾經提過，用&lt;strong&gt;Single-Source Shortest Path&lt;/strong&gt;之演算法其實也可以應付&lt;strong&gt;All-Pairs Shortest Path&lt;/strong&gt;問題，只要把每一個vertex都當做起點，找一次&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;(或者&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;)，就能得到Graph中「從每一個vertex到達其餘vertex之最短路徑」，可惜效能卻不能盡如人意。  &lt;/p&gt;
&lt;p&gt;上述提到的兩種演算法之時間複雜度如表一：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Bellman-Ford&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;Dijkstra(worst)&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;Dijkstra(best)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(VE)\)&lt;/span&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(E+V^2)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(E+V\log V)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：兩種演算法解決&lt;/strong&gt;Single-Source Shortest Path&lt;strong&gt;之時間複雜度&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若再加上「以每個vertex為起點」的運算成本，更新成表二：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Bellman-Ford&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;Dijkstra(worst)&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;Dijkstra(best)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(V^2E)\)&lt;/span&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(EV+V^3)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(EV+V^2\log V)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表二：兩種演算法解決&lt;/strong&gt;All-Pairs Shortest Path&lt;strong&gt;之時間複雜度&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;還有一個條件：觀察&lt;strong&gt;Adjacency Matrix&lt;/strong&gt;發現，edge最多的情況，即為矩陣中除了對角線(diagonal)為&lt;span class="math"&gt;\(0\)&lt;/span&gt;，其餘皆有值的情況，因此edge數目&lt;span class="math"&gt;\(E\)&lt;/span&gt;與vertex數目&lt;span class="math"&gt;\(V\)&lt;/span&gt;應具有以下關係：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(E=O(V^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;將此關係代入表二，形成表三：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Bellman-Ford&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;Dijkstra(worst)&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;Dijkstra(best)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(V^4)\)&lt;/span&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(V^3+V^3)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(V^3+V^2\log V)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表三：兩種演算法解決&lt;/strong&gt;All-Pairs Shortest Path&lt;strong&gt;之時間複雜度&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據表三，成本最高的情況發生在&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;，需要&lt;span class="math"&gt;\(O(V^4)\)&lt;/span&gt;的成本，而&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;雖然非常有效率，只需要&lt;span class="math"&gt;\(O(V^3)\)&lt;/span&gt;，但是不要忘記，唯有Graph中不存在具有negative weight的edge時，才可使用&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;，這將是一大限制。&lt;/p&gt;
&lt;p&gt;而本篇文章將要介紹的&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;，適用的情況只需要「Graph中不存在&lt;strong&gt;negative cycle&lt;/strong&gt;」，即可在時間複雜度&lt;span class="math"&gt;\(O(V^3)\)&lt;/span&gt;完成。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="floyd"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Floyd-Warshall Algorithm&lt;/h2&gt;
&lt;p&gt;&lt;a name="inter"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;引入中繼點(intermediate vertex)&lt;/h3&gt;
&lt;p&gt;若用一句含有逗點的話來描述&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;的精髓，應該可以這麼說：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次多加入一個「&lt;strong&gt;中繼點(intermediate vertex)&lt;/strong&gt;」，考慮從vertex(X)走向vertex(Y)的最短路徑，是否因為經過了該中繼點vertex(Z)而降低成本，形成新的最短路徑。  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中繼點&lt;/strong&gt;就是「允許被路徑經過」的vertex。 &lt;/li&gt;
&lt;li&gt;若原先的最短路徑是&lt;span class="math"&gt;\(Path:X-Y\)&lt;/span&gt;，在引入&lt;strong&gt;中繼點&lt;/strong&gt;vertex(Z)後，最短路徑就有兩種可能，&lt;span class="math"&gt;\(Path:X-Y\)&lt;/span&gt;或者&lt;span class="math"&gt;\(Path:X-Z-Y\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
先看個簡單的例子，感受一下&lt;strong&gt;中繼點(intermediate vertex)&lt;/strong&gt;究竟為何物。&lt;/p&gt;
&lt;p&gt;以圖二(a)的Graph為例，其滿足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不包含&lt;strong&gt;negative cycle&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(允許)含有&lt;strong&gt;positive cycle&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(允許)edge具有&lt;strong&gt;negative weight&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要找到從vertex(A)走到vertex(D)的最短路徑。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在概念上，引入兩個集合會較容易理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;集合K&lt;/strong&gt;：由所有&lt;strong&gt;中繼點&lt;/strong&gt;形成的集合。&lt;ul&gt;
&lt;li&gt;當演算法剛開始，Graph的「每一個vertex」都在&lt;strong&gt;K&lt;/strong&gt;裏面。&lt;/li&gt;
&lt;li&gt;隨著演算法的進行，vertex將逐一從&lt;strong&gt;集合K&lt;/strong&gt;中被移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合S&lt;/strong&gt;：只有與「存在&lt;strong&gt;集合S&lt;/strong&gt;裡面的vertex」相連的edge，才會被納入尋找最短路徑的討論。隨著演算法進行，會不停從&lt;strong&gt;集合K&lt;/strong&gt;挑選vertex放進&lt;strong&gt;集合S&lt;/strong&gt;，尋找新的最短路徑。&lt;ul&gt;
&lt;li&gt;舉例來說，若要找到圖二(a)的Graph中，從vertex(A)走到vertex(D)的最短路徑，若&lt;strong&gt;集合S&lt;/strong&gt;裡面只有vertex(A)、vertex(B)、vertex(D)，那麼就只能考慮由「edge(A,B)、edge(A,D)、edge(B,D)」形成的路徑，以其中的最短路徑為最後結果(這時候的最短路徑只能算是「當前找到」的最短路徑，未必是最後結果)。&lt;/li&gt;
&lt;li&gt;特別注意，&lt;strong&gt;集合S&lt;/strong&gt;的作用是找到「某個vertex(X)走到某個vertex(Y)」的最短路徑，因此，即使「加入的中繼點」都相同，但是起點與終點必定不同，所以不同的「起點vertex(X)與終點vertex(Y)」之組合，都有各自的&lt;strong&gt;集合S&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;從vertex(A)走到vertex(D)，起始狀態的&lt;strong&gt;集合S&lt;/strong&gt;為&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A,D\)&lt;/span&gt;}，加入中繼點vertex(B)後，更新成&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A,B,D\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;從vertex(C)走到vertex(D)，起始狀態的&lt;strong&gt;集合S&lt;/strong&gt;為&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(C,D\)&lt;/span&gt;}，加入中繼點vertex(B)後，更新成&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(B,C,D\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;
見圖二(b)，「初始狀態」指的是「尚未加入任何中繼點進入&lt;strong&gt;集合S&lt;/strong&gt;」，因此&lt;strong&gt;集合K&lt;/strong&gt;應包含所有vertex，&lt;span class="math"&gt;\(K=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A,B,C,D\)&lt;/span&gt;}。&lt;/p&gt;
&lt;p&gt;因為沒有任何中繼點，對所有的「起點-終點」組合而言，&lt;strong&gt;集合S&lt;/strong&gt;都只有起點vertex(X)與終點vertex(Y)，而最短路徑有兩種可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若存在edge(X,Y)，最短路徑必定是edge(X,Y)；&lt;/li&gt;
&lt;li&gt;若不存在edge(X,Y)，那麼兩者的距離為「無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)」。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;考慮圖二(b)，從vertex(A)走到vertex(D)的最短路徑就是經過edge(A,D)的&lt;span class="math"&gt;\(Path:A-D\)&lt;/span&gt;，成本為&lt;span class="math"&gt;\(8\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時「從vertex(A)走到vertex(D)」的&lt;strong&gt;集合S&lt;/strong&gt;為&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A,D\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;若考慮的是「從vertex(C)走到vertex(B)」的問題，此時&lt;strong&gt;集合S&lt;/strong&gt;為&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(B,C\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;
接著，依序從&lt;strong&gt;集合K&lt;/strong&gt;中，讀取vertex(A)、vertex(B)、vertex(C)、vertex(D)作為中繼點，加入&lt;strong&gt;集合S&lt;/strong&gt;，並考慮所有由「&lt;strong&gt;集合S&lt;/strong&gt;中的vertex互相相連的edge」形成的路徑，找到其中的最短路徑。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;首先加入vertex(A)作為&lt;strong&gt;中繼點&lt;/strong&gt;，見圖二(c)左：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;集合S&lt;/strong&gt;沒有更新，仍是&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A,D\)&lt;/span&gt;}，因此，所有路徑中的最短路徑仍然是&lt;span class="math"&gt;\(Path:A-D\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合K&lt;/strong&gt;更新成&lt;span class="math"&gt;\(K=\)&lt;/span&gt;{&lt;span class="math"&gt;\(B,C,D\)&lt;/span&gt;}，也就是說，除了vertex(D)為終點vertex，其餘的vertex(B)、vertex(C)都不能被路徑經過。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著加入vertex(B)作為&lt;strong&gt;中繼點&lt;/strong&gt;，見圖二(c)右：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;集合S&lt;/strong&gt;更新成&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A,B,D\)&lt;/span&gt;}；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合K&lt;/strong&gt;更新成&lt;span class="math"&gt;\(K=\)&lt;/span&gt;{&lt;span class="math"&gt;\(C,D\)&lt;/span&gt;}，亦即，除了vertex(D)為終點，vertex(C)不能被路徑經過。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據是否經過中繼點vertex(B)，所有能夠「從vertex(A)走到vertex(D)」的路徑共有兩條：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:A-D\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(8\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:A-B-D\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(5\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;於是更新「當前的最短路徑」為&lt;span class="math"&gt;\(Path:A-B-D\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;繼續加入vertex(C)作為&lt;strong&gt;中繼點&lt;/strong&gt;，見圖二(d)左：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;集合S&lt;/strong&gt;更新成&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A,B,C,D\)&lt;/span&gt;}；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合K&lt;/strong&gt;更新成&lt;span class="math"&gt;\(K=\)&lt;/span&gt;{&lt;span class="math"&gt;\(D\)&lt;/span&gt;}。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有能夠「從vertex(A)走到vertex(D)」的路徑共有數條(因為出現&lt;strong&gt;cycle&lt;/strong&gt;)：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:A-D\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(8\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:A-B-D\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(5\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:A-C-D\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(7\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:A-B-C-D\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;所有包含&lt;strong&gt;cycle&lt;/strong&gt;&lt;span class="math"&gt;\(:A-B-C-A\)&lt;/span&gt;的路徑，成本一定大於&lt;span class="math"&gt;\(4\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以找到「當前的最短路徑」為&lt;span class="math"&gt;\(Path:A-B-C-D\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;最後，再加入vertex(D)作為&lt;strong&gt;中繼點&lt;/strong&gt;，如圖二(d)右，因為沒有更新&lt;strong&gt;集合S&lt;/strong&gt;，最短路徑維持&lt;span class="math"&gt;\(Path:A-B-C-D\)&lt;/span&gt;，此即為最終結果。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
最重要的是，&lt;span class="math"&gt;\(Path:A-B-C-D\)&lt;/span&gt;的形成，其實是由一段一段的&lt;strong&gt;subpath&lt;/strong&gt;慢慢接起來的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在「初始狀態」時，&lt;span class="math"&gt;\(Path:A-B\)&lt;/span&gt;、&lt;span class="math"&gt;\(Path:B-C\)&lt;/span&gt;、&lt;span class="math"&gt;\(Path:C-D\)&lt;/span&gt;就已經是最短路徑。&lt;/li&gt;
&lt;li&gt;當引入vertex(B)作為&lt;strong&gt;中繼點&lt;/strong&gt;時，對&lt;span class="math"&gt;\(Path:A-B-C-D\)&lt;/span&gt;的形成沒有影響。&lt;/li&gt;
&lt;li&gt;當引入vertex(C)作為&lt;strong&gt;中繼點&lt;/strong&gt;時，因為已經有最短路徑&lt;span class="math"&gt;\(Path:B-C\)&lt;/span&gt;以及&lt;span class="math"&gt;\(Path:C-D\)&lt;/span&gt;，便建立起從vertex(B)走到vertex(D)的最段路徑，&lt;span class="math"&gt;\(Path:B-C-D\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;最後，因為已經有最短路徑&lt;span class="math"&gt;\(Path:B-C-D\)&lt;/span&gt;，連同另一段最段路徑&lt;span class="math"&gt;\(Path:A-B\)&lt;/span&gt;，便能得到從vertex(A)走到vertex(D)的最短路徑，&lt;span class="math"&gt;\(Path:A-B-C-D\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更廣義的意義上，可以將以上步驟解讀成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在引入中繼點vertex(k)之前，已經找到「引入中繼點vertex(k-1)後，從vertex(i)走到vertex(j)」的最短路徑；&lt;/li&gt;
&lt;li&gt;在引入中繼點vertex(k-1)之前，已經找到「引入中繼點vertex(k-2)後，從vertex(i)走到vertex(j)」的最短路徑；&lt;/li&gt;
&lt;li&gt;依此類推。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;經由以上觀察，&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;的奧義就是「以較小段的最短路徑(subpath)，連結出最終的最短路徑」。    &lt;/p&gt;
&lt;p&gt;而其正確性的根據是最短路徑的&lt;strong&gt;結構特徵&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最短路徑是由較小段的最短路徑(subpath)所連結起來的。換句話說，由較小段的最短路徑(subpath)接起來的路徑必定仍然是最短路徑。&lt;br /&gt;
(參考：&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathintrojian-jie.html#property"&gt;Single-Source Shortest Path：Intro(簡介)&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著，將以上說明，以稍微嚴謹的數學符號表示。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="explain"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;以數學符號表示&lt;/h3&gt;
&lt;p&gt;現考慮，從vertex(i)走到vertex(j)，逐一引入&lt;strong&gt;中繼點&lt;/strong&gt;vertex(k)，欲尋找最短路徑。  &lt;/p&gt;
&lt;p&gt;定義，引入&lt;strong&gt;中繼點&lt;/strong&gt;vertex(k)後，「當前的最短路徑」之成本為&lt;span class="math"&gt;\(d^{(k)}_{ij}\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(d^{(k)}_{ij}\)&lt;/span&gt;為「已將&lt;strong&gt;集合K&lt;/strong&gt;{&lt;span class="math"&gt;\(1,2,3,...k\)&lt;/span&gt;}中的所有vertex作為&lt;strong&gt;中繼點&lt;/strong&gt;引入&lt;strong&gt;集合S&lt;/strong&gt;」後，從起點vertex(i)走到終點vertex(j)的路徑之成本。&lt;/li&gt;
&lt;li&gt;注意：引入&lt;strong&gt;中繼點&lt;/strong&gt;的順序以{&lt;span class="math"&gt;\(1,2,3,...k\)&lt;/span&gt;}表示，但實際上順序不重要，只要所有vertex都被當作&lt;strong&gt;中繼點&lt;/strong&gt;一次，而且是只有一次，即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於最短路徑不包含&lt;strong&gt;cycle&lt;/strong&gt;，每當引入一個&lt;strong&gt;中繼點&lt;/strong&gt;vertex(k)，只有兩種可能：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vertex(k)不在最短路徑上，&lt;span class="math"&gt;\(Path:i-...-j\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;vertex(k)位在最短路徑上，&lt;span class="math"&gt;\(Path:i-...-k-...-j\)&lt;/span&gt;；  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果是第一種情形，「vertex(k)不在最短路徑上」，最短路徑便維持&lt;span class="math"&gt;\(Path:i-...-j\)&lt;/span&gt;。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;維持的意思是，最短路徑是由「起點vertex(i)」、「終點vertex(j)」與「&lt;strong&gt;中繼點&lt;/strong&gt;{&lt;span class="math"&gt;\(1,2,...,k-1\)&lt;/span&gt;}」中的vertex構成；&lt;/li&gt;
&lt;li&gt;成本便滿足：&lt;span class="math"&gt;\(d^{(k)}_{ij}=d^{(k-1)}_{ij}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是第二種情形，「vertex(k)位在最短路徑上」，最短路徑又可以分成兩段：&lt;span class="math"&gt;\(SubPath:i-...-k\)&lt;/span&gt;，以及&lt;span class="math"&gt;\(SubPath:k-...-j\)&lt;/span&gt;，又因為這兩段subpath也是「考慮了&lt;strong&gt;集合K&lt;/strong&gt;{&lt;span class="math"&gt;\(1,2,3,...k-1\)&lt;/span&gt;}的vertex作為&lt;strong&gt;中繼點&lt;/strong&gt;引入&lt;strong&gt;集合S&lt;/strong&gt;」後得到的最短路徑，便保證&lt;span class="math"&gt;\(Path:i-...-k-...-j\)&lt;/span&gt;也會是最短路徑，其路徑成本滿足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(d^{(k)}_{ij}=d^{(k-1)}_{ik}+d^{(k-1)}_{kj}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;綜合以上，可以得到，引入&lt;strong&gt;中繼點&lt;/strong&gt;vertex(k)後，從vertex(i)走到vertex(j)的最短路徑之成本：&lt;/p&gt;
&lt;div class="math"&gt;$$
d^{(k)}_{ij}=
\begin{cases}
w_{ij}  &amp;amp; \text{if $k=0$}\\
\min(d^{(k-1)}_{ij},d^{(k-1)}_{ik}+d^{(k-1)}_{kj}) &amp;amp; \text{if $k\geq 1$}
\end{cases}
$$&lt;/div&gt;
&lt;p&gt;其中，&lt;span class="math"&gt;\(w_{ij}\)&lt;/span&gt;即為edge的weight。&lt;/p&gt;
&lt;p&gt;以&lt;span class="math"&gt;\(D\)&lt;/span&gt;表示&lt;code&gt;Distance[][]&lt;/code&gt;，則&lt;span class="math"&gt;\(D^{(k)}[i][j]=d^{(k)}_{ij}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
只要&lt;code&gt;Distance[][]&lt;/code&gt;被更新，也需要同時更新&lt;code&gt;Predecessor[][]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;比照&lt;span class="math"&gt;\(d^{(k)}_{ij}\)&lt;/span&gt;的定義，以&lt;span class="math"&gt;\(p^{(k)}_{ij}\)&lt;/span&gt;表示：「已將&lt;strong&gt;集合K&lt;/strong&gt;{&lt;span class="math"&gt;\(1,2,3,...k\)&lt;/span&gt;}中的所有vertex作為&lt;strong&gt;中繼點&lt;/strong&gt;引入&lt;strong&gt;集合S&lt;/strong&gt;」後，從起點vertex(i)走到終點vertex(j)的路徑上，&lt;strong&gt;vertex(j)的predecessor&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其數學式定義如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始狀態時，因為當只有edge(i,j)存在時，才存在一條路徑從vertex(i)走到vertex(j)，因此，&lt;span class="math"&gt;\(p^{(0)}_{ij}\)&lt;/span&gt;的初始狀態為：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$
p^{(0)}_{ij}=
\begin{cases}
NIL &amp;amp; \text{if $i=j$ or $w_{ij}=\infty$}\\
i &amp;amp; \text{if $i\neq j$ and $w_{ij}&amp;lt;\infty$}
\end{cases}
$$&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;當開始引入&lt;strong&gt;中繼點&lt;/strong&gt;vertex(k)後，&lt;span class="math"&gt;\(p^{(k)}_{ij}\)&lt;/span&gt;便如同&lt;span class="math"&gt;\(d^{(k)}_{ij}\)&lt;/span&gt;，需考慮是否因為vertex(k)所提供的edge更新了最短路徑，定義如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$
p^{(k)}_{ij}=  
\begin{cases}  
p^{(k-1)}_{ij} &amp;amp; \text{if $d^{(k-1)}_{ij}\leq d^{(k-1)}_{ik}+d^{(k-1)}_{kj}$}\\  
p^{(k-1)}_{kj} &amp;amp; \text{if $d^{(k-1)}_{ij}&amp;gt;d^{(k-1)}_{ik}+d^{(k-1)}_{kj}$}\\  
\end{cases}  
$$&lt;/div&gt;
&lt;p&gt;將&lt;code&gt;Predecessor[][]&lt;/code&gt;以&lt;span class="math"&gt;\(P\)&lt;/span&gt;表示，那麼&lt;span class="math"&gt;\(P^{(k)}[i][j]=p^{(k)}_{ij}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;由於&lt;code&gt;Predecessor[][]&lt;/code&gt;比較難理解，馬上以圖二(a)之Graph為例，看一次&lt;code&gt;Distance[][]&lt;/code&gt;與&lt;code&gt;Predecessor[][]&lt;/code&gt;的規則變化，並且解讀&lt;code&gt;Predecessor[][]&lt;/code&gt;攜帶的路徑訊息。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;觀察Distance與Predecessor的變化&lt;/h3&gt;
&lt;p&gt;圖三(a)到圖三(d)展示依序將vertex(A)、vertex(B)、vertex(C)、vertex(D)作為&lt;strong&gt;中繼點&lt;/strong&gt;，納入&lt;strong&gt;集合S&lt;/strong&gt;，考慮從vertex(A)到vertex(D)的最短路徑之過程。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖三(a)，表示「初始狀態」，只有當edge(X,Y)存在時，才存在vertex(X)到vertex(Y)的最短路徑，此時的兩項資料結構：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Distance&lt;/code&gt;等於&lt;code&gt;Adjacency Matrix&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;若存在edge(X,Y)，則&lt;code&gt;Distance[X][Y]&lt;/code&gt;即為edge(X,Y)之weight；&lt;/li&gt;
&lt;li&gt;若不存在edge(X,Y)，則&lt;code&gt;Distance[X][Y]&lt;/code&gt;等於「無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)」，表示無法從vertex(X)走到vertex(Y)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Predecessor&lt;/code&gt;記錄的是「被走到的vertex」的&lt;strong&gt;predecessor&lt;/strong&gt;，見圖三(a)：&lt;ul&gt;
&lt;li&gt;若存在edge(X,Y)，則「從vertex(X)走到vertex(Y)」的路徑在，確實是由「vertex(X)」走到vertex(Y)，因此&lt;code&gt;Predecessor[X][Y]&lt;/code&gt;即為vertex(X)：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Predecessor[A][C]=A&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Predecessor[C][D]=C&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若不存在edge(X,Y)，則以&lt;code&gt;NIL&lt;/code&gt;、&lt;code&gt;NULL&lt;/code&gt;或是&lt;span class="math"&gt;\(-1\)&lt;/span&gt;表示「vertex(Y)無法由vertex(X)走到」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖三(b)引入vertex(A)作為&lt;strong&gt;中繼點&lt;/strong&gt;，其中有兩點值得討論。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Path:C-A-B\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(6\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原本從vertex(C)無法走到vertex(B)，現在「vertex(A)可以被路徑經過」，因此「從vertex(C)走到vertex(B)」便能將&lt;span class="math"&gt;\(Path:C-A\)&lt;/span&gt;接上&lt;span class="math"&gt;\(Path:A-B\)&lt;/span&gt;，形成&lt;span class="math"&gt;\(Path:C-A-B\)&lt;/span&gt;，成本&lt;code&gt;Distance[C][B]&lt;/code&gt;更新為&lt;span class="math"&gt;\(6\)&lt;/span&gt;，比原本的無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)小，所以更新為「當前的最短路徑」。&lt;/li&gt;
&lt;li&gt;在&lt;span class="math"&gt;\(Path:C-A-B\)&lt;/span&gt;上，是由「vertex(A)」走到vertex(B)的，因此更新&lt;code&gt;Predecessor[C][B]=Predecessor[A][B]=A&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;從vertex(C)走到vertex(D)沒有更新：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在引入vertex(A)之後，從vertex(C)走到vertex(D)多了一條選擇：&lt;span class="math"&gt;\(Path:C-A-D\)&lt;/span&gt;，但是其成本為&lt;span class="math"&gt;\(12\)&lt;/span&gt;，比原本的&lt;span class="math"&gt;\(Path:C-D\)&lt;/span&gt;之成本&lt;span class="math"&gt;\(1\)&lt;/span&gt;還高，因此不更新路徑，維持&lt;span class="math"&gt;\(Path:C-D\)&lt;/span&gt;為「當前的最短路徑」。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Distance[C][D]=1&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Predecessor[C][D]=C&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根據以上兩種情形：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只要遇到更短的路徑就更新；&lt;/li&gt;
&lt;li&gt;若比當前的路徑之成本還高的話就維持原樣；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正是&lt;strong&gt;Relaxation&lt;/strong&gt;的概念。&lt;br /&gt;
(關於&lt;strong&gt;Relaxation&lt;/strong&gt;，請參考：&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathintrojian-jie.html#relax"&gt;Single-Source Shortest Path：Intro(簡介)&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖三(c)引入vertex(B)作為&lt;strong&gt;中繼點&lt;/strong&gt;，被更新的有「vertex(A)走到vertex(C)」與「vertex(A)走到vertex(D)」，資料項目更新如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Distance[A][C]=Distance[A][B]+Distance[B][C]&lt;/code&gt;&lt;span class="math"&gt;\(=0\)&lt;/span&gt;；&lt;br /&gt;
&lt;code&gt;Distance[A][D]=Distance[A][B]+Distance[B][D]&lt;/code&gt;&lt;span class="math"&gt;\(=5\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Predecessor[A][C]=Predecessor[B][C]=B&lt;/code&gt;；&lt;br /&gt;
&lt;code&gt;Predecessor[A][D]=Predecessor[B][D]=B&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同樣地，從「vertex(C)走到vertex(D)」又有了新的可能路徑&lt;span class="math"&gt;\(Path:C-A-B-D\)&lt;/span&gt;，不過其成本為&lt;span class="math"&gt;\(9\)&lt;/span&gt;，高於&lt;span class="math"&gt;\(Path:C-D\)&lt;/span&gt;之成本&lt;span class="math"&gt;\(1\)&lt;/span&gt;，因此不更新。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖三(d)引入vertex(C)作為&lt;strong&gt;中繼點&lt;/strong&gt;，更新之邏輯同上，不再贅述。&lt;br /&gt;
再將vertex(D)作為&lt;strong&gt;中繼點&lt;/strong&gt;也不會影響任何路徑，因為沒有任何一條從vertex(D)「指出去」的edge，亦即，從vertex(D)走到其餘vertex的成本都是「無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)」，所以圖三(d)即為&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;的結果。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;code&gt;Distance&lt;/code&gt;的矩陣意義很容易解讀，例如&lt;code&gt;Distance[X][Y]=5&lt;/code&gt;，即表示，從vertex(X)走到vertex(Y)的最短路徑之成本為&lt;span class="math"&gt;\(5\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;稍微複雜的是如何從&lt;code&gt;Predecessor&lt;/code&gt;回溯出路徑。&lt;br /&gt;
&lt;code&gt;Predecessor[X][Y]=Z&lt;/code&gt;的物理意義是，從vertex(X)走到vertex(Y)的最短路徑上，vertex(Y)的&lt;strong&gt;predecessor&lt;/strong&gt;為vertex(Z)，也就是說，vertex(Y)是透過edge(Z,Y)才接上&lt;span class="math"&gt;\(Path:X-...-Z\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;若要從圖三(d)的&lt;code&gt;Predecessor[A][]&lt;/code&gt;中找到從vertex(A)走到vertex(D)的最短路徑，見圖四(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根據&lt;code&gt;Predecessor[A][D]=C&lt;/code&gt;，得知是經由edge(C,D)走到vertex(D)，再接著看從vertex(A)要怎麼走到vertex(C)；&lt;/li&gt;
&lt;li&gt;根據&lt;code&gt;Predecessor[A][C]=B&lt;/code&gt;，得知是經由edge(B,C)走到vertex(C)，再接著看從vertex(A)要怎麼走到vertex(B)；&lt;/li&gt;
&lt;li&gt;最後，根據&lt;code&gt;Predecessor[A][B]=A&lt;/code&gt;，得知是經由edge(A,B)走到vertex(B)；&lt;br /&gt;
(實際上的程式碼可能會多找一次，直到&lt;code&gt;Predecessor==NIL&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此時便能找到，從vertex(A)走到vertex(D)的最短路徑為&lt;span class="math"&gt;\(Path:A-B-C-D\)&lt;/span&gt;。&lt;br /&gt;
值得注意的是，&lt;span class="math"&gt;\(Path:A-B-C-D\)&lt;/span&gt;的&lt;strong&gt;任何subpath&lt;/strong&gt;都是最短路徑。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;同理，根據&lt;code&gt;Predecessor[B][]&lt;/code&gt;可以找到從vertex(B)走到其餘vertex的最短路徑，見圖四(b)，分別是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:B-C\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(-2\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:B-C-A\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(2\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:B-C-D\)&lt;/span&gt;，成本&lt;span class="math"&gt;\(-1\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/AllPairs_FloydWarshall/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;程式碼包含幾個部分：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Graph_SP_AllPairs&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本的資料項目：&lt;code&gt;AdjList&lt;/code&gt;、&lt;code&gt;Distance&lt;/code&gt;、&lt;code&gt;Predecessor&lt;/code&gt;；&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt;實現。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本函式：&lt;strong&gt;Constructor&lt;/strong&gt;、&lt;code&gt;AddEdge()&lt;/code&gt;、&lt;code&gt;PrintData()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InitializeData()&lt;/code&gt;用來對&lt;code&gt;Distance&lt;/code&gt;與&lt;code&gt;Predecessor&lt;/code&gt;進行上一小節介紹過的初始化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FloydWarshall()&lt;/code&gt;利用三層迴圈，進行&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;在第三層迴圈的&lt;code&gt;if&lt;/code&gt;判斷式內，多了一個條件&lt;code&gt;(Distance[i][k] != MaxDistance)&lt;/code&gt;，是因為實際上的程式碼不存在「無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)」，以下面提供的程式碼為例，令無限大的距離為&lt;code&gt;int MaxDistance = 1000&lt;/code&gt;，可以想像的是，若不加上上述條件，程式會以為&lt;code&gt;Distance=1000&lt;/code&gt;是「有edge相連」，而進行路徑更新，導致錯誤(error)。&lt;/li&gt;
&lt;li&gt;為了驗證需要，在每一次「引入&lt;strong&gt;中繼點&lt;/strong&gt;vertex(k)，並更新完&lt;code&gt;Distance&lt;/code&gt;與&lt;code&gt;Predecessor&lt;/code&gt;後」，都會將此兩項資料印出，與主要演算法無關。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;：建立如圖二(a)的Graph之&lt;code&gt;AdjMatrix&lt;/code&gt;，並進行&lt;code&gt;FloydWarshall()&lt;/code&gt;。&lt;br /&gt;
另外，程式碼以vertex&lt;span class="math"&gt;\(:0,1,2,3\)&lt;/span&gt;代表vertex&lt;span class="math"&gt;\(:A,B,C,D\)&lt;/span&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for setw()&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;MaxDistance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InitializeData&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;FloydWarshall&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// Constructor, initialize AdjMatrix with 0 or MaxDistance&lt;/span&gt;
    &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MaxDistance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InitializeData&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MaxDistance&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FloydWarshall&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;InitializeData&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;initial Distance[]:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;initial Predecessor[]:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;including vertex(&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;):&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; 
                     &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;MaxDistance&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                    &lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// print data after including new vertex and updating the shortest paths&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Distance[]:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;PrintData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;Predecessor[]:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;PrintData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;Graph_SP_AllPairs&lt;/span&gt; &lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FloydWarshall&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;initial&lt;/span&gt; &lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;6&lt;/span&gt;    &lt;span class="mi"&gt;8&lt;/span&gt;
 &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;3&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
 &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="n"&gt;initial&lt;/span&gt; &lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;including&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;6&lt;/span&gt;    &lt;span class="mi"&gt;8&lt;/span&gt;
 &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;3&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;    &lt;span class="mi"&gt;6&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
 &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;including&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;5&lt;/span&gt;
 &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;3&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;    &lt;span class="mi"&gt;6&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
 &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;including&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;    &lt;span class="mi"&gt;6&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
 &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;including&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;Distance&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;    &lt;span class="mi"&gt;6&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
 &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是嘔心瀝血的&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;之介紹，內容主要圍繞在「引入&lt;strong&gt;中繼點&lt;/strong&gt;」與「最短路徑之&lt;strong&gt;結構特徵&lt;/strong&gt;」上，值得讀者細細品嘗。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch25&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cse.ust.hk/faculty/golin/COMP271Sp03/Notes/MyL15.pdf"&gt;Mordecai Golin：Lecture15:The Floyd-Warshall Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm"&gt;Wikipedia：Floyd-Warshall Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/"&gt;GeeksforGeeks：Dynamic Programming | Set 16 (Floyd Warshall Algorithm)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Shortest Path系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html"&gt;Shortest Path：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathbellman-ford-algorithm.html"&gt;Single-Source Shortest Path：Bellman-Ford Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html"&gt;Single-Source Shortest Path：on DAG(directed acyclic graph)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html"&gt;All-Pairs Shortest Path：Floyd-Warshall Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Shortest Path"></category><category term="Relaxation"></category><category term="Dynamic Programming"></category></entry><entry><title>Single-Source Shortest Path：Dijkstra's Algorithm</title><link href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html" rel="alternate"></link><updated>2016-03-07T22:30:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-07:SecondRound/single-source-shortest-pathdijkstras-algorithm.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將介紹另一種處理Single-Source Shortest Path的方法：&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;。&lt;br /&gt;
演算法的概念依然需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Relaxation&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Convergence property&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path-relaxation property&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若有疑惑，&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathintrojian-jie.html#relax"&gt;傳送門在這裏&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在演算法中，將會使用到&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;，包含三個基本操作(operation)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ExtractMin()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DecreaseKey()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MinHeapInsert()&lt;/code&gt;，不過本文以&lt;code&gt;BuildMinHeap()&lt;/code&gt;取代；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若讀者需要稍作複習，請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html"&gt;Priority Queue：Intro(簡介)&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#dijkstra"&gt;Dijkstra's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Shortest Path系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dijkstra"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Dijkstra's Algorithm&lt;/h2&gt;
&lt;p&gt;若某一directed graph中，所有edge的weight皆為&lt;strong&gt;非負實數&lt;/strong&gt;(&lt;span class="math"&gt;\(weight\geq 0\)&lt;/span&gt;)，如圖一(a)，便能夠使用&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;處理這個directed graph上的Single-Source Shortest Path問題。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;是一種「每次挑選當前最佳選擇(optimal solution)」的&lt;strong&gt;Greedy Algorithm&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把vertex分成兩個集合，其中一個集合「&lt;strong&gt;S&lt;/strong&gt;」中的vertex屬於「已經找到從起點vertex出發至該vertex的最短路徑」，另一個集合「&lt;strong&gt;Q&lt;/strong&gt;」中的vertex則還沒有。&lt;ul&gt;
&lt;li&gt;非常重要：這裡的&lt;strong&gt;Q&lt;/strong&gt;就是&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;，其中每一個&lt;strong&gt;HeapNode&lt;/strong&gt;的&lt;code&gt;element&lt;/code&gt;即為「vertex的index」，&lt;code&gt;key&lt;/code&gt;即為「vertex的&lt;code&gt;distance&lt;/code&gt;」，表示從起點走到該vertex的path成本。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;對所有vertex的&lt;code&gt;predecessor&lt;/code&gt;與&lt;code&gt;distance&lt;/code&gt;進行初始化(見圖一(b))，並更新起點vertex之&lt;code&gt;distance&lt;/code&gt;為&lt;span class="math"&gt;\(0\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;若Graph中有&lt;span class="math"&gt;\(V\)&lt;/span&gt;個vertex，便執行&lt;span class="math"&gt;\(V\)&lt;/span&gt;次迴圈。  &lt;/li&gt;
&lt;li&gt;在每一個迴圈的開始，從&lt;strong&gt;Q&lt;/strong&gt;中挑選出「&lt;code&gt;distance&lt;/code&gt;值最小」的vertex，表示已經找到「從起點vertex抵達該vertex之最短距離」，並將該vertex從&lt;strong&gt;Q&lt;/strong&gt;中移除，放進&lt;strong&gt;S&lt;/strong&gt;集合。&lt;ul&gt;
&lt;li&gt;利用&lt;code&gt;ExtractMin()&lt;/code&gt;挑選「&lt;code&gt;distance&lt;/code&gt;值最小」的vertex，即為&lt;strong&gt;Greedy Algorithm&lt;/strong&gt;概念。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每一次迴圈都會藉由&lt;code&gt;Relax()&lt;/code&gt;更新「從起點vertex到達&lt;strong&gt;仍屬於Q集合&lt;/strong&gt;的vertex之path距離」，並將path距離存放於&lt;code&gt;distance[]&lt;/code&gt;。並且利用&lt;code&gt;DecreaseKey()&lt;/code&gt;更新&lt;strong&gt;Q&lt;/strong&gt;中vertex的&lt;strong&gt;Key&lt;/strong&gt;(也就是&lt;code&gt;distance&lt;/code&gt;)。&lt;br /&gt;
步驟四與步驟五為完整的一次迴圈。&lt;/li&gt;
&lt;li&gt;進到下一個迴圈時，會繼續從&lt;strong&gt;Q&lt;/strong&gt;中挑選出「&lt;code&gt;distance&lt;/code&gt;最小」的vertex，放進&lt;strong&gt;S&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;重複上述步驟，直到&lt;strong&gt;Q&lt;/strong&gt;中的vertex都被放進&lt;strong&gt;S&lt;/strong&gt;為止。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如此便能得到從起點vertex抵達其餘vertex的最短路徑。&lt;/p&gt;
&lt;p&gt;演算法將使用兩項資料項目&lt;code&gt;predecessor[]&lt;/code&gt;與&lt;code&gt;distance[]&lt;/code&gt;，其功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;predecessor[]&lt;/code&gt;：記錄vertex是被哪個vertex所找到，由&lt;code&gt;predecessor[]&lt;/code&gt;可以還原出&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;，也就是&lt;strong&gt;Shortest-Path Tree&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distance[]&lt;/code&gt;：記錄從起點vertex走到特定vertex的path之weight總和。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;
以下以圖一(a)之Graph為例，以vertex(0)為起點，進行&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，對&lt;code&gt;predecessor[]&lt;/code&gt;和&lt;code&gt;distance[]&lt;/code&gt;進行初始化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有vertex的&lt;code&gt;predecessor[]&lt;/code&gt;先設為&lt;span class="math"&gt;\(-1\)&lt;/span&gt;。&lt;ul&gt;
&lt;li&gt;若到演算法結束時，vertex(X)之&lt;code&gt;predecessor[X]&lt;/code&gt;仍等於&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，表示從起點vertex走不到vertex(X)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有vertex的&lt;code&gt;distance[]&lt;/code&gt;先設為「無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)」。&lt;ul&gt;
&lt;li&gt;若在演算法結束時，&lt;code&gt;distance[]&lt;/code&gt;仍為「無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)」，表示，從起點vertex走不到vertex(X)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把起點vertex(0)之&lt;code&gt;distance[0]&lt;/code&gt;設為&lt;span class="math"&gt;\(0\)&lt;/span&gt;，如此一來，當挑選Min-Priority Queue中，&lt;code&gt;distance[]&lt;/code&gt;值最小的vertex，進行路徑探索時，就會從vertex(0)開始。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著便進入演算法的主要迴圈，包含兩個步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ExtractMin()&lt;/code&gt;：從Min-Priority Queue，也就是&lt;strong&gt;Q&lt;/strong&gt;中，選出&lt;code&gt;distance&lt;/code&gt;最小的vertex，並將其從&lt;strong&gt;Q&lt;/strong&gt;中移除。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Relax()&lt;/code&gt;以及&lt;code&gt;DecreaseKey()&lt;/code&gt;：對選出的vertex所連結的edge進行&lt;code&gt;Relax()&lt;/code&gt;，更新&lt;code&gt;distance&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;，並同步更新&lt;strong&gt;Q&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第一次迴圈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;從&lt;strong&gt;Q&lt;/strong&gt;中以&lt;code&gt;ExtractMin()&lt;/code&gt;，取得目前&lt;code&gt;distance&lt;/code&gt;值最小的vertex：起點vertex(0)。&lt;br /&gt;
建立一個變數&lt;code&gt;int u&lt;/code&gt;記住vertex(0)，並將vertex(0)從&lt;strong&gt;Q&lt;/strong&gt;移除，表示已經找到從起點vertex走到vertex(0)的最短路徑，見圖二(a)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，以vertex(0)為探索起點，尋找所有「從vertex(0)指出去」的edge，進行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Relax()&lt;/code&gt;：以圖二(b)為例，從vertex(0)能夠走到vertex(1)、vertex(5)，便利用&lt;code&gt;Relax()&lt;/code&gt;更新從起點vertex，經過vertex(0)後抵達vertex(1)、vertex(5)的path之weight總和，存放進&lt;code&gt;distance[]&lt;/code&gt;，同時更新&lt;code&gt;predecessor[]&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;vertex(1)能夠從vertex(0)以成本「&lt;span class="math"&gt;\(8\)&lt;/span&gt;」走到，比原先的「無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)」成本要低，因此，更新：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[1]=distance[0]+weight(0,1)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor[1]=0&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;對vertex(5)比照辦理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DecreaseKey()&lt;/code&gt;：在更新&lt;code&gt;distance[]&lt;/code&gt;之後，也要同步更新&lt;strong&gt;Q&lt;/strong&gt;中HeapNode的資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;strong&gt;第二次迴圈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;繼續從&lt;strong&gt;Q&lt;/strong&gt;中選出&lt;code&gt;distance&lt;/code&gt;最小的vertex(5)，並將vertex(5)從&lt;strong&gt;Q&lt;/strong&gt;中移除，表示已經找到「從起點vertex(0)走到vertex(5)」的最短距離，如圖三(a)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;關鍵是，為什麼從&lt;strong&gt;Q&lt;/strong&gt;中挑選&lt;code&gt;distance&lt;/code&gt;最小的vertex(X)，就能肯定已經找到「從起點vertex走到vertex(X)之最短路徑」，&lt;code&gt;distance[X]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(0,X)\)&lt;/span&gt;？&lt;/p&gt;
&lt;p&gt;這裡不進行嚴謹證明(證明請參考：&lt;a href="https://www.cs.bris.ac.uk/~montanar/teaching/dsa/dijkstra-handout.pdf"&gt;Ashley Montanaro：Priority queues and Dijkstra’s algorithm&lt;/a&gt;)，只就基本條件推論。&lt;/p&gt;
&lt;p&gt;前面提到，&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;的使用時機是，當Graph中的weight皆為非負實數(&lt;span class="math"&gt;\(weight\geq 0\)&lt;/span&gt;)，此時：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Graph中的所有&lt;strong&gt;cycle&lt;/strong&gt;之wieght總和必定是正值(positive value)；&lt;/li&gt;
&lt;li&gt;亦即，路徑中的edge越多，其weight總和只會增加或持平，不可能減少。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼再看圖三(a)，從vertex(0)走到vertex(5)有兩個選擇：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一個是經過edge(0,5)，成本為&lt;span class="math"&gt;\(1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;另一個是經過edge(0,1)，再經過其他vertex(例如，&lt;span class="math"&gt;\(Path:0-1-2-3-5\)&lt;/span&gt;)，最後抵達vertex(5)，由於edge(0,1)之weight已經是&lt;span class="math"&gt;\(8\)&lt;/span&gt;，可以確定的是，經過edge(0,1)的這條path之weight總和必定大於&lt;span class="math"&gt;\(8\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;顯然，直接經過edge(0,5)會是從vertex(0)走到vertex(5)最短的路徑。  &lt;/p&gt;
&lt;p&gt;更廣義地說，從&lt;strong&gt;Q&lt;/strong&gt;中挑選&lt;code&gt;distance&lt;/code&gt;最小之vertex，並將其從&lt;strong&gt;Q&lt;/strong&gt;中移除，必定表示，已經找到從起點vertex走到該vertex之最短路徑。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
接著，重複上述步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Relax()&lt;/code&gt;：對所有「從vertex(5)指出去」的edge進行&lt;strong&gt;Relaxation&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DecreaseKey()&lt;/code&gt;：同步更新&lt;strong&gt;Q&lt;/strong&gt;中的vertex之&lt;code&gt;distance[]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接下來，第三次迴圈至第六次迴圈(直到&lt;strong&gt;Q&lt;/strong&gt;中的vertex都被移除)的步驟如上述，見圖四(a)-圖七(a)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三次迴圈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四次迴圈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五次迴圈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六次迴圈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_Dijkstra/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖七(a)便是從vertex(0)走到Graph中其餘vertex之最短路徑&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;程式碼包含幾個部分：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class BinaryHeap&lt;/code&gt;與&lt;code&gt;struct HeapNode&lt;/code&gt;：以Binary Heap實現Min-Priority Queue，概念與範例程式碼請參考&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Graph_SP&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本的資料項目：&lt;code&gt;AdjList&lt;/code&gt;、&lt;code&gt;num_vertex&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;、&lt;code&gt;distance&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Relax()&lt;/code&gt;、&lt;code&gt;InitializeSingleSource()&lt;/code&gt;之功能與&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;所使用相同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dijkstra()&lt;/code&gt;：功能如前一小節所述。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;class BinaryHeap&lt;/code&gt;設為&lt;code&gt;class Graph_SP&lt;/code&gt;的「&lt;strong&gt;friend&lt;/strong&gt;」，才能夠把&lt;code&gt;distance[]&lt;/code&gt;放進Min Heap中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;：建立如圖一(a)之&lt;code&gt;AdjList&lt;/code&gt;，並進行&lt;code&gt;Dijkstra()&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;utility&amp;gt;          &lt;/span&gt;&lt;span class="c1"&gt;// for std::pair&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;          &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;cmath&amp;gt;            &lt;/span&gt;&lt;span class="c1"&gt;// for std::floor&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Priority_Queue_BinaryHeap.h&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Max_Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;             &lt;span class="c1"&gt;// SP serves as Shortest Path&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintIntArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 以Start作為起點&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// edge方向：from X to Y&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Dijkstra&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// 需要Min-Priority Queue&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 以Binary Heap實現Min-Priority Queue&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Dijkstra&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;BinaryHeap&lt;/span&gt; &lt;span class="nf"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// object of min queue&lt;/span&gt;
    &lt;span class="n"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BuildMinHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// initializa visited[] as {0,0,0,...,0}&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsHeapEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ExtractMin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
             &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

            &lt;span class="n"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DecreaseKey&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;print predecessor:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;print distance:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Max_Distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;Graph_SP&lt;/span&gt; &lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g9&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Dijkstra&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;larger&lt;/span&gt; &lt;span class="n"&gt;than&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;
&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;larger&lt;/span&gt; &lt;span class="n"&gt;than&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="nl"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;9&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;小小備註(可能不是很重要)：&lt;/p&gt;
&lt;p&gt;output中的「new key is larger than current key」來自於Min-Priority Queue中的&lt;code&gt;DecreaseKey()&lt;/code&gt;。&lt;br /&gt;
&lt;code&gt;DecreaseKey()&lt;/code&gt;只允許將Min-Priority Queue中的node之Key「降低」，不能「增加」，所以當要求「增加」時，便中止該函式。&lt;/p&gt;
&lt;p&gt;那麼以此例而言，什麼時候會出現「new key is larger than current key」呢？&lt;/p&gt;
&lt;p&gt;就是當vertex(X)想要對vertex(Y)進行&lt;strong&gt;Relaxation&lt;/strong&gt;卻失敗的時候，以此例而言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次發生在圖四(a)與圖四(b)，要以vertex(3)對其他「還存在Min-Priority Queue中」而且「與vertex(3)相連」的vertex進行&lt;strong&gt;Relaxation&lt;/strong&gt;時(在vertex(3)因為&lt;code&gt;distance&lt;/code&gt;最小而被當作起點之前，vertex(0)與vertex(5)已經從&lt;strong&gt;Q&lt;/strong&gt;中移除了，因此目前只剩下vertex(1)、vertex(2)、vertex(4)與之相連)，因為vertex(4)當下的&lt;code&gt;distance&lt;/code&gt;(從vertex(5)走到vertex(4)的成本)會比從vertex(3)走到vertex(4)還低(成本&lt;code&gt;distance[3]+weight(3,4)&lt;/code&gt;為&lt;span class="math"&gt;\(3+7=10\)&lt;/span&gt;)，所以在&lt;strong&gt;Relaxation&lt;/strong&gt;後，&lt;code&gt;distance[4]&lt;/code&gt;維持不變，那麼在&lt;code&gt;minQueue&lt;/code&gt;進行&lt;code&gt;DecreaseKey()&lt;/code&gt;時，就不會對vertex(4)的Key(也就是&lt;code&gt;distance[4]&lt;/code&gt;)進行調整。&lt;/li&gt;
&lt;li&gt;第二次發生在圖六(a)與圖六(b)，以vertex(2)對vertex(4)進行&lt;strong&gt;Relaxation&lt;/strong&gt;時，理由與第一次一樣：「從vertex(2)走到vertex(4)的成本」比「從vertex(5)走到vertex(4)的成本」還高，所以不更新&lt;code&gt;distance[4]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
最後，關於&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;之時間複雜度，會因為Min-Priority Queue所使用的資料結構(例如，Binary Heap或是Fibonacci Heap)而有所差異，可能最差從&lt;span class="math"&gt;\(O(V^2+E)\)&lt;/span&gt;到最好&lt;span class="math"&gt;\(O(V\log V+E)\)&lt;/span&gt;，請參考以下連結之討論：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.cs.bris.ac.uk/~montanar/teaching/dsa/dijkstra-handout.pdf"&gt;Ashley Montanaro：Priority queues and Dijkstra’s algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/dijkstraAlgor.htm"&gt;Rashid Bin Muhammad：Dijkstra's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Dijkstra's_algorithm"&gt;Wikipedia：Dijkstra's algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;之介紹。  &lt;/p&gt;
&lt;p&gt;讀者不妨嘗試比較&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;與&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;之差異，一般情況下，&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;應該會較有效率，不過限制是Graph之weight必須是非負實數(nonnegative real number)，若遇到weight為負數時，仍需使用&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch24&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Dijkstra's_algorithm"&gt;Wikipedia：Dijkstra's algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html"&gt;Priority Queue：Intro(簡介)&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.bris.ac.uk/~montanar/teaching/dsa/dijkstra-handout.pdf"&gt;Ashley Montanaro：Priority queues and Dijkstra’s algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/dijkstraAlgor.htm"&gt;Rashid Bin Muhammad：Dijkstra's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Shortest Path系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html"&gt;Shortest Path：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathbellman-ford-algorithm.html"&gt;Single-Source Shortest Path：Bellman-Ford Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html"&gt;Single-Source Shortest Path：on DAG(directed acyclic graph)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html"&gt;All-Pairs Shortest Path：Floyd-Warshall Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Shortest Path"></category><category term="Relaxation"></category><category term="Priority Queue"></category><category term="Greedy Algorithm"></category></entry><entry><title>Priority Queue：Binary Heap</title><link href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html" rel="alternate"></link><updated>2016-03-05T21:26:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-05:SecondRound/priority-queuebinary-heap.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將接續&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html"&gt;Priority Queue：Intro(簡介)&lt;/a&gt;，介紹Binary Heap(二元堆積)，並用以實現Min-Priority Queue。  &lt;/p&gt;
&lt;p&gt;Binary Heap的概念與Binary Tree密切相關，若讀者有興趣，不妨回顧一下何謂&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;暖暖身，請參考：&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bh"&gt;Binary Heap(二元堆積)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#operation"&gt;Binary Heap之Operation(函式)&lt;/a&gt; &lt;ul&gt;
&lt;li&gt;&lt;a href="#MinHeapify"&gt;函式：MinHeapify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#BuildMinHeap"&gt;函式：BuildMinHeap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#other"&gt;函式：其他&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Minimum"&gt;函式：Minimum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ExtractMin"&gt;函式：ExtractMin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#DecreaseKey"&gt;函式：DecreaseKey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#MinHeapInsert"&gt;函式：MinHeapInsert&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Priority Queue系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bh"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Binary Heap(二元堆積)&lt;/h2&gt;
&lt;p&gt;為處理廣義情形，建議將Binary Heap中的元素定義為&lt;strong&gt;Dictionary&lt;/strong&gt;，每個資料項目皆有其對應的&lt;strong&gt;Key&lt;/strong&gt;值，也就是Priority Queue將使用的&lt;strong&gt;Key&lt;/strong&gt;。&lt;br /&gt;
(關於Dictionary，請參考：&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html#dict"&gt;Hash Table：Intro(簡介)&lt;/a&gt;以及&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html#dictionary"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Binary Heap有兩項基本特徵：&lt;/p&gt;
&lt;p&gt;特徵一：Binary Heap之結構可以視作&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖一(a)，A&lt;span class="math"&gt;\(\sim\)&lt;/span&gt;I共9個元素，便按照&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;之順序規則，填滿位置&lt;span class="math"&gt;\(1\sim9\)&lt;/span&gt;，以index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)&lt;span class="math"&gt;\(\sim\)&lt;/span&gt;index(&lt;span class="math"&gt;\(9\)&lt;/span&gt;)表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣的優點是易於尋找「parent-child」之關係，以index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)的node為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其&lt;strong&gt;left child&lt;/strong&gt;必定位在&lt;strong&gt;index(&lt;span class="math"&gt;\(2i\)&lt;/span&gt;)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;其&lt;strong&gt;right child&lt;/strong&gt;必定位在&lt;strong&gt;index(&lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;其&lt;strong&gt;parent&lt;/strong&gt;必定位在&lt;strong&gt;index(&lt;span class="math"&gt;\(\lfloor i/2 \rfloor\)&lt;/span&gt;)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖一(a)中位於index(&lt;span class="math"&gt;\(3\)&lt;/span&gt;)之node(F)為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其&lt;strong&gt;left child&lt;/strong&gt;為index(&lt;span class="math"&gt;\(6\)&lt;/span&gt;)之node(E)；&lt;/li&gt;
&lt;li&gt;其&lt;strong&gt;right child&lt;/strong&gt;為index(&lt;span class="math"&gt;\(7\)&lt;/span&gt;)之node(I)；&lt;/li&gt;
&lt;li&gt;其&lt;strong&gt;parent&lt;/strong&gt;為index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)之node(D)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;特徵二，若將位於index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)之node視為subtree之&lt;strong&gt;root&lt;/strong&gt;，那麼，可將此Binary Heap分為兩類：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Max Heap&lt;/strong&gt;：在每一個subtree中，&lt;strong&gt;root&lt;/strong&gt;之「key」要比兩個&lt;strong&gt;child&lt;/strong&gt;之「key」還要大：&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Key(i)&amp;gt;Key(2i)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Key(i)&amp;gt;Key(2i+1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Min Heap&lt;/strong&gt;：在每一個subtree中，&lt;strong&gt;root&lt;/strong&gt;之「key」要比兩個&lt;strong&gt;child&lt;/strong&gt;之「key」還要小：&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Key(i)&amp;lt;Key(2i)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Key(i)&amp;lt;Key(2i+1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖一(b)之Min Heap為例，每個node下方的藍色數字表示其&lt;strong&gt;Key&lt;/strong&gt;值，檢查Min-Heap中任何一個subtree，皆滿足&lt;span class="math"&gt;\(Key(i)&amp;lt;Key(2i)\)&lt;/span&gt;以及&lt;span class="math"&gt;\(Key(i)&amp;lt;Key(2i+1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由於Binary Heap特有的「parent-child」之關係，只要讓矩陣中index(&lt;span class="math"&gt;\(0\)&lt;/span&gt;)的位置閒置，從index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)開始存放資料之Dictionary，便能夠使用矩陣(array)來表示Binary Heap，如圖一(b)。&lt;/p&gt;
&lt;p&gt;Binary Heap中的每個資料(node)之Dictionary將以&lt;code&gt;struct&lt;/code&gt;實現：&lt;br /&gt;
(亦可使用&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;或其他)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;備註：為了區別&lt;code&gt;element&lt;/code&gt;與&lt;code&gt;key&lt;/code&gt;，圖示中的&lt;code&gt;element&lt;/code&gt;是以「英文字母」表示，而&lt;code&gt;key&lt;/code&gt;用&lt;code&gt;int&lt;/code&gt;。不過這裡定義的&lt;code&gt;struct HeapNode&lt;/code&gt;之&lt;code&gt;element&lt;/code&gt;是以&lt;code&gt;int&lt;/code&gt;表示，主要是為了使這篇文章定義的&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;可以在&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;直接複製貼上使用。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;code&gt;class BinaryHeap&lt;/code&gt;之定義，以及所有成員函式(member function)之宣告如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 存放HeapNode資料的矩陣&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;FindPosition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;               &lt;span class="c1"&gt;// default constructor會把heap[0]給預留 &lt;/span&gt;
        &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// 之後若新增HeapNode, 會從heap[1]開始新增&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;IsHeapEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;

    &lt;span class="c1"&gt;// Min-Priority Queue&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BuildMinHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DecreaseKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;newKey&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;MinHeapInsert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Minimum&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                  &lt;span class="c1"&gt;// 回傳vertex的位置index&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;ExtractMin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// 回傳vertex的位置index&lt;/span&gt;

    &lt;span class="c1"&gt;// void HeapSort();&lt;/span&gt;

    &lt;span class="c1"&gt;// Max-Priority Queue&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="operation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Binary Heap之Operation(函式)&lt;/h2&gt;
&lt;p&gt;接著要介紹和Min Heap與Min-Priority Queue有關的函式。&lt;/p&gt;
&lt;p&gt;小小提醒：為避免混淆，在圖示介紹中，資料的「element」是以「英文字母」表示，而實際的程式碼，資料的「element」仍是用&lt;code&gt;int&lt;/code&gt;，例如，使用&lt;span class="math"&gt;\(A-1\)&lt;/span&gt;、&lt;span class="math"&gt;\(B-2\)&lt;/span&gt;做對應。&lt;/p&gt;
&lt;p&gt;&lt;a name="MinHeapify"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：MinHeapify&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MinHeapify()&lt;/code&gt;是一種「由上至下」(由&lt;strong&gt;root&lt;/strong&gt;往&lt;strong&gt;leaf&lt;/strong&gt;)，按照Min Heap之規則逐一調整subtree的方法，步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;選定某個index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)之node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)，視為subtree之&lt;strong&gt;root&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;比較&lt;strong&gt;root&lt;/strong&gt;的Key與兩個&lt;strong&gt;child&lt;/strong&gt;(node(&lt;span class="math"&gt;\(2i\)&lt;/span&gt;)與node(&lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;))之Key；&lt;ul&gt;
&lt;li&gt;如果&lt;strong&gt;left child&lt;/strong&gt;之Key最小，則將node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)與node(&lt;span class="math"&gt;\(2i\)&lt;/span&gt;)對調位置，使原先的&lt;strong&gt;left child&lt;/strong&gt;成為&lt;strong&gt;root&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;right child&lt;/strong&gt;之Key最小，則將node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)與node(&lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;)對調位置，使原先的&lt;strong&gt;right child&lt;/strong&gt;成為&lt;strong&gt;root&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;並在對調之後，繼續檢查「新的subtree」是否滿足Min Heap的規則。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖二(a)為例，node(K)、node(Y)、node(Z)所形成的subtree不符合Min Heap的規則，因此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較三者的Key，以變數&lt;code&gt;int smallest&lt;/code&gt;記錄具有最小Key值的node。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smallest&lt;/code&gt;是Key為&lt;span class="math"&gt;\(17\)&lt;/span&gt;的node(Y)，則將node(K)與node(Y)互換位置，如圖二(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在經過以上步驟之後，node(K)、node(Y)、node(Z)所形成的subtree已經滿足Min Heap的規則。  &lt;/p&gt;
&lt;p&gt;不過，由於node(K)之Key值比node(Y)之Key值大，因此，即使原先由node(Y)、node(B)、node(G)形成之subtree滿足Min Heap規則(以圖二(a)的情形為例，原先已經不滿足Min Heap)，仍不能保證node(K)取代node(Y)後，node(K)、node(B)、node(G)所形成之subtree也滿足Min Heap規則，所以需要重複上述步驟，再次以node(K)作為subtree之&lt;strong&gt;root&lt;/strong&gt;，檢查並調整subtree成Min Heap，如圖二(c)與圖二(d)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;因為&lt;code&gt;smallest&lt;/code&gt;挑的是node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)、node(&lt;span class="math"&gt;\(2i\)&lt;/span&gt;)、node(&lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;)中Key值最小的node，使之成為subtree之&lt;code&gt;root&lt;/code&gt;，因此「所有被檢查過的」subtree，必定滿足Min Heap之規則，如圖二(d)中的「node(Y)、node(G)、node(Z)」與「node(G)、node(B)、node(K)」。&lt;/p&gt;
&lt;p&gt;但是，Binary Heap中仍然可能有某些subtree不符合Min Heap規則，如圖二(d)中的「node(E)、node(F)、node(I)」，因此，會需要一個迴圈對「所有具有&lt;strong&gt;child&lt;/strong&gt;的node」進行檢查(利用&lt;code&gt;MinHeapify()&lt;/code&gt;檢查)，這就是下一個函式&lt;code&gt;BuildMinHeap()&lt;/code&gt;的任務。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MinHeapify()&lt;/code&gt;之範例程式碼如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// 取得left child&lt;/span&gt;
        &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="c1"&gt;// 取得right child&lt;/span&gt;
        &lt;span class="n"&gt;smallest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// smallest用來記錄包含root與child, 三者之中Key最小的node&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;smallest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;smallest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smallest&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;smallest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smallest&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                 &lt;span class="c1"&gt;// 如果目前node的Key不是三者中的最小&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smallest&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;   &lt;span class="c1"&gt;// 就調換node與三者中Key最小的node之位置&lt;/span&gt;
        &lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smallest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// 調整新的subtree成Min Heap&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="BuildMinHeap"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：BuildMinHeap&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BuildMinHeap()&lt;/code&gt;的任務很簡單，把每一個「具有&lt;strong&gt;child&lt;/strong&gt;」的node都進行過一次&lt;code&gt;MinHeapify()&lt;/code&gt;，如此便能保證Binary Heap中的所有subtree皆滿足Min Heap規則，便能將一個由任意矩陣代表的Binary Heap轉換成Min Heap。&lt;/p&gt;
&lt;p&gt;根據Binary Heap的index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)特徵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;left child&lt;/strong&gt;在index(&lt;span class="math"&gt;\(2i\)&lt;/span&gt;)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;right child&lt;/strong&gt;在index(&lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;parent&lt;/strong&gt;在index(&lt;span class="math"&gt;\(\lfloor i/2 \rfloor\)&lt;/span&gt;)；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若Binary Heap共有&lt;span class="math"&gt;\(N\)&lt;/span&gt;個node，那麼所有「具有&lt;strong&gt;child&lt;/strong&gt;」的node，必定位在index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)到index(&lt;span class="math"&gt;\(\lfloor N/2 \rfloor\)&lt;/span&gt;)。&lt;/p&gt;
&lt;p&gt;以圖三(a)中的任意Binary Heap(還不是Min Heap)為例，共有&lt;span class="math"&gt;\(9\)&lt;/span&gt;個node，因此，必定只有index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)到index(&lt;span class="math"&gt;\(4\)&lt;/span&gt;)的node具有&lt;strong&gt;child&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;因此，&lt;code&gt;BuildMinHeap()&lt;/code&gt;只要從index(&lt;span class="math"&gt;\(4\)&lt;/span&gt;)之node，一路往index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)之node進行&lt;code&gt;MinHeapify()&lt;/code&gt;，便能將此Binary Heap轉換成Min Heap，見圖三(b)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/BuildMinHeap_v2.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BuildMinHeap()&lt;/code&gt;之範例程式碼如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;input：給定一個任意矩陣&lt;code&gt;array[]&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;此處給定&lt;code&gt;std::vector&amp;lt;int&amp;gt; array&lt;/code&gt;，把&lt;code&gt;array&lt;/code&gt;的&lt;strong&gt;index&lt;/strong&gt;視為&lt;code&gt;element&lt;/code&gt;，把&lt;code&gt;array&lt;/code&gt;的&lt;strong&gt;數值&lt;/strong&gt;視為&lt;code&gt;key&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若array[] = {&lt;span class="math"&gt;\(100,27,34,56,...\)&lt;/span&gt;}，那麼key(&lt;span class="math"&gt;\(100\)&lt;/span&gt;)就對應到element(&lt;span class="math"&gt;\(0\)&lt;/span&gt;)，key(&lt;span class="math"&gt;\(27\)&lt;/span&gt;)對應到element(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)，key(&lt;span class="math"&gt;\(34\)&lt;/span&gt;)對應到element(&lt;span class="math"&gt;\(2\)&lt;/span&gt;)，依此類推。&lt;/li&gt;
&lt;li&gt;例如在&lt;strong&gt;Graph&lt;/strong&gt;問題中，&lt;code&gt;array&lt;/code&gt;的&lt;strong&gt;index&lt;/strong&gt;時常對應到「特定的vertex」，例如&lt;code&gt;BFS()&lt;/code&gt;的&lt;code&gt;distance[]&lt;/code&gt;，&lt;code&gt;distance[1]&lt;/code&gt;即表示「從起點vertex走到vertex(1)」的距離，因此不需要特別使用&lt;code&gt;struct HeapNode&lt;/code&gt;表示&lt;code&gt;array&lt;/code&gt;的矩陣元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以把input令成&lt;code&gt;std::vector&amp;lt;HeapNode&amp;gt; array&lt;/code&gt;，那麼每一個矩陣元素都有各自的&lt;code&gt;element&lt;/code&gt;與&lt;code&gt;key&lt;/code&gt;，依序放進&lt;code&gt;std::vector&amp;lt;HeapNode&amp;gt; heap&lt;/code&gt;即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;heap[]&lt;/code&gt;初始化：先把&lt;code&gt;array[]&lt;/code&gt;的資料放進&lt;code&gt;heap[]&lt;/code&gt;，並將&lt;code&gt;heap[0]&lt;/code&gt;閒置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;接著對index(&lt;span class="math"&gt;\(\lfloor N/2 \rfloor\)&lt;/span&gt;)到index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)進行&lt;code&gt;MinHeapify()&lt;/code&gt;。&lt;br /&gt;
&lt;/br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BuildMinHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="c1"&gt;// 將array[]的資料放進 heap之矩陣中, 並預留 heap[0] 不做使用&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     
        &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 把array[]的idx視為element&lt;/span&gt;
        &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;              &lt;span class="c1"&gt;// 把array[]的數值視為key&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// length要減一, 因為heap從從1開始存放資料&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="other"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：其他&lt;/h3&gt;
&lt;p&gt;在進入與Min-Priority Queue有關的函式之前，先介紹些其他(雜項)放鬆心情。&lt;/p&gt;
&lt;p&gt;首先是在&lt;code&gt;MinHeapify()&lt;/code&gt;出現過的&lt;code&gt;swap()&lt;/code&gt;，單純地利用&lt;strong&gt;reference&lt;/strong&gt;作為函式的參數，對Heap中的node進行位置調換：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;FindPosition()&lt;/code&gt;是為了確認特定元素所在的位置(index)，這會用在Min-Priority Queue中的&lt;code&gt;DecreaseKey()&lt;/code&gt;，因為其需要先「找到資料在Heap中的位置」，再調整該資料之Key。&lt;/p&gt;
&lt;p&gt;不過由於&lt;code&gt;DecreaseKey()&lt;/code&gt;的時間複雜度只有&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;，若使用以下的直覺寫法，缺點是會把時間複雜度提高到&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;(其中&lt;span class="math"&gt;\(N\)&lt;/span&gt;為node總數)。&lt;br /&gt;
還有一些替代方法，例如以空間換取時間，設立一個矩陣變數，記錄每一筆資料的位置，便能維持&lt;code&gt;DecreaseKey()&lt;/code&gt;的效率。  &lt;/p&gt;
&lt;p&gt;這部分就留給讀者自行斟酌。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FindPosition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以及定義在&lt;code&gt;class BinaryHeap&lt;/code&gt;裡面的&lt;code&gt;IsHeapEmpty()&lt;/code&gt;與&lt;code&gt;GetParentNode()&lt;/code&gt;，分別檢查Heap是否有資料，和回傳node(i)之&lt;strong&gt;parent&lt;/strong&gt;的index(&lt;span class="math"&gt;\(\lfloor i/2 \rfloor\)&lt;/span&gt;)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;IsHeapEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="Minimum"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：Minimum&lt;/h3&gt;
&lt;p&gt;因為Min Queue的規則，&lt;strong&gt;root&lt;/strong&gt;一定是所有node中，具有最小Key值的node，因此，若要得到最小值，只要讀取&lt;code&gt;heap[1]&lt;/code&gt;即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Minimum&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="ExtractMin"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：ExtractMin&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ExtractMin()&lt;/code&gt;的目的是「回傳具有最小Key的node之index」，並且將其從Heap中移除，步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;確認Heap是否有資料，若沒有的話，便回傳&lt;strong&gt;error：巧婦難為無米之炊&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;若Heap中有資料，先以變數&lt;code&gt;min&lt;/code&gt;記下Min Heap中的&lt;strong&gt;root&lt;/strong&gt;之&lt;code&gt;element&lt;/code&gt;，&lt;strong&gt;root&lt;/strong&gt;即為Heap中具有最小Key值之node；&lt;/li&gt;
&lt;li&gt;接著把Heap中「最後一個node」之資料放進「第一個index位置」裡面，如此便從Heap中移除原先的「最小Key值node」；&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由於在上個步驟已經把原先位於「最後位置index」之node放進&lt;strong&gt;root&lt;/strong&gt;之位置，便能夠直接刪除最後一個位置的記憶體位置，調整存放資料的&lt;code&gt;heap&lt;/code&gt;；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在此，因為使用了C++標準函式庫(STL)的&lt;code&gt;std::vector&lt;/code&gt;，若要刪除&lt;code&gt;heap&lt;/code&gt;的最後一個元素，只要只用成員函式(member function)：&lt;code&gt;std::vector::erase()&lt;/code&gt;即可。&lt;br /&gt;
(關於&lt;code&gt;std::vector::erase&lt;/code&gt;，請參考：&lt;a href="http://www.cplusplus.com/reference/vector/vector/erase/"&gt;Cplusplus：std::vector::erase&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此時，&lt;strong&gt;root&lt;/strong&gt;位置的node之Key極有可能比其兩個&lt;strong&gt;child&lt;/strong&gt;之Key值還要大，有可能違反Min Heap規則，因此需要對其執行&lt;code&gt;MinHeapify()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖四(a)為例，要取出Min Heap的&lt;strong&gt;root&lt;/strong&gt;，也就是Key值為2的node(D)，並且將Min Heap中，位在最後一個index之node(C)放進&lt;strong&gt;root&lt;/strong&gt;，然後利用&lt;code&gt;MinHeapify()&lt;/code&gt;重新將Heap調整成Min heap，如圖四(b)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/ExtractMin_v2.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExtractMin()&lt;/code&gt;之範例程式碼如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ExtractMin&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsHeapEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;error: heap is empty&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 此時heap的第一個node具有最小key值&lt;/span&gt;
                                  &lt;span class="c1"&gt;// 便以min記錄其element, 最後回傳min&lt;/span&gt;
    &lt;span class="c1"&gt;// delete the first element/vertex&lt;/span&gt;
    &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;            &lt;span class="c1"&gt;// 把最後一個element放到第一個位置,&lt;/span&gt;
    &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 再刪除最後一個element&lt;/span&gt;
    &lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;          &lt;span class="c1"&gt;// 目前, heap[1]具有最大Key, 需要進行調整&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 回傳heap中具有最小key的element&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="DecreaseKey"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：DecreaseKey&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DecreaseKey()&lt;/code&gt;的目的是調整Min Heap中的node之Key值，因為Key值改變，極有可能違反Min Heap規則，因此也需要對Heap進行調整，步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於函式的參數(argument)是&lt;code&gt;struct&lt;/code&gt;結構中的&lt;code&gt;element&lt;/code&gt;，若以圖五(a)為例，資料的&lt;code&gt;element&lt;/code&gt;就是「英文字母」(A、B、C等等)，因此，先利用&lt;code&gt;FindPosition()&lt;/code&gt;找到該資料在Heap中的位置index；&lt;/li&gt;
&lt;li&gt;再判斷，若參數中的&lt;code&gt;newKey&lt;/code&gt;沒有比原先的Key還小，就直接結束函式(可以想成&lt;code&gt;DecreaseKey()&lt;/code&gt;只有把資料之Key降低，沒有調高的功能)；&lt;/li&gt;
&lt;li&gt;若沒有在上個步驟結束函式，便把資料之Key更新成&lt;code&gt;newKey&lt;/code&gt;；&lt;ul&gt;
&lt;li&gt;因為使用矩陣存放資料，所以只要有資料在Heap中的index，即可靠index對資料進行存取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因為是把資料的Key「降低」，因此，有可能使得原先資料所位於的subtree違反Min Heap規則，需要調整：&lt;ul&gt;
&lt;li&gt;假設被修改的資料是位於index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)的node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)，便比較node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)與其&lt;strong&gt;parent&lt;/strong&gt;(也就是node(&lt;span class="math"&gt;\(\lfloor i/2 \rfloor\)&lt;/span&gt;))之Key值，&lt;/li&gt;
&lt;li&gt;如果node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)之Key值較小，便交換index(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)與index(&lt;span class="math"&gt;\(\lfloor i/2 \rfloor\)&lt;/span&gt;)的資料(如同在&lt;code&gt;Minheapify()&lt;/code&gt;中的交換&lt;code&gt;swap()&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;若node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)之Key值仍然比其&lt;strong&gt;parent&lt;/strong&gt;之Key值大，表示，node(&lt;span class="math"&gt;\(i\)&lt;/span&gt;)所在之subtree仍滿足Min Heap規則，即可結束函式。&lt;/li&gt;
&lt;li&gt;還有，由於Heap的&lt;strong&gt;root&lt;/strong&gt;是從index(&lt;span class="math"&gt;\(1\)&lt;/span&gt;)開始存放資料，若一路回溯&lt;strong&gt;parent&lt;/strong&gt;直到index小於&lt;span class="math"&gt;\(1\)&lt;/span&gt;，表示Heap中所有與「被修改的資料」有關之subtree都被檢查過了，可以結束函式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖五(a)為例，若將node(H)之Key值從原先的&lt;span class="math"&gt;\(15\)&lt;/span&gt;更改成&lt;span class="math"&gt;\(3\)&lt;/span&gt;，將使得subtree「node(A)、node(G)、node(H)」違反Min Heap規則，如圖五(b)，必須利用上述方法修正。&lt;br /&gt;
修正流程見圖五(c)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/DecreaseKey.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DecreaseKey()&lt;/code&gt;之範例程式碼如下：&lt;br /&gt;
(函式裡的&lt;code&gt;int node&lt;/code&gt;與&lt;code&gt;struct HeapNode&lt;/code&gt;的&lt;code&gt;element&lt;/code&gt;具有相同意義)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DecreaseKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;newKey&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FindPosition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 找到node所在的位置index&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newKey&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;// 如果不是把node的Key下修, 便終止此函式&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;new key is larger than current key&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 更新node之Key後, 需要檢查是否新的subtree滿足Min Heap&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;)].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;)]);&lt;/span&gt;
        &lt;span class="n"&gt;index_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="MinHeapInsert"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;函式：MinHeapInsert&lt;/h3&gt;
&lt;p&gt;有了&lt;code&gt;DecreaseKey()&lt;/code&gt;後，要在Min Heap中新增資料會容易許多：&lt;br /&gt;
(若恰好以&lt;code&gt;std::vector&lt;/code&gt;建立&lt;code&gt;heap[]&lt;/code&gt;，簡直只要兩行程式碼)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Heap中多配置一塊新的記憶體位置，也就是把用來儲存Heap之矩陣&lt;code&gt;heap[]&lt;/code&gt;拉長，存放新的資料；&lt;/li&gt;
&lt;li&gt;現在新的資料已經位於Heap中的最後一個位置index，只要利用&lt;code&gt;DecreaseKey()&lt;/code&gt;，即可將新的Heap調整成Min Heap。&lt;ul&gt;
&lt;li&gt;因為&lt;code&gt;DecreaseKey()&lt;/code&gt;並不會阻止「&lt;code&gt;newKey&lt;/code&gt;等於node現有Key」的情形，所以，即使在&lt;code&gt;DecreaseKey()&lt;/code&gt;的輸入參數(input argument)上，&lt;code&gt;newKey&lt;/code&gt;若等於已經存在Heap中的node之Key也是可行的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖六(a)為例，若要在Heap中新增Key為&lt;span class="math"&gt;\(6\)&lt;/span&gt;之node(J)，便將其加入&lt;code&gt;heap[]&lt;/code&gt;的最後位置，再利用&lt;code&gt;DecreaseKey()&lt;/code&gt;比較node(J)與其&lt;strong&gt;parent&lt;/strong&gt;之Key值，檢查是否符合Min Heap規則，若不符合即進行修正，見圖六(a)-圖六(c)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(a)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(b)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Priority%20Queue%20series/Binary%20Heap%20fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MinHeapInsert()&lt;/code&gt;之範例程式碼如下：&lt;br /&gt;
(函式裡的&lt;code&gt;int node&lt;/code&gt;與&lt;code&gt;struct HeapNode&lt;/code&gt;的&lt;code&gt;element&lt;/code&gt;具有相同意義)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;MinHeapInsert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;    &lt;span class="c1"&gt;// 在heap[]尾巴新增一個node&lt;/span&gt;
    &lt;span class="n"&gt;DecreaseKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;由以上說明可以發現，在&lt;code&gt;MinHeapify()&lt;/code&gt;中，是「由上往下」對subtree進行修正，有的寫法會將此操作獨立成函式：&lt;strong&gt;SiftDown&lt;/strong&gt;；&lt;br /&gt;
在&lt;code&gt;DecreaseKey()&lt;/code&gt;中，則是「由下往上」進行修正，此則稱為&lt;strong&gt;SiftUp&lt;/strong&gt;，範例請參考：&lt;a href="http://codereview.stackexchange.com/questions/42999/implementation-of-binary-heap-in-c"&gt;Code Review：Implementation of binary heap in C++&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是以Binary Heap實現Min-Priority Queue之說明，後者將在許多應用出現，包括與Graph相關的&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Prim's Algorithm&lt;/a&gt;和&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Dijkstra's Algorithm&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch6&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5, Ch9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.bris.ac.uk/~montanar/teaching/dsa/dijkstra-handout.pdf"&gt;Ashley Montanaro：Priority queues and Dijkstra’s algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.yam.com/rockmanray/article/44952434"&gt;禪心劍氣相思骨：Priority Queue 解析1 - 從binary heap開始&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codereview.stackexchange.com/questions/42999/implementation-of-binary-heap-in-c"&gt;Code Review：Implementation of binary heap in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Priority_queue"&gt;Wikipedia：Priority Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Binary_heap"&gt;Wikipedia：Binary Heap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Priority Queue系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html"&gt;Priority Queue：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category><category term="Priority Queue"></category><category term="Heap"></category><category term="Binary Tree"></category><category term="Dictionary"></category></entry><entry><title>Priority Queue：Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html" rel="alternate"></link><updated>2016-03-05T21:25:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-05:SecondRound/priority-queueintrojian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將介紹抽象的資料結構：Priority Queue(優先權佇列)的基本概念。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#pq"&gt;簡介：Priority Queue(優先權佇列)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Priority Queue系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="pq"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;簡介：Priority Queue(優先權佇列)&lt;/h2&gt;
&lt;p&gt;「待辦事項」通常是表面上看起來沒有順序、但其實具有「執行時的優先順序」的一堆事情。&lt;/p&gt;
&lt;p&gt;Priority Queue(優先權佇列)就像在處理「待辦事項」，能夠在眾多各自具有優先順序之資料堆中，取出「最重要/最不重要」的項目：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Priority&lt;/strong&gt;：對資料項目賦予「權重/優先權」，用以表示資料的重要程度。&lt;br /&gt;
&lt;strong&gt;Queue&lt;/strong&gt;：隊伍、佇列、順序，意味著把資料整理成「某種順序」的資料結構。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所謂的「某種順序」，可能是「先進先出(First-In-First-Out)」順序：每次要從此資料結構讀取資料時，必定是拿到「先進入」的資料。&lt;br /&gt;
    (請參考：&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;Wikipedia：Queue&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;也有可能是額外賦予資料的「權重/優先權」順序：每次要從此資料結構讀取資料時，必定會拿到具有「最大值/最小值權重」的資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果每次要從Priority Queue讀取資料時，都拿到「權重最大」的資料，則稱此為&lt;strong&gt;Max-Priority Queue&lt;/strong&gt;。&lt;br /&gt;
反之，若每次讀取資料，都拿到「權重最小」的資料，則稱此為&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;舉例來說，如果每天起床固定要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;削鉛筆，重要性&lt;span class="math"&gt;\(2\)&lt;/span&gt;分；&lt;/li&gt;
&lt;li&gt;梳洗，重要性&lt;span class="math"&gt;\(10\)&lt;/span&gt;分；&lt;/li&gt;
&lt;li&gt;剪指甲，重要性&lt;span class="math"&gt;\(4\)&lt;/span&gt;分；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那麼，以一個Max-Priority Queue來管理「每天起床的待辦事項」，第一件事情要先刷牙上廁所，然後是剪指甲，最後再削一些無關緊要的鉛筆。&lt;br /&gt;
反之，若以一個Min-Priority Queue來管理「每天起床的待辦事項」，第一件事情要先削鉛筆，然後是剪指甲，最後才能去刷牙。&lt;/p&gt;
&lt;p&gt;一個Max-Priority Queue，最基本會有三種操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Insert&lt;/strong&gt;：將資料加入Queue中。&lt;ul&gt;
&lt;li&gt;例如，把「削鉛筆」、「梳洗」、「剪指甲」三件事情寫進Queue裡。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IncreaseKey&lt;/strong&gt;：當某項資料的「重要性提高」時，需要在Queue中改變資料的權重，以下將以Key代表權重。&lt;ul&gt;
&lt;li&gt;例如，最近突變出某種藉由指甲垢傳遞的流感病毒，使得「剪指甲」的重要性提高，便需要增加「剪指甲」的Key，假設Key提高到&lt;span class="math"&gt;\(11\)&lt;/span&gt;分，那麼每天起床的工作順序就變成：「剪指甲」、「梳洗」、「削鉛筆」。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ExtractMax&lt;/strong&gt;：取得最重要(Key最大)的資料，並將其從Queue中移除。&lt;ul&gt;
&lt;li&gt;每天起床後，先從「待辦事項」得知，最重要的事情是「梳洗」，並在完成之後，將其從「待辦事項」移除，避免重複執行。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;與之對應的Min-Priority Queue之基本操作則是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Insert&lt;/strong&gt;：將資料加入Queue中。 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DecreaseKey&lt;/strong&gt;：當某項資料的「重要性降低」時，需要改變在Queue中資料的Key。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ExtractMin&lt;/strong&gt;：取得重要性最低(Key最小)的資料，並將其從Queue中移除。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
為了替&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;以及&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;鋪路，本系列文章將以Min-Priority Queue作為代表。&lt;br /&gt;
不過只要掌握Priority Queue的概念，Max-Priority Queue就只是桌上的一塊小蛋糕。&lt;/p&gt;
&lt;p&gt;稍微困難的是實現方法，&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch9&lt;/a&gt;一共列出了六種實現方法(可能還有更多)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leftist Tree(左傾樹)&lt;/li&gt;
&lt;li&gt;Binomial Heap(二項式堆積)&lt;/li&gt;
&lt;li&gt;Fibonacci Heap(費式堆積)&lt;/li&gt;
&lt;li&gt;Pairing Heap(成對堆積)&lt;/li&gt;
&lt;li&gt;Symmetric Min-Max Heap(對稱式最小-最大堆積)&lt;/li&gt;
&lt;li&gt;Interval Heap(區間堆積)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前四種資料結構稱為&lt;strong&gt;Single-End Priority Queue(SEPQ)&lt;/strong&gt;，亦即，該資料結構只能取得「最大」或是「最小」權重的資料。&lt;br /&gt;
後兩種資料結構稱為&lt;strong&gt;Double-End Priority Queue(DEPQ)&lt;/strong&gt;，可以同時取得「權重最大」以及「權重最小」的資料。&lt;/p&gt;
&lt;p&gt;下ㄧ篇文章，將介紹比上述六種資料結構更初級的&lt;strong&gt;Binary Heap&lt;/strong&gt;來實現Min-Priority Queue。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch6&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5, Ch9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.bris.ac.uk/~montanar/teaching/dsa/dijkstra-handout.pdf"&gt;Ashley Montanaro：Priority queues and Dijkstra’s algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.yam.com/rockmanray/article/44952434"&gt;禪心劍氣相思骨：Priority Queue 解析1 - 從binary heap開始&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Priority_queue"&gt;Wikipedia：Priority Queue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Priority Queue系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html"&gt;Priority Queue：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category><category term="Priority Queue"></category><category term="Heap"></category><category term="Binary Tree"></category></entry><entry><title>Single-Source Shortest Path：on DAG(directed acyclic graph)</title><link href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html" rel="alternate"></link><updated>2016-03-02T16:12:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-02:SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將介紹在DAG(directed acyclic graph)上處理Single-Source Shortest Path問題之演算法，除了DAG之外，與之息息相關的&lt;strong&gt;Topological Sort&lt;/strong&gt;也會跑出來，再加上&lt;strong&gt;Path-Relaxation Property&lt;/strong&gt;，就能建構起本篇文章的演算法核心。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#terminology"&gt;名詞概念回顧&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#dag"&gt;DAG(directed acyclic graph)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#topo"&gt;Topological Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#property"&gt;Path-Relaxation Property&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#spdag"&gt;Single-Source Shortest Path in DAG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Shortest Path系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="terminology"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;名詞概念回顧&lt;/h2&gt;
&lt;p&gt;&lt;a name="dag"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;DAG(directed acyclic graph)&lt;/h3&gt;
&lt;p&gt;所謂的&lt;strong&gt;DAG(directed acyclic graph)&lt;/strong&gt;，就是&lt;strong&gt;不存在cycle&lt;/strong&gt;的directed graph，如圖一(a)與圖一(b)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="topo"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Topological Sort&lt;/h3&gt;
&lt;p&gt;若在&lt;strong&gt;DAG&lt;/strong&gt;上，存在一條從vertex(X)指向vertex(Y)的edge(X,Y)，那麼在&lt;strong&gt;Topological Sort&lt;/strong&gt;中，vertex(X)一定出現在vertex(Y)之前。&lt;br /&gt;
(關於DAG與Topological Sort的詳細介紹與演算法，請參考&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;。)&lt;/p&gt;
&lt;p&gt;試尋找圖一(a)之DAG的Topological Sort，如圖二(a)。可以確定的是，Topological Sort可能不唯一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;圖二(a)之Graph存在edge(4,1)，因此在Topological Sort中vertex(4)一定在vertex(1)之前。依此類推，可以觀察其餘vertex在Topological Sort裡的相互關係。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖二(b)為圖一(b)之DAG的Topological Sort。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="property"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Path-Relaxation Property&lt;/h3&gt;
&lt;p&gt;根據&lt;strong&gt;Path-Relaxation Property&lt;/strong&gt;：若從vertex(0)走到vertex(3)之最短路徑為&lt;span class="math"&gt;\(Path:0-1-2-3\)&lt;/span&gt;，那麼只要在對edge進行&lt;strong&gt;Relaxation&lt;/strong&gt;的順序出現「edge(0,1)&lt;span class="math"&gt;\(-\)&lt;/span&gt;edge(1,2)&lt;span class="math"&gt;\(-\)&lt;/span&gt;edge(2,3)」的順序，不管其他edge(0,2)、edge(1,3)是否也有進行&lt;strong&gt;Relaxation&lt;/strong&gt;，&lt;code&gt;distance[3]&lt;/code&gt;一定能夠更新至最短路徑&lt;span class="math"&gt;\(Path:0-1-2-3\)&lt;/span&gt;的weight，&lt;code&gt;distance[3]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(0,3)=w(0,1)+w(1,2)+w(2,3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;(詳細定義請參考&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathintrojian-jie.html"&gt;Single-Source Shortest Path：Intro(簡介)&lt;/a&gt;。)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="spdag"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Single-Source Shortest Path in DAG&lt;/h2&gt;
&lt;p&gt;有了以上概念之後，要在DAG上找到Single-Source Shortest Path就變得輕鬆寫意了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到DAG的Topological Sort；&lt;/li&gt;
&lt;li&gt;按照Topological Sort的vertex順序，對所有從該vertex出發連接至其餘vertex的edge進行&lt;strong&gt;Relaxation&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;大功告成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;為什麼這樣可行？&lt;/p&gt;
&lt;p&gt;因為在DAG中，不存在&lt;strong&gt;cycle&lt;/strong&gt;(若從vertex(X)離開後，就不可能再回到vertex(X))，所以路徑只有「一個方向」，因此最短路徑的方向一定也依循著DAG的「大方向」。以圖四(a)為例，DAG的「大方向」即為「由左至右」，從vertex(0)至vertex(6)。  &lt;/p&gt;
&lt;p&gt;而Topological Sort會把vertex按照「大方向的頭到尾」之順序排列，若按照此vertex順序，對所有與此vertex相連之edge進行&lt;code&gt;Relax()&lt;/code&gt;，就會從最短路徑的最前端edge開始，一路往最短路徑之尾端edge進行&lt;code&gt;Relax()&lt;/code&gt;，如此便滿足&lt;strong&gt;Path-Relaxation Property&lt;/strong&gt;， 因此，以上演算法可以得到最短路徑。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以下便按照上述演算法，在圖四(a)之DAG上找到Single-Source問題之最短路徑，見圖四(b)-(g)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(d)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(e)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(f)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(g)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後，由以上演算法找到的&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;如圖四(h)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(g)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;範例程式碼中包含：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Graph_SP&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本的資料項目：&lt;code&gt;predecessor&lt;/code&gt;、&lt;code&gt;distance&lt;/code&gt;、&lt;code&gt;num_vertex&lt;/code&gt;、&lt;code&gt;AdjList&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Relax()&lt;/code&gt;、&lt;code&gt;InitializeSingleSource()&lt;/code&gt;之功能與&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;所使用相同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DAG_SP()&lt;/code&gt;：尋找&lt;strong&gt;Shortest-Path Tree&lt;/strong&gt;的主要函式，功能如前一小節所述。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetTopologicalSort()&lt;/code&gt;：可以視為&lt;code&gt;DFS()&lt;/code&gt;的變形，主要功能是建立&lt;code&gt;color[]&lt;/code&gt;、&lt;code&gt;discover[]&lt;/code&gt;、&lt;code&gt;finish[]&lt;/code&gt;等資料項目，並把從&lt;code&gt;DAG_SP()&lt;/code&gt;接收來的資料項目&lt;code&gt;topologicalsort[]&lt;/code&gt;傳進&lt;code&gt;DFSVisit_TS()&lt;/code&gt;。&lt;br /&gt;
順便在找到&lt;code&gt;topologicalsort[]&lt;/code&gt;後，將&lt;code&gt;discover[]&lt;/code&gt;與&lt;code&gt;finish[]&lt;/code&gt;印出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DFSVisit_TS()&lt;/code&gt;：此為&lt;code&gt;DFSVisit()&lt;/code&gt;的變形，唯一修改的部分是在&lt;code&gt;finish[]&lt;/code&gt;更新後，多加了一行&lt;code&gt;array[count--] = vertex;&lt;/code&gt;，其中&lt;code&gt;count&lt;/code&gt;為&lt;code&gt;topologicalsort[]&lt;/code&gt;的&lt;strong&gt;index&lt;/strong&gt;，用意是要按照「探索結束」的先後，將vertex依序從&lt;code&gt;topologicalsort[]&lt;/code&gt;的尾端放到前端，如此一來，&lt;code&gt;topologicalsort[]&lt;/code&gt;所存放的vertex，就會按照&lt;code&gt;finish[]&lt;/code&gt;由大到小的順序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;：建立如圖四(a)之&lt;code&gt;AdjList&lt;/code&gt;，並進行&lt;code&gt;DAG_SP()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;(關於&lt;code&gt;DFS()&lt;/code&gt;與&lt;code&gt;DFSVisit()&lt;/code&gt;之概念與程式碼，請參考&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;。)&lt;br /&gt;
(關於&lt;strong&gt;Topological Sort&lt;/strong&gt;與&lt;code&gt;DFS()&lt;/code&gt;的關聯，請參考&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;。)&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;utility&amp;gt;          &lt;/span&gt;&lt;span class="c1"&gt;// for std::pair&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;          &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Max_Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;             &lt;span class="c1"&gt;// SP serves as Shortest Path&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintIntArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 以Start作為起點&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// 對edge(X,Y)進行Relax&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DAG_SP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                     &lt;span class="c1"&gt;// 需要 DFS, 加一個額外的Linked list&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;GetTopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit_TS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                     &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;GetTopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="c1"&gt;// count 為 topologicalsort[] 的 index&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;DFSVisit_TS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;print discover time:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintIntArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;print finish time:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintIntArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DFSVisit_TS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                           &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// set gray&lt;/span&gt;
    &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
         &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;DFSVisit_TS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// set black&lt;/span&gt;
    &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 產生Topological Sort&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DAG_SP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// distance[],predecessor[]的initialization&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;topologicalsort&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;GetTopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;topologicalsort&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;topologicalsort&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
             &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;print predecessor:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;print distance:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintIntArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Max_Distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;Graph_SP&lt;/span&gt; &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DAG_SP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// 以vertex(0)作為起點&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;discover&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;9&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
  &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;13&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="mi"&gt;10&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="nl"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上結果符合圖四(g)的預期。&lt;/p&gt;
&lt;p&gt;若嘗試以vertex(2)作為起點：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;g8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DAG_SP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;discover&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
  &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
  &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;13&lt;/span&gt;  &lt;span class="mi"&gt;10&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;9&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="nl"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
 &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;結果便如圖五，因為從vertex(2)走不到vertex(0)與vertex(1)，因此&lt;code&gt;distance[0]&lt;/code&gt;與&lt;code&gt;distance[1]&lt;/code&gt;仍維持起始值無限大(範例程式將無限大設為&lt;span class="math"&gt;\(100\)&lt;/span&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_DAG/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是&lt;strong&gt;在DAG(directed acyclic graph)中&lt;/strong&gt;處理Single-Source Shortest Path之演算法之介紹。&lt;br /&gt;
同樣地，只要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Relaxation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Convergence property&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path-relaxation property&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之概念，即可掌握此演算法的運作邏輯。  &lt;/p&gt;
&lt;p&gt;下一篇文章將介紹大魔王：&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;，如果讀者熟悉&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;的話，可能會有些幫助。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch24&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Shortest Path系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html"&gt;Shortest Path：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathbellman-ford-algorithm.html"&gt;Single-Source Shortest Path：Bellman-Ford Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html"&gt;Single-Source Shortest Path：on DAG(directed acyclic graph)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html"&gt;All-Pairs Shortest Path：Floyd-Warshall Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Shortest Path"></category><category term="Relaxation"></category><category term="DAG"></category></entry><entry><title>Single-Source Shortest Path：Bellman-Ford Algorithm</title><link href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathbellman-ford-algorithm.html" rel="alternate"></link><updated>2016-03-01T20:12:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-03-01:SecondRound/single-source-shortest-pathbellman-ford-algorithm.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章將介紹&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;來回應上一篇&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathintrojian-jie.html"&gt;Single-Source Shortest Path：Intro(簡介)&lt;/a&gt;的問題，演算法的概念主要圍繞在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Relaxation&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Convergence property&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path-relaxation property&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建議讀者可以先進&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathintrojian-jie.html#relax"&gt;傳送門&lt;/a&gt;精彩回顧一下。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#representation"&gt;Graph之表示法(representation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bf"&gt;Bellman-Ford Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#nc"&gt;檢查Graph中是否存在negative cycle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Shortest Path系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="representation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Graph之表示法(representation)&lt;/h2&gt;
&lt;p&gt;在&lt;a href=""&gt;BFS/DFS系列文章&lt;/a&gt;使用&lt;strong&gt;Adjacency List&lt;/strong&gt;代表Graph，不過edge上沒有weight，可以使用如下資料結構：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt;std::list&amp;lt;int&amp;gt;&amp;gt; AdjList;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=""&gt;MST系列文章&lt;/a&gt;的Graph利用&lt;strong&gt;Adjacency Matrix&lt;/strong&gt;，因此可以使用如下資料結構，把weight放進矩陣之元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; AdjMatrix;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章將利用&lt;strong&gt;Adjacency List&lt;/strong&gt;來代表weighted edge，方法是使用C++標準函式庫(STL)的&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;，使得&lt;code&gt;AdjList&lt;/code&gt;的資料結構更新為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt;std::list&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; AdjList;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若有一條從vertex(0)(&lt;code&gt;from&lt;/code&gt;)指向vertex(1)(&lt;code&gt;to&lt;/code&gt;)的edge(0,1)之weight為&lt;span class="math"&gt;\(5\)&lt;/span&gt;，若利用新的&lt;code&gt;AdjList&lt;/code&gt;表示，如圖一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;from&lt;/code&gt;以&lt;code&gt;std::vector&lt;/code&gt;的&lt;strong&gt;index&lt;/strong&gt;表示；&lt;/li&gt;
&lt;li&gt;每一個&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;都是一個&lt;code&gt;std::list&lt;/code&gt;的node；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;to&lt;/code&gt;放在&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;的第一個&lt;code&gt;int&lt;/code&gt;資料項；&lt;/li&gt;
&lt;li&gt;將&lt;strong&gt;weight&lt;/strong&gt;放在&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;的第二個&lt;code&gt;int&lt;/code&gt;資料項，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;關於&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;的用法，可以參考：&lt;a href="http://www.cplusplus.com/reference/utility/pair/?kw=pair"&gt;Cplusplus：std::pair&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bf"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Bellman-Ford Algorithm&lt;/h2&gt;
&lt;p&gt;根據&lt;strong&gt;Path-Relaxation Property&lt;/strong&gt;，考慮一條從vertex(0)到vertex(K)之路徑&lt;span class="math"&gt;\(P:v_0-v_1-...-v_K\)&lt;/span&gt;，如果在對path之edge進行&lt;code&gt;Relax()&lt;/code&gt;的順序中，&lt;strong&gt;曾經出現&lt;/strong&gt;edge(v&lt;sub&gt;0&lt;/sub&gt;,v&lt;sub&gt;1&lt;/sub&gt;)、edge(v&lt;sub&gt;1&lt;/sub&gt;,v&lt;sub&gt;2&lt;/sub&gt;)、...、edge(v&lt;sub&gt;K-1&lt;/sub&gt;,v&lt;sub&gt;K&lt;/sub&gt;)的順序，那麼這條path一定是最短路徑，滿足&lt;code&gt;distance[K]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(v_0,v_K)\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在對edge(v&lt;sub&gt;1&lt;/sub&gt;,v&lt;sub&gt;2&lt;/sub&gt;)進行&lt;code&gt;Relax()&lt;/code&gt;之前，只要已經對edge(v&lt;sub&gt;0&lt;/sub&gt;,v&lt;sub&gt;1&lt;/sub&gt;)進行過&lt;code&gt;Relax()&lt;/code&gt;，那麼，不管還有其餘哪一條edge已經進行過&lt;code&gt;Relax()&lt;/code&gt;，&lt;code&gt;distance[2]&lt;/code&gt;必定會等於&lt;span class="math"&gt;\(\delta(0,2)\)&lt;/span&gt;，因為&lt;strong&gt;Convergence property&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Bellman-Ford Algorihm&lt;/strong&gt;就用最直覺的方式滿足&lt;strong&gt;Path-Relaxation Property&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一共執行&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;次迴圈。&lt;/li&gt;
&lt;li&gt;在每一次迴圈裡，對「&lt;strong&gt;所有的edge&lt;/strong&gt;」進行&lt;code&gt;Relax()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;經過&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;次的「所有edge之&lt;code&gt;Relax()&lt;/code&gt;」後，必定能夠產生「按照最短路徑上之edge順序的&lt;code&gt;Relax()&lt;/code&gt;順序」，也就能夠得到最短路徑。&lt;ul&gt;
&lt;li&gt;由於從起點走到任一vertex之最短路徑，最多只會有&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;條edge，因此，執行&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;次迴圈必定能夠滿足「最壞情況」(worst case)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;
考慮如圖二(a)之Graph，以vertex(0)作為起點。&lt;br /&gt;
並且根據圖二(a)之&lt;strong&gt;Adjacency List&lt;/strong&gt;，得到在&lt;strong&gt;Bellman-Ford Algorihm&lt;/strong&gt;中對所有edge進行&lt;code&gt;Relax()&lt;/code&gt;之順序如圖二(b)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：根據圖二(a)之&lt;/strong&gt;&lt;code&gt;AdjList&lt;/code&gt;&lt;strong&gt;，對所有edge進行&lt;/strong&gt;&lt;code&gt;Relax()&lt;/code&gt;&lt;strong&gt;之順序。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
首先，對Graph的資料項目&lt;code&gt;distance&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;進行初始化，見圖二(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance&lt;/code&gt;：將起點vertex之&lt;code&gt;distance&lt;/code&gt;設為&lt;span class="math"&gt;\(0\)&lt;/span&gt;，並將其餘vertex之&lt;code&gt;distance&lt;/code&gt;設為無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)。&lt;ul&gt;
&lt;li&gt;如果在演算法結束後，某個vertex之&lt;code&gt;distance&lt;/code&gt;仍然無限大(&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;)，則表示Graph中沒有一條path能夠從起點vertex走到該vertex。&lt;/li&gt;
&lt;li&gt;回顧&lt;code&gt;Relax()&lt;/code&gt;，因為只有起點vertex(0)之&lt;code&gt;distance&lt;/code&gt;設為&lt;span class="math"&gt;\(0\)&lt;/span&gt;，其餘&lt;code&gt;distance&lt;/code&gt;都是無限大，因此，在進行「所有edge之&lt;code&gt;Relax()&lt;/code&gt;」時，一定是從與起點vertex(0)相連之edge先開始。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor&lt;/code&gt;：將所有vertex之&lt;code&gt;predecessor&lt;/code&gt;設為&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，表示目前還沒有&lt;code&gt;predecessor&lt;/code&gt;。對其餘vertex來說，可以想成還沒有被起點vertex找到。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
接著開始&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;次的迴圈，並在每次迴圈，都對「所有edge」進行&lt;code&gt;Relax()&lt;/code&gt;。&lt;br /&gt;
(此例，共&lt;span class="math"&gt;\(5\)&lt;/span&gt;次迴圈，每次按照圖二(b)之順序處理&lt;span class="math"&gt;\(10\)&lt;/span&gt;條edge)。&lt;/p&gt;
&lt;h3&gt;第一次迴圈(iteration#1)&lt;/h3&gt;
&lt;p&gt;對第一條edge(0,1)進行&lt;code&gt;Relax()&lt;/code&gt;，見圖三(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;distance[1]&lt;/code&gt;與&lt;code&gt;distance[0]+w(0,1)&lt;/code&gt;，發現」從vertex(0)走到vertex(1)」之成本較原先的成本低(原先的成本即為&lt;code&gt;distance[1]&lt;/code&gt;)，因此更新&lt;code&gt;distance[1]&lt;/code&gt;為&lt;code&gt;distance[0]+w(0,1)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;同時更新&lt;code&gt;predecessor[1]=0&lt;/code&gt;，表示vertex(1)是從vertex(0)走過去的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;對第二、三條edge(1,2)、edge(1,4)進行&lt;code&gt;Relax()&lt;/code&gt;，見圖三(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於&lt;code&gt;distance[2]&lt;/code&gt;與&lt;code&gt;distance[4]&lt;/code&gt;皆大於從vertex(1)走過去的成本，因此更新：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[2]=distance[1]+w(1,2)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distance[4]=distance[1]+w(1,4)&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;對第四、五條edge(2,4)、edge(2,5)進行&lt;code&gt;Relax()&lt;/code&gt;，見圖三(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於&lt;code&gt;distance[4]&lt;/code&gt;小於「從vertex(2)走過去的成本(&lt;code&gt;distance[2]+w(2,4)&lt;/code&gt;)，因此，仍維持從vertex(1)走到vertex(4)之路徑。&lt;/li&gt;
&lt;li&gt;而&lt;code&gt;distance[5]&lt;/code&gt;大於&lt;code&gt;distance[2]+w(2,5)&lt;/code&gt;，因此更新：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[5]=distance[2]+w(2,5)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor[5]=2&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;對第六條edge(3,2)進行&lt;code&gt;Relax()&lt;/code&gt;，見圖三(d)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顯然，「從vertex(1)走到vertex(2)」之成本&lt;code&gt;distance[2]&lt;/code&gt;遠小於「從vertex(3)走到vertex(2)」之成本&lt;code&gt;distance[3]+w(2,3)&lt;/code&gt;，因此，不更新抵達vertex(2)之路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;對第七、八條edge(4,3)、edge(4,5)進行&lt;code&gt;Relax()&lt;/code&gt;，見圖三(e)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於&lt;code&gt;distance[3]&lt;/code&gt;大於從vertex(4)走到vertex(3)的成本(&lt;code&gt;distance[4]+w(4,3)&lt;/code&gt;)，因此更新：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[3]=distance[4]+w(4,3)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor[3]=4&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;而且&lt;code&gt;distance[5]&lt;/code&gt;也大於&lt;code&gt;distance[4]+w(4,5)&lt;/code&gt;，表示「從vertex(4)走到vertex(5)」會比「從vertex(2)走到vertex(5)」還近，便更新：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[5]=distance[4]+w(4,5)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor[5]=4&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;對第九、十條edge(5,0)、edge(5,1)進行&lt;code&gt;Relax()&lt;/code&gt;，見圖三(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較&lt;code&gt;distance&lt;/code&gt;及edge之&lt;strong&gt;weight&lt;/strong&gt;後發現，從vertex(5)走到vertex(0)與vertex(1)之成本皆高於當前走到此二vertex之路徑，因此不更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過了第一次迴圈的洗禮，大致能夠掌握&lt;code&gt;Relax()&lt;/code&gt;的精髓：如果有比目前的成本更低的路徑，就選擇那條路徑。&lt;br /&gt;
例如，圖三(c)中，原本從vertex(0)走到vertex(5)的路徑是&lt;span class="math"&gt;\(Path:0-1-2-5\)&lt;/span&gt;，但是在圖三(e)時，發現了更短的路徑&lt;span class="math"&gt;\(Path:0-1-4-5\)&lt;/span&gt;，便更新其成為目前「從vertex(0)走到vertex(5)」的最短路徑。&lt;/p&gt;
&lt;p&gt;還有沒有可能更新出成本更低的路徑？  &lt;/p&gt;
&lt;p&gt;當然有，因為第一次迴圈的&lt;code&gt;Relax()&lt;/code&gt;明顯沒有更新到和edge(3,2)有關路徑，其原因在於，&lt;code&gt;Relax()&lt;/code&gt;&lt;strong&gt;進行的edge順序&lt;/strong&gt;。&lt;br /&gt;
在第一次迴圈中，是先對edge(3,2)進行&lt;code&gt;Relax()&lt;/code&gt;，不過此時的&lt;code&gt;distance[3]&lt;/code&gt;還是無限大，因此沒有作用，之後才更新出「從vertex(4)走到vertex(3)」的路徑。&lt;br /&gt;
就圖三(f)看來，&lt;code&gt;distance[2]&lt;/code&gt;為&lt;span class="math"&gt;\(11\)&lt;/span&gt;，而&lt;span class="math"&gt;\(Path:0-1-4-3-2\)&lt;/span&gt;之成本只有&lt;span class="math"&gt;\(6\)&lt;/span&gt;，顯然是低於當前的路徑&lt;span class="math"&gt;\(Path:0-1-2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因此需要&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;次迴圈，以確保演算法一定能找到最短路徑。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
第二次直到第五次迴圈的邏輯同上，在此就不再贅述。&lt;/p&gt;
&lt;p&gt;最後得到的最短路徑之&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;如圖三(g)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據圖三(g)，從vertex(0)走到Graph中其餘vertex之最短路徑為&lt;span class="math"&gt;\(Path:0-1-4-3-2-5\)&lt;/span&gt;，若把&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;中，每一次迴圈對所有edge進行&lt;code&gt;Relax()&lt;/code&gt;之順序攤開，如圖三(h)，可以驗證&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;確實滿足&lt;strong&gt;Path-Relaxation Property&lt;/strong&gt;，按照最短路徑之順序對edge進行&lt;code&gt;Relax()&lt;/code&gt;。&lt;br /&gt;
(&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;就是暴力解決，當然會滿足。)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_BellmanFord/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;程式碼包含幾個部分：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Graph_SP&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;AdjList&lt;/code&gt;，並利用&lt;code&gt;std::pair&amp;lt;int,int&amp;gt;&lt;/code&gt;儲存edge的weight。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InitializeSingleSource(int Start)&lt;/code&gt;：對資料項目&lt;code&gt;distance&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;進行初始化，並以&lt;code&gt;int Start&lt;/code&gt;作為最短路徑之起點。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Relax()&lt;/code&gt;：對edge進行Relaxation的主要函式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BellmanFord()&lt;/code&gt;：進行&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;的主要函式，內容如前一小節所述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及&lt;code&gt;main()&lt;/code&gt;：建立如圖二(a)之&lt;code&gt;AdjList&lt;/code&gt;，並進行&lt;code&gt;BellmenFord()&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;utility&amp;gt;          &lt;/span&gt;&lt;span class="c1"&gt;// for std::pair&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;          &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Max_Distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;             &lt;span class="c1"&gt;// SP serves as Shortest Path&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 以Start作為起點&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// 對edge(X,Y)進行Relax&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;BellmanFord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 以Start作為起點&lt;/span&gt;
                                                &lt;span class="c1"&gt;// if there is negative cycle, return false&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BellmanFord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// |V-1|次的iteration&lt;/span&gt;
        &lt;span class="c1"&gt;// for each edge belonging to E(G)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;             &lt;span class="c1"&gt;// 把AdjList最外層的vector走一遍&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                 &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;          &lt;span class="c1"&gt;// 各個vector中, 所有edge走一遍&lt;/span&gt;
                &lt;span class="n"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// check if there is negative cycle&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
             &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// i是from, *itr是to&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// print predecessor[] &amp;amp; distance[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor[]:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;distance[]:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Max_Distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;Graph_SP&lt;/span&gt; &lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g7&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BellmanFord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;There is no negative cycle.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;There is negative cycle.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="n"&gt;There&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt; &lt;span class="n"&gt;negative&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt; 
&lt;a name="nc"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;檢查Graph中是否存在negative cycle&lt;/h3&gt;
&lt;p&gt;聰明的讀者一定已經發現了，&lt;code&gt;BellmanFord()&lt;/code&gt;還有個功能，可以檢查Graph中是否存在&lt;strong&gt;negative cycle&lt;/strong&gt;。&lt;br /&gt;
上一篇文章&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathintrojian-jie.html#limit"&gt;Single-Source Shortest Path：Intro(簡介)&lt;/a&gt;曾經提到，塵世間最痛苦的事情莫過於在處理Single-Source Shortest Path問題時碰上&lt;strong&gt;negative cycle&lt;/strong&gt;，因為&lt;strong&gt;negative cycle&lt;/strong&gt;存在會使得最短路徑出現&lt;span class="math"&gt;\(-\infty\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;若存在從vertex(from)指向vertex(to)的edge(from,to)，並具有weight，根據&lt;code&gt;Relax()&lt;/code&gt;的運作原則，：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;distance[to]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;gt;\)&lt;/span&gt;&lt;code&gt;distance[from]+weight&lt;/code&gt;，便更新&lt;code&gt;distance[to]=distance[from]+weight&lt;/code&gt;」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在對Graph中所有edge進行&lt;code&gt;Relax()&lt;/code&gt;後，所有edge(from,to)所連結的兩個vertex之&lt;code&gt;distance&lt;/code&gt;必定滿足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[to]&lt;/code&gt;&lt;span class="math"&gt;\(\leq\)&lt;/span&gt;&lt;code&gt;distance[from]+weight&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而&lt;code&gt;BellmanFord()&lt;/code&gt;的檢查方法，便是在&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;次「對所有edge進行&lt;code&gt;Relax()&lt;/code&gt;」後，檢查，若存在任何一條edge(from,to)所連結的兩個vertex之&lt;code&gt;distance&lt;/code&gt;關係為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[to]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;gt;\)&lt;/span&gt;&lt;code&gt;distance[from]+weight&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就表示存在某一條edge之weight永遠可以讓該edge連結之vertex的&lt;code&gt;distance&lt;/code&gt;下降，因此Graph中必定存在negative cycle。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;之介紹。&lt;br /&gt;
只要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Relaxation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Convergence property&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path-relaxation property&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之概念，即可掌握&lt;strong&gt;Bellman-Ford Algorithm&lt;/strong&gt;的運作邏輯。&lt;/p&gt;
&lt;p&gt;下一篇文章將介紹的是，&lt;strong&gt;在DAG(directed acyclic graph)中&lt;/strong&gt;處理Single-Source Shortest Path之演算法。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch24&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Shortest_path_problem"&gt;Wikipedia：Shortest path problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cplusplus.com/reference/utility/pair/?kw=pair"&gt;Cplusplus：std::pair&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Shortest Path系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html"&gt;Shortest Path：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathbellman-ford-algorithm.html"&gt;Single-Source Shortest Path：Bellman-Ford Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html"&gt;Single-Source Shortest Path：on DAG(directed acyclic graph)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html"&gt;All-Pairs Shortest Path：Floyd-Warshall Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Shortest Path"></category><category term="Relaxation"></category></entry><entry><title>Shortest Path：Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html" rel="alternate"></link><updated>2016-02-29T20:12:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-29:SecondRound/shortest-pathintrojian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;如果非要在這個章節加上一份先備知識，我會說是&lt;a href="https://www.google.com.tw/maps"&gt;Google Map&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sp"&gt;最短路徑問題(Shortest Path)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#limit"&gt;限制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#property"&gt;特徵&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#relax"&gt;觀念：Relaxation&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#triangle"&gt;Triangle inequality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#upper-bound"&gt;Upper-Bound property&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#convergence"&gt;Convergence property&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#path-relaxation"&gt;Path-relaxation property&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#trailer"&gt;精彩預告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Shortest Path系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="sp"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;最短路徑問題(Shortest Path)&lt;/h2&gt;
&lt;p&gt;為了解決較為廣義的情境，接下來討論的最短路徑問題將考慮的是一個&lt;strong&gt;weighted directed graph&lt;/strong&gt;，以weight總和表示path之成本，並以具有方向性之edge表示兩個vertex之間的關係。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;undirected graph的問題能夠以directed graph的模型解決，反之則無法。&lt;/li&gt;
&lt;li&gt;不具weight的edge也能夠以weighted edge模擬(將全部weight設為相同數值即可)，反之則無法。&lt;/li&gt;
&lt;li&gt;可以視為只能處理unweighted graph之BFS/DFS的擴充包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定義名詞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;path之weight：若有一條&lt;span class="math"&gt;\(Path:0-1-2-...-K\)&lt;/span&gt;，定義其weight為所有edge之weight總和，&lt;span class="math"&gt;\(w(path)=\sum_{i=1}^{K}w(i-1,i)\)&lt;/span&gt;，如圖一。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最短路徑之成本&lt;span class="math"&gt;\(w(path)=\delta(X,Y)\)&lt;/span&gt;：在Graph上，所有從vertex(X)出發抵達vertex(Y)的path中，具有最小weight之path，稱為最短路徑，其weight滿足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\delta(X,Y)=\min\)&lt;/span&gt;{&lt;span class="math"&gt;\(w(path)\)&lt;/span&gt;, for all path from X to Y}。&lt;br /&gt;
(可能有多條path之weight皆為極小值，那麼這些path都是最短路徑。)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若&lt;span class="math"&gt;\(\delta(X,Y)=\infty\)&lt;/span&gt;，則表示無法從vertex(X)走到vertex(Y)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據出發的vertex(稱為source)與終點vertex(稱為destination)之數量選擇，可以將最短路徑問題分成四類：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Single-Pair Shortest Path&lt;/strong&gt;：從單一vertex，抵達某個特定vertex之最短路徑，此為第二種問題的子問題；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single-Source Shortest Path&lt;/strong&gt;：從單一vertex，抵達Graph中其餘所有vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single-Destination Shortest Path&lt;/strong&gt;：從Graph中的每一個vertex抵達某個特定vertex之最短路徑：&lt;ul&gt;
&lt;li&gt;此為第二種問題之變形，只要把edge的方向相反，也就是在&lt;strong&gt;G&lt;sup&gt;T&lt;/sup&gt;&lt;/strong&gt;上，執行第二種問題之演算法即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All-Pairs Shortest Path&lt;/strong&gt;：Graph中的所有vertex抵達其餘所有vertex之最短路徑。&lt;ul&gt;
&lt;li&gt;若把每一個vertex都當作起點，即可利用第二種問題之方法解決。&lt;/li&gt;
&lt;li&gt;不過之後將介紹的&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;有更好的答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;綜合以上，先學第二種問題的演算法：以單一vertex為起點，抵達Graph中的其餘所有vertex之最短路徑，再學第四種問題的&lt;strong&gt;Floyd-Warshall Algorithm&lt;/strong&gt;(以及其他高效率的演算法)，就是最明智的選擇。(推銷成功)&lt;/p&gt;
&lt;p&gt;先來看個簡單的&lt;strong&gt;Single-Source Shortest Path&lt;/strong&gt;範例：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如圖二(a)，考慮一個weighted directed graph，若以vertex(0)為起點，要找到從vertex(0)抵達Graph中其餘vertex的最短路徑，結果便如圖二(b)。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考慮從vertex(0)走到vertex(2)：path&lt;span class="math"&gt;\(:0-1-2\)&lt;/span&gt;的edge數最少，但是weight總和是&lt;span class="math"&gt;\(11\)&lt;/span&gt;，而edge數較多的&lt;span class="math"&gt;\(Path:0-1-4-3-2\)&lt;/span&gt;的weight總和只有&lt;span class="math"&gt;\(6\)&lt;/span&gt;，才是從vertex(0)走到vertex(2)的最短路徑。&lt;/li&gt;
&lt;li&gt;原因在於weight有負值(negative value)，所以edge越多的path，weight總和不見得越大(經過某些路徑使得整體成本降低)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：path上之edge越少，不見得weight總和越小。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如圖二(b)所示，在處理最短路徑問題時，最基本需要用到兩個資料項目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[]&lt;/code&gt;：記錄從起點vertex，經過具有weight之edge，走到其餘vertex之「距離」，也就是該條path之weight。若有一條&lt;span class="math"&gt;\(Path:0-1-2\)&lt;/span&gt;，則path之weight總和即記錄在&lt;code&gt;distance[2]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor[]&lt;/code&gt;：除了距離之外，還希望能夠回溯路徑，因此需要記錄vertex之&lt;code&gt;predecessor&lt;/code&gt;，並以此得到&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於最短路徑一定&lt;strong&gt;不包含cycle&lt;/strong&gt;，&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;會是一棵&lt;strong&gt;Shortest-Path Tree&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;起點vertex即為&lt;strong&gt;root&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;從&lt;strong&gt;root&lt;/strong&gt;到其餘vertex的path必定是唯一的最短路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(若Graph上出現&lt;span class="math"&gt;\(\delta(X,Y)=\infty\)&lt;/span&gt;的情況，&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;會是&lt;strong&gt;Shortest-Path Forest&lt;/strong&gt;。)&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="limit"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;限制&lt;/h3&gt;
&lt;p&gt;為什麼最短路徑一定&lt;strong&gt;不包含cycle&lt;/strong&gt;？  &lt;/p&gt;
&lt;p&gt;由於weight只要求是實數(real number)，weight可正可負，因此Graph中可能出現&lt;strong&gt;weight總和為正&lt;/strong&gt;的cycle與&lt;strong&gt;weight總和為負&lt;/strong&gt;的cycle。&lt;/p&gt;
&lt;p&gt;考慮圖三(a)，cycle&lt;span class="math"&gt;\(:1-2-3\)&lt;/span&gt;之weight為&lt;span class="math"&gt;\(10\)&lt;/span&gt;，若path經過此cycle，weight之總和必定會增加，此path不會是最短路徑。考慮從vertex(0)走到vertex(4)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:0-1-2-3-4\)&lt;/span&gt;之weight為&lt;span class="math"&gt;\(10\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;經過一次cycle，&lt;span class="math"&gt;\(Path:0-1-2-3-1-2-3-4\)&lt;/span&gt;之weight為&lt;span class="math"&gt;\(20\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;考慮圖三(b)，cycle&lt;span class="math"&gt;\(:1-2-3\)&lt;/span&gt;之weight為&lt;span class="math"&gt;\(-6\)&lt;/span&gt;，表示path經過此cycle，weight之總和就會減少，而且經過越多次，weight總和越少，所以永遠不會有最短路徑，&lt;span class="math"&gt;\(\delta(X,Y)=-\infty\)&lt;/span&gt;。考慮從vertex(0)走到vertex(4)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Path:0-1-2-3-4\)&lt;/span&gt;之weight為&lt;span class="math"&gt;\(4\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;經過一次cycle，&lt;span class="math"&gt;\(Path:0-1-2-3-1-2-3-4\)&lt;/span&gt;之weight為&lt;span class="math"&gt;\(-2\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;經過兩次cycle，&lt;span class="math"&gt;\(Path:0-1-2-3-1-2-3-1-2-3-4\)&lt;/span&gt;之weight為&lt;span class="math"&gt;\(-8\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;因此，在考慮最短路徑問題時，問題之Graph可以有總和為正值的cycle，但是不能有總和為負值的cycle。  &lt;/p&gt;
&lt;p&gt;而演算法所挑選出來的最短路徑之Predecessor Subgraph，一定不包含cycle。&lt;/p&gt;
&lt;p&gt;&lt;a name="property"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;特徵&lt;/h3&gt;
&lt;p&gt;最短路徑除了&lt;strong&gt;不會有cycle&lt;/strong&gt;外，還有兩點特徵值得一提。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特徵一&lt;/strong&gt;：因為最短路徑不存在cycle，在共有&lt;span class="math"&gt;\(V\)&lt;/span&gt;個vertex之Graph中，從vertex(X)走到vertex(Y)的最短路徑，至多只會包含&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;條edge。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖二(b)，從vertex(0)走到vertex(5)的paht上，共有&lt;span class="math"&gt;\(5\)&lt;/span&gt;條edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此種情形發生在&lt;strong&gt;Shortest-Path Tree&lt;/strong&gt;退化成Linked list的時候。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特徵二&lt;/strong&gt;：。若在Graph上，存在一條從vertex(0)走到vertex(K)的最短路徑，&lt;span class="math"&gt;\(P:v_0-v_1-v_2-...-v_K\)&lt;/span&gt;，並定義所有path上的vertex所形成的&lt;strong&gt;subpath&lt;/strong&gt;為&lt;span class="math"&gt;\(P_{ij}:v_i-v_{i+1}-...-v_j\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(1\leq i\leq j\leq K\)&lt;/span&gt;，那麼每一條&lt;strong&gt;subpath&lt;/strong&gt;都會是最短路徑。&lt;br /&gt;
白話文：最短路徑必定是由較小段的最短路徑(subpath)所連結起來的。換句話說，由較小段的最短路徑(subpath)接起來的路徑必定仍然是最短路徑。&lt;/p&gt;
&lt;p&gt;圖二(b)中，從vertex(0)走到vertex(5)之最短路徑為：&lt;span class="math"&gt;\(P:v_0-v_1-v_4-v_3-v_2-v_5\)&lt;/span&gt;，那麼其中的任何一條path，都是兩個vertex之間的最短距離：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;從vertex(1)走到vertex(2)之最短路徑：&lt;span class="math"&gt;\(P:v_1-v_4-v_3-v_2\)&lt;/span&gt;，weight總和為&lt;span class="math"&gt;\(1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;從vertex(4)走到vertex(5)之最短路徑：&lt;span class="math"&gt;\(P:v_4-v_3-v_2-v_5\)&lt;/span&gt;，weight總和為&lt;span class="math"&gt;\(3\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上將「能夠考慮最短路徑問題」的Graph形式，以及「最短路徑之&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;」的特徵介紹完畢。&lt;/p&gt;
&lt;p&gt;接著要介紹尋找最短路徑之演算法核心概念：&lt;strong&gt;Relaxation&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="relax"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;觀念：Relaxation&lt;/h2&gt;
&lt;p&gt;見圖四(a)，現從vertex(S)作為起點，欲尋找抵達vertex(X)與vertex(Y)之最短路徑。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;其中，vertex(X)之最短路徑只有一種可能，&lt;span class="math"&gt;\(\delta(S,X)=w(S,X)\)&lt;/span&gt;。&lt;br /&gt;
而vertex(Y)可以從vertex(S)或者vertex(X)抵達，因此最短路徑&lt;span class="math"&gt;\(\delta(S,Y)\)&lt;/span&gt;有兩種可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\delta(S,Y)=w(S,Y)\)&lt;/span&gt;：vertex(Y)經由vertex(S)直接抵達。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\delta(S,Y)=w(S,X)+w(X,Y)\)&lt;/span&gt;：vertex(S)先經過vertex(X)，再到vertex(Y)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這兩條path中，weight最小的path即是最短路徑。&lt;br /&gt;
找到最短路徑的方法很直觀，只要比較這兩條路徑的weight，挑weight小的path即可。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以圖四(b)為例，首先從vertex(S)出發，發現其與vertex(X)、vertex(Y)皆有edge相連，便更新兩個vertex的&lt;code&gt;distance&lt;/code&gt;為兩條相連edge之weight：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[Y]=w(S,Y)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distance[X]=w(S,X)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著考慮經過vertex(X)再到vertex(Y)之path有沒有可能成本較低，便比較&lt;code&gt;distance[Y]&lt;/code&gt;與&lt;code&gt;distance[X]+w(X,Y)&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;distance[Y]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;gt;\)&lt;/span&gt;&lt;code&gt;distance[X]+w(X,Y)&lt;/code&gt;，則表示&lt;span class="math"&gt;\(P:S-X-Y\)&lt;/span&gt;之成本小於&lt;span class="math"&gt;\(P:S-Y\)&lt;/span&gt;，因此從vertex(S)經過vertex(X)再到vertex(Y)才是最短路徑，便更新&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distance[Y]=distance[X]+w(X,Y)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor[Y]=X&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反之，若&lt;code&gt;distance[Y]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;distance[X]+w(X,Y)&lt;/code&gt;，表示&lt;span class="math"&gt;\(P:S-Y\)&lt;/span&gt;之成本小於&lt;span class="math"&gt;\(P:S-X-Y\)&lt;/span&gt;，則不需要更新兩個資料項目，目前的路徑已經是最短路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的「比較&lt;code&gt;distance&lt;/code&gt;後決定是否更新&lt;code&gt;distance&lt;/code&gt;(與&lt;code&gt;predecessor&lt;/code&gt;)」步驟，就是&lt;strong&gt;Relaxation&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Relax()&lt;/code&gt;之範例程式碼如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="c1"&gt;// Relax() as a member function of class Graph_SP&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_SP&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Relax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
根據&lt;strong&gt;Relaxation&lt;/strong&gt;可以衍生出幾個性質：&lt;/p&gt;
&lt;p&gt;&lt;a name="triangle"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Triangle inequality&lt;/h3&gt;
&lt;p&gt;經過&lt;strong&gt;Relaxation&lt;/strong&gt;，並得到最短路徑後，任意兩個在Grpah上之vertex(X)與vertex(Y)，若存在edge(X,Y)從vertex(X)指向vertex(Y)，必定滿足以下關係(假設vertex(S)為起點)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\delta(S,Y)\leq \delta(S,X)+w(X,Y)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="upper-bound"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Upper-Bound property&lt;/h3&gt;
&lt;p&gt;一旦從vertex(S)抵達vertex(X)之path已經更新至最短路徑&lt;span class="math"&gt;\(\delta(S,X)\)&lt;/span&gt;，那麼&lt;code&gt;distance[X]&lt;/code&gt;將不再更新，保持&lt;code&gt;distance[X]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(S,X)\)&lt;/span&gt;至演算法程序結束。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;觀察&lt;code&gt;Relax()&lt;/code&gt;的&lt;code&gt;if&lt;/code&gt;條件式，若新的path之weight比原有的path之weight還大，就不更新&lt;code&gt;distance&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="convergence"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Convergence property&lt;/h3&gt;
&lt;p&gt;假定Graph上存在從vertex(X)指向vertex(Y)之edge(X,Y)，並且從起點vertex走到vertex(Y)之最短路徑包含這條edge。&lt;br /&gt;
若在對edge(X,Y)進行&lt;code&gt;Relax()&lt;/code&gt;之前，從vertex(S)到達vertex(X)的path就已經滿足最短路徑，&lt;code&gt;distance[X]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(S,X)\)&lt;/span&gt;，那麼在對edge(X,Y)進行&lt;code&gt;Relax()&lt;/code&gt;後，必定得到從vertex(S)走到vertex(Y)之最短路徑，並更新&lt;code&gt;distance[Y]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(S,Y)\)&lt;/span&gt;，而且至此之後，&lt;code&gt;distance[Y]&lt;/code&gt;將不會再被更新。&lt;/p&gt;
&lt;p&gt;如圖五(a)，&lt;span class="math"&gt;\(Path=S-X-Y\)&lt;/span&gt;是從vertex(S)走到vertex(Y)的最短路徑，並且在對edge(X,Y)進行&lt;code&gt;Relax()&lt;/code&gt;之前，從vertex(S)走到vertex(X)之path已經是最短路徑，&lt;code&gt;distance[X]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(S,X)\)&lt;/span&gt;，那麼，此時對edge(X,Y)進行&lt;code&gt;Relax()&lt;/code&gt;，必定能得到從vertex(S)走到vertex(Y)之最短路徑，&lt;code&gt;distance[Y]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(S,Y)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;但是若從vertex(S)走到vertex(Y)之最短路徑不包含edge(X,Y)，那麼即使在對edge(X,Y)做&lt;code&gt;Relax()&lt;/code&gt;之前，&lt;code&gt;distance[X]&lt;/code&gt;已經等於&lt;span class="math"&gt;\(\delta(S,X)\)&lt;/span&gt;，&lt;code&gt;distance[Y]&lt;/code&gt;仍然不更新。&lt;/p&gt;
&lt;p&gt;這表示，&lt;code&gt;distance[Y]&lt;/code&gt;已經等於&lt;span class="math"&gt;\(\delta(S,Y)\)&lt;/span&gt;，如圖五(b)。或者，從vertex(S)走到vertex(Y)之最短路徑會從其他vertex走到vertex(Y)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/ShortestPath_fig/SingleSource_intro/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="path-relaxation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Path-relaxation property&lt;/h3&gt;
&lt;p&gt;考慮一條從vertex(0)到vertex(K)之路徑&lt;span class="math"&gt;\(P:v_0-v_1-...-v_K\)&lt;/span&gt;，如果在對path之edge進行&lt;code&gt;Relax()&lt;/code&gt;的順序中，&lt;strong&gt;曾經出現&lt;/strong&gt;edge(v&lt;sub&gt;0&lt;/sub&gt;,v&lt;sub&gt;1&lt;/sub&gt;)、edge(v&lt;sub&gt;1&lt;/sub&gt;,v&lt;sub&gt;2&lt;/sub&gt;)、...、edge(v&lt;sub&gt;K-1&lt;/sub&gt;,v&lt;sub&gt;K&lt;/sub&gt;)的順序，那麼這條path一定是最短路徑，滿足&lt;code&gt;distance[K]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(v_0,v_K)\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在對edge(v&lt;sub&gt;1&lt;/sub&gt;,v&lt;sub&gt;2&lt;/sub&gt;)進行&lt;code&gt;Relax()&lt;/code&gt;之前，只要已經對edge(v&lt;sub&gt;0&lt;/sub&gt;,v&lt;sub&gt;1&lt;/sub&gt;)進行過&lt;code&gt;Relax()&lt;/code&gt;，那麼，不管還有對其餘哪一條edge進行&lt;code&gt;Relax()&lt;/code&gt;，&lt;code&gt;distance[2]&lt;/code&gt;必定會等於&lt;span class="math"&gt;\(\delta(0,2)\)&lt;/span&gt;，因為&lt;strong&gt;Convergence property&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，現有一條從vertex(0)走到vertex(3)之最短路徑為&lt;span class="math"&gt;\(Path:0-1-2-3\)&lt;/span&gt;，根據&lt;strong&gt;Convergence property&lt;/strong&gt;，只要在對edge(1,2)進行&lt;code&gt;Relax()&lt;/code&gt;之前，已經對edge(0,1)進行&lt;code&gt;Relax()&lt;/code&gt;，如此便保證&lt;span class="math"&gt;\(Path:0-1-2\)&lt;/span&gt;一定是最短路徑，此時再對edge(2,3)進行&lt;code&gt;Relax()&lt;/code&gt;，便能找到&lt;span class="math"&gt;\(Path:0-1-2-3\)&lt;/span&gt;。&lt;br /&gt;
換言之，只要確保&lt;code&gt;Relax()&lt;/code&gt;的過程曾經出現「edge(0,1)-&amp;gt;edge(1,2)-&amp;gt;edge(2,3)」的順序，不需理會中間是否有其他edge進行&lt;code&gt;Relax()&lt;/code&gt;，即使有也不影響最後結果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;Relax()&lt;/code&gt;順序：「edge(2,3)-&amp;gt;&lt;strong&gt;edge(0,1)&lt;/strong&gt;-&amp;gt;edge(2,3)-&amp;gt;&lt;strong&gt;edge(1,2)&lt;/strong&gt;-&amp;gt;&lt;strong&gt;edge(2,3)&lt;/strong&gt;」仍可以得到最短路徑，&lt;code&gt;distance[3]&lt;/code&gt;&lt;span class="math"&gt;\(=\delta(0,3)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="trailer"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;精彩預告&lt;/h2&gt;
&lt;p&gt;接下來三篇文章，將介紹處理&lt;strong&gt;Single-Source Shortest Path&lt;/strong&gt;的三種演算法，各別的適用情境與時間複雜度如下：&lt;br /&gt;
(注意：一律不允許&lt;strong&gt;negative cycle&lt;/strong&gt;出現)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Bellmem-Ford Algorithm&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;只要Graph中沒有&lt;strong&gt;negative cycle&lt;/strong&gt;，即使有&lt;strong&gt;positive cycle&lt;/strong&gt;、edge有&lt;strong&gt;negative weight&lt;/strong&gt;，皆可使用。&lt;/li&gt;
&lt;li&gt;時間複雜度：&lt;span class="math"&gt;\(O(VE)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shortest Path on DAG&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;只要Graph中沒有&lt;strong&gt;cycle&lt;/strong&gt;，即使edge有&lt;strong&gt;negative weight&lt;/strong&gt;，亦可使用。&lt;/li&gt;
&lt;li&gt;時間複雜度：&lt;span class="math"&gt;\(O(V+E)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dijkstra's Algorithm&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;只要Graph中的edge沒有&lt;strong&gt;negative weight&lt;/strong&gt;，即使有&lt;strong&gt;cycle&lt;/strong&gt;，亦可使用。&lt;/li&gt;
&lt;li&gt;時間複雜度，根據實現&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;之資料結構將有所不同：&lt;ul&gt;
&lt;li&gt;若使用普通矩陣(array)，需要&lt;span class="math"&gt;\(O(E+V^2)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;若使用&lt;strong&gt;Binary Heap&lt;/strong&gt;，需要&lt;span class="math"&gt;\(O((E+V)\log V)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;若使用&lt;strong&gt;Fibonacci Heap&lt;/strong&gt;，只需要&lt;span class="math"&gt;\(O(E+V\log V)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;將以上描述做成表格，見表一與表二：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;有positive cycle&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;沒有positive cycle&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;有negative weight&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;Bellman-Ford&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;on DAG&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;沒有negative weight&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;Dijkstra&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;All three&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：三種演算法之使用情境比較&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Bellman-Ford&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;on DAG&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;Dijkstra(worst)&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
&lt;th&gt;&amp;nbsp;&amp;nbsp;Dijkstra(best)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(VE)\)&lt;/span&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(V+E)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(E+V^2)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&amp;nbsp;&lt;span class="math"&gt;\(O(E+V\log V)\)&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表二：三種演算法之時間複雜度比較&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch24&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Shortest_path_problem"&gt;Wikipedia：Shortest path problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=UHd1jHjPL7E"&gt;大話西遊之仙履奇緣&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Shortest Path系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html"&gt;Shortest Path：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathbellman-ford-algorithm.html"&gt;Single-Source Shortest Path：Bellman-Ford Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html"&gt;Single-Source Shortest Path：on DAG(directed acyclic graph)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html"&gt;All-Pairs Shortest Path：Floyd-Warshall Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Intro"></category><category term="Shortest Path"></category><category term="Relaxation"></category></entry><entry><title>Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue</title><link href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html" rel="alternate"></link><updated>2016-02-25T20:33:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-25:SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html"&gt;Minimum Spanning Tree：Prim's Algorithm&lt;/a&gt;中介紹過&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;的概念，也提供了範例程式碼。&lt;/p&gt;
&lt;p&gt;本篇文章將補充以稍微優秀一點的資料結構：&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;實現&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;中的「取最小值(&lt;strong&gt;ExtractMin&lt;/strong&gt;)」的方法。&lt;/p&gt;
&lt;p&gt;上一篇文章的&lt;code&gt;MinKeyExtract()&lt;/code&gt;需要把整個&lt;code&gt;key[]&lt;/code&gt;走過一次，時間複雜度為&lt;span class="math"&gt;\(O(|V|)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(|V|\)&lt;/span&gt;表示vertex的數量。&lt;br /&gt;
而以Binary Heap實現的&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;，在「取最小值」的時候只要&lt;span class="math"&gt;\(O(\log{|V|})\)&lt;/span&gt;，即為以Binary Tree解讀Binary Heap的「樹高」，理論上應該會比較有效率。&lt;/p&gt;
&lt;p&gt;建議讀者可以先閱讀以下文章，：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;：MST的基本概念，以及證明用的&lt;strong&gt;Theorem1&lt;/strong&gt;與&lt;strong&gt;Corollary2&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html"&gt;Minimum Spanning Tree：Prim's Algorithm&lt;/a&gt;：&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;的基本概念。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;：以&lt;strong&gt;Binary Heap&lt;/strong&gt;實現&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;Prim's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;MST系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Prim's Algorithm&lt;/h2&gt;
&lt;p&gt;以下不再贅述&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;的概念，直接以圖示觀察Min-Priority Queue的作用。&lt;/p&gt;
&lt;p&gt;觀察圖一(a)到圖一(m)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(g)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(h)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(i)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(j)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(k)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(l)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(m)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;以下的程式範例包含了&lt;code&gt;class BinaryHeap&lt;/code&gt;、&lt;code&gt;class Graph_MST&lt;/code&gt;與&lt;code&gt;main()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class BinaryHeap&lt;/code&gt;的概念與程式碼與&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;的內容相同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Graph_MST&lt;/code&gt;建立Graph，其中&lt;code&gt;Prim_MinQueue()&lt;/code&gt;即為尋找MST的&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;之函式主體。&lt;/p&gt;
&lt;p&gt;最後，&lt;code&gt;main()&lt;/code&gt;利用&lt;code&gt;AddEdge()&lt;/code&gt;建立出Graph的&lt;code&gt;AdjList&lt;/code&gt;，並執行&lt;code&gt;Prim_MinQueue()&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;utility&amp;gt;          &lt;/span&gt;&lt;span class="c1"&gt;// for std::pair&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;          &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;cmath&amp;gt;            &lt;/span&gt;&lt;span class="c1"&gt;// for std::floor&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;/////////////// MinHeap ////////////////&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;FindPosition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;
    &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 主要存放vertex及其distance的vector&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// Min-Priority Queue&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BuildMinHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DecreaseKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;newKey&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;MinHeapInsert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;ExtractMin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                               &lt;span class="c1"&gt;// 回傳heap[1]並調整Heap&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Minimum&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;         &lt;span class="c1"&gt;// 回傳heap[1]&lt;/span&gt;

    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsHeapEmpty&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;

&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;FindPosition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;MinHeapInsert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HeapNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;DecreaseKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DecreaseKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;newKey&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FindPosition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 找到node所在的位置index&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newKey&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;// 如果不是把node的Key下修, 便終止此函式&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;new key is not smaller than current key&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 更新node之Key後,   &lt;/span&gt;
                                              &lt;span class="c1"&gt;// 需要檢查是否新的subtree滿足Min Heap&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;)].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;)]);&lt;/span&gt;
        &lt;span class="n"&gt;index_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetParentNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;HeapNode&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ExtractMin&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsHeapEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;error: heap is empty&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 此時heap的第一個node具有最小key值&lt;/span&gt;
    &lt;span class="c1"&gt;// 便以min記錄其element, 最後回傳min&lt;/span&gt;
    &lt;span class="c1"&gt;// delete the first element/vertex&lt;/span&gt;
    &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;            &lt;span class="c1"&gt;// 把最後一個element放到第一個位置,&lt;/span&gt;
    &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 再刪除最後一個element&lt;/span&gt;
    &lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;          &lt;span class="c1"&gt;// 目前, heap[1]具有最大Key, 需要進行調整&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 回傳heap中具有最小key的element&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BuildMinHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="c1"&gt;// 將array[]的資料放進 heap之矩陣中, 並預留 heap[0] 不做使用&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 把array[]的idx視為element&lt;/span&gt;
        &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;              &lt;span class="c1"&gt;// 把array[]的數值視為key&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// length要減一, 因為heap從從1開始存放資料&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryHeap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// 取得left child&lt;/span&gt;
        &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="c1"&gt;// 取得right child&lt;/span&gt;
        &lt;span class="n"&gt;smallest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// smallest用來記錄包含root與child, 三者之中Key最小的node&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;smallest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;smallest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smallest&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;smallest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smallest&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                 &lt;span class="c1"&gt;// 如果目前node的Key不是三者中的最小&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smallest&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;   &lt;span class="c1"&gt;// 就調換node與三者中Key最小的node之位置&lt;/span&gt;
        &lt;span class="n"&gt;MinHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smallest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// 調整新的subtree成Min Heap&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;/////////////// Prim&amp;#39;s Algorithm /////////////////&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxDistance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph_MST&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// 以Start作為起點&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph_MST&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph_MST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Prim_MinQueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryHeap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_MST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;maxDistance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 起點vertex的distance設為0, ExtractMin就會從起點開始&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_MST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Prim_MinQueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;InitializeSingleSource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;BinaryHeap&lt;/span&gt; &lt;span class="nf"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BuildMinHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// use minQueue to handle distance[]&lt;/span&gt;

    &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// initializa visited[] as {0,0,0,...,0}&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsHeapEmpty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ExtractMin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
             &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

                &lt;span class="c1"&gt;// for edge(X,Y)&lt;/span&gt;
                &lt;span class="c1"&gt;// u: X , (*itr).first: Y, (*itr).second: weight(X,Y)&lt;/span&gt;
                &lt;span class="c1"&gt;// (*itr).second &amp;lt; distance[(*itr).first]: weight(X,Y) &amp;lt; distance[Y]&lt;/span&gt;

                &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;minQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DecreaseKey&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;///////   print result   /////////&lt;/span&gt;

    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;print predecessor[]:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;print distance[]:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;v1&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; - &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;v2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; : weight&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 若從4開始, i依序為5,6,0,1,2,3&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; - &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
        &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; : &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 到了6之後, 6+1 = 7, error:bad_access&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_MST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph_MST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;Graph_MST&lt;/span&gt; &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;MST found by Prim_MinQueue:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Prim_MinQueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MST&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="nl"&gt;Prim_MinQueue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="nl"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;

 &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;  &lt;span class="nl"&gt;v2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;
  &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;
  &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;結果如同圖一(m)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_PQ_fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(m)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是利用&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;實作的&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;之介紹。  &lt;/p&gt;
&lt;p&gt;建議讀者可以稍微比較一下以下兩者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;實作的&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;，以及&lt;/li&gt;
&lt;li&gt;利用&lt;strong&gt;Min-Priority Queue&lt;/strong&gt;實作的&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html#code"&gt;Dijkstra's Algorithm&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根本一模一樣。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch23&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm"&gt;Rashid Bin Muhammad：Jarnik's (Prim's) Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://theoryofprogramming.com/2015/03/27/prims-algorithm/"&gt;Theory of Programming：Prim's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/"&gt;GeeksforGeeks：Greedy Algorithms | Set 6 (Prim’s MST for Adjacency List Representation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html#code"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;MST系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treekruskals-algorithm.html"&gt;Minimum Spanning Tree：Kruskal's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html"&gt;Minimum Spanning Tree：Prim's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Minimum Spanning Tree"></category><category term="Greedy Algorithm"></category><category term="Cut(partition)"></category><category term="Priority Queue"></category><category term="Heap"></category></entry><entry><title>Minimum Spanning Tree：Prim's Algorithm</title><link href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html" rel="alternate"></link><updated>2016-02-25T20:30:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-25:SecondRound/minimum-spanning-treeprims-algorithm.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章要接著介紹另一個尋找MST的演算法：&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;建議讀者可以先閱讀在&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;介紹過的「演算法概念」與&lt;strong&gt;Theorem1&lt;/strong&gt;與&lt;strong&gt;Corollary2&lt;/strong&gt;，對理解接下來的內容會有些幫助。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;Prim's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;MST系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Prim's Algorithm&lt;/h2&gt;
&lt;p&gt;考慮圖一(a)的Graph，目標是要在此Graph上找到MST。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;之演算法將使用三個資料項目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;predecessor[]&lt;/code&gt;：記錄最後在MST中，各個vertex之間的「parent-child」關係。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key[]&lt;/code&gt;：此為「挑選edge」的關鍵，&lt;code&gt;key[]&lt;/code&gt;記錄的會是edge的weight，但是會將weight「暫存在vertex上」，表示「到達該vertex的成本」，演算法的最後將挑選出能夠以「最低成本」抵達該vertex的edge，此edge上的兩個vertex即形成「parent-child」關係，能夠記錄進&lt;code&gt;predecessor[]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;visited[]&lt;/code&gt;：用來標記出，哪些vertex已經在MST裡面，哪些還沒有。已經是MST之vertex標記為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，其餘為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了&lt;code&gt;key[]&lt;/code&gt;與&lt;code&gt;visited[]&lt;/code&gt;，就能正確挑選出edge，形成最後的MST。&lt;/p&gt;
&lt;p&gt;演算法步驟如下：&lt;/p&gt;
&lt;p&gt;首先，初始化所有vertex的資料項目，見圖一(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;predecessor[]&lt;/code&gt;設成&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，表示vertex沒有predecessor。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key[]&lt;/code&gt;設成「無限大」，表示所有vertex都沒有辦法經由與其餘vertex相連之edge抵達。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;visited[]&lt;/code&gt;設成&lt;span class="math"&gt;\(0\)&lt;/span&gt;，表示MST裡面還沒有vertex。&lt;br /&gt;
(程式範例中，&lt;code&gt;visited[]&lt;/code&gt;的資料型態是用&lt;code&gt;bool&lt;/code&gt;，因此設為&lt;code&gt;false&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;初始化之後，選定其中一個vertex作為起點。&lt;br /&gt;
這個起點會是MST的root，如果不要求MST之起點為何，那麼起點可以任意挑選。&lt;br /&gt;
在此選定vertex(2)作為起點，便將&lt;code&gt;key[2]&lt;/code&gt;設成&lt;span class="math"&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新&lt;code&gt;key[]&lt;/code&gt;是關鍵，原因在於，演算法會根據&lt;code&gt;key[]&lt;/code&gt;的大小，每次挑選出&lt;code&gt;key[]&lt;/code&gt;值最小的vertex放進MST。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著便開始演算法的主要迴圈。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先從&lt;code&gt;key[]&lt;/code&gt;中挑選出數值最小(可以想成「抵達成本」最小)的vertex，放進MST。&lt;br /&gt;
在此挑選到的是vertex(2)，見圖一(c)。&lt;/li&gt;
&lt;li&gt;由於vertex(2)已經屬於MST，便更新&lt;code&gt;visited[2]=1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，找到所有與vertex(2)具有edge相連的vertex(X)，比較所有edge(2,X)之weight與vertex(X)的&lt;code&gt;key[]&lt;/code&gt;，如果weight比&lt;code&gt;key[X]&lt;/code&gt;小，便更新&lt;code&gt;predecessor[X]&lt;/code&gt;成vertex(2)，並且把&lt;code&gt;key[X]&lt;/code&gt;更新成weight(2,X)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示從vertex(2)經由edge(2,X)抵達vertex(X)，只要花費weight(2,X)的成本，而到最後，若Graph上沒有從其他vertex經由「成本更小的edge」能夠抵達vertex(X)，那麼MST中，就會存在edge(2,X)，因為在所有連結vertex(2)與vertex(X)的edge中，edge(2,X)的成本最低。&lt;/li&gt;
&lt;li&gt;另外一種情況，若weight(2,X)比&lt;code&gt;key[X]&lt;/code&gt;大，那就不更新&lt;code&gt;key[X]&lt;/code&gt;，表示從Graph中某個vertex(Y)到達vertex(X)，會比從vertex(2)到達vertex(X)的成本更低。也不更新&lt;code&gt;predecessor[X]&lt;/code&gt;，維持vertex(Y)作為vertex(X)的predecessor。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據圖一(c)，與vertex(2)相連的vertex分別是vertex(1)、vertex(3)、vertex(6)，經比較後發現： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(weight(2,1)&amp;lt;\)&lt;/span&gt;&lt;code&gt;key[1]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(weight(2,3)&amp;lt;\)&lt;/span&gt;&lt;code&gt;key[3]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(weight(2,6)&amp;lt;\)&lt;/span&gt;&lt;code&gt;key[6]&lt;/code&gt;；  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此時便更新&lt;code&gt;key[]&lt;/code&gt;與&lt;code&gt;predecessor[]&lt;/code&gt;，見圖一(d)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;key[1]=weight(2,1)=10&lt;/code&gt;，&lt;code&gt;predecessor[1]=2&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key[3]=weight(2,3)=5&lt;/code&gt;，&lt;code&gt;predecessor[3]=2&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key[6]=weight(2,6)=3&lt;/code&gt;，&lt;code&gt;predecessor[6]=2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;總結圖一(c)與圖一(d)的步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;選取&lt;code&gt;key[]&lt;/code&gt;值最小的vertex放進MST，假設為vertex(X)；&lt;/li&gt;
&lt;li&gt;將vertex(X)之&lt;code&gt;visited[]&lt;/code&gt;標記為&lt;span class="math"&gt;\(1\)&lt;/span&gt;(或是&lt;code&gt;true&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;比較weight與&lt;code&gt;key[]&lt;/code&gt;，判斷是否需要更新所有與vertex(X)具有edge相連之vertex的&lt;code&gt;key[]&lt;/code&gt;與&lt;code&gt;predecessor[]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上便完成一次&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;的主要迴圈。&lt;br /&gt;
若Graph上有&lt;span class="math"&gt;\(V\)&lt;/span&gt;個vertex，接下來只要繼續上述步驟「&lt;span class="math"&gt;\(V-1\)&lt;/span&gt;」次，就能得到Graph上的MST。&lt;/p&gt;
&lt;p&gt;接著，繼續從&lt;code&gt;key[]&lt;/code&gt;挑選出數值最小的vertex(3)放進MST，更新&lt;code&gt;visited[3]=1&lt;/code&gt;，見圖一(e)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再比較所有與vertex(3)具有edge相連之vertex的&lt;code&gt;key[]&lt;/code&gt;，根據圖一(e)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vertex(2)已經進入MST中(&lt;code&gt;visited[2]=1&lt;/code&gt;)，忽略不計；&lt;/li&gt;
&lt;li&gt;vertex(6)與vertex(3)相連，不過weight(6,3)比&lt;code&gt;key[6]=8&lt;/code&gt;還要大，表示從vertex(3)走到vertex(6)之成本高於從vertex(2)走到vertex(6)，因此不更新&lt;code&gt;key[6]&lt;/code&gt;與&lt;code&gt;predecessor[6]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;vertex(4)與vertex(3)相連，並且weight(4,3)&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;key[4]=infinity&lt;/code&gt;，於是更新&lt;code&gt;key[4]=weight(4,3)&lt;/code&gt;，&lt;code&gt;predecessor[4]=3&lt;/code&gt;，見圖一(f)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著重複上述步驟，直到Graph上所有vertex都被放進MST中(&lt;code&gt;visited[]&lt;/code&gt;全部變成&lt;span class="math"&gt;\(1\)&lt;/span&gt;)，即可找到MST，見圖一(g)至圖一(n)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(g)：將vertex(4)放進MST中&lt;/strong&gt;，&lt;code&gt;visited[4]=1&lt;/code&gt;&lt;strong&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(h)：從vertex(4)探索vertex(1)、vertex(5)、vertex(6)。&lt;br /&gt;
更新vertex(1)、vertex(5)、vertex(6)之&lt;code&gt;key[]&lt;/code&gt;與&lt;code&gt;predecessor[]&lt;/code&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(i)：將vertex(1)放進MST中&lt;/strong&gt;，&lt;code&gt;visited[1]=1&lt;/code&gt;&lt;strong&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(j)：從vertex(1)探索vertex(0)、vertex(2)、vertex(4)、vertex(6)。&lt;br /&gt;
更新vertex(0)的&lt;code&gt;key[]&lt;/code&gt;與&lt;code&gt;predecessor[]&lt;/code&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(k)：將vertex(6)放進MST中&lt;/strong&gt;，&lt;code&gt;visited[6]=1&lt;/code&gt;&lt;strong&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(l)：將vertex(0)放進MST中&lt;/strong&gt;，&lt;code&gt;visited[0]=1&lt;/code&gt;&lt;strong&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(m)：從vertex(0)探索vertex(1)、vertex(5)。&lt;br /&gt;
更新vertex(5)的&lt;code&gt;key[]&lt;/code&gt;與&lt;code&gt;predecessor[]&lt;/code&gt;。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(n)：將vertex(5)放進MST中&lt;/strong&gt;，&lt;code&gt;visited[5]=1&lt;/code&gt;，&lt;strong&gt;MST建立完畢。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;見圖一(n)，當Graph上所有vertex的&lt;code&gt;visited[]&lt;/code&gt;都被設為&lt;span class="math"&gt;\(1\)&lt;/span&gt;(或是&lt;code&gt;true&lt;/code&gt;)後，MST便建立完畢。&lt;/p&gt;
&lt;p&gt;那麼&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;的運作原則是什麼？&lt;/p&gt;
&lt;p&gt;觀察圖一(d)至圖一(j)，被放進MST的vertex恰好都與vertex(6)有edge相連，因此，vertex(6)總共被「檢查了四次」(比較weight與&lt;code&gt;key[6]&lt;/code&gt;四次)，並且「更新了兩次」(&lt;code&gt;key[6]&lt;/code&gt;從&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;更新成&lt;span class="math"&gt;\(8\)&lt;/span&gt;，最後更新成&lt;span class="math"&gt;\(2\)&lt;/span&gt;)，可以肯定的是，若vertex(6)一定要與Graph中的其中一個vertex相連(這是MST的要求)，那麼&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;一定能夠替vertex(6)挑選出最小weight的edge：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖一(n)為例，vertex(6)共有四條edge連結至其他vertex，而最後是透過weight為&lt;span class="math"&gt;\(2\)&lt;/span&gt;的edge(4,6)與vertex(4)相連。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看圖二，當vertex(3)被放進MST時，vertex(2)已經被放進MST，因此可以把這兩個vertex視為一個connected component，並且找到一個Cut &lt;span class="math"&gt;\((C,V-C)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(C=\)&lt;/span&gt;{&lt;span class="math"&gt;\(2,3\)&lt;/span&gt;}，&lt;span class="math"&gt;\(V-C=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,1,4,5,6\)&lt;/span&gt;}，而在Cut上的crossing edge總共有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;edge(1,2)，weight&lt;span class="math"&gt;\(=10\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;edge(2,6)，weight&lt;span class="math"&gt;\(=8\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;edge(3,6)，weight&lt;span class="math"&gt;\(=9\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;edge(3,4)，weight&lt;span class="math"&gt;\(=7\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顯然，light edge為edge(3,4)，因此edge(3,4)必定會是MST中的edge。&lt;/p&gt;
&lt;p&gt;這便是&lt;strong&gt;Theorem1&lt;/strong&gt;所證明的事。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;以下的程式範例包含了&lt;code&gt;class Graph&lt;/code&gt;與&lt;code&gt;main()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Graph&lt;/code&gt;：使用&lt;code&gt;Adjacency Matrix&lt;/code&gt;而不是&lt;code&gt;Adjacency List&lt;/code&gt;。   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;PrimMST()&lt;/code&gt;為主要演算法，內容如前一節所介紹。  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;MinKeyExtract()&lt;/code&gt;根據&lt;code&gt;visited&lt;/code&gt;找到，所有尚未放進MST的vertex中，&lt;code&gt;key[]&lt;/code&gt;最小值的vertex。&lt;/p&gt;
&lt;p&gt;最後，&lt;code&gt;main()&lt;/code&gt;利用&lt;code&gt;AddEdge()&lt;/code&gt;建立出Graph的&lt;code&gt;AdjMatrix&lt;/code&gt;，並執行&lt;code&gt;PrimMST()&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for setw()&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Max_Weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 初始化key[]時需要infinity, 以Max_Weight代替&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;GraphMST&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrimMST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// 可以指定起點Start, 若沒有指定, 則從vertex(0)作為MST的root&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;MinKeyExtract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;MinKeyExtract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Max_Weight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;min_idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;min_idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;min_idx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrimMST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Max_Weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// false表示vertex還沒有被visited&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MinKeyExtract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// print MST, 與MST演算法主體無關&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;v1&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; - &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;v2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; : weight&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 若從4開始, i依序為5,6,0,1,2,3&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; - &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
                  &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; : &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 到了6之後, 6+1 = 7, error:bad_access, 透過mod把7喬回0&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;GraphMST&lt;/span&gt; &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;MST found by Prim:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrimMST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MST&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="nl"&gt;Prim&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
 &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;  &lt;span class="nl"&gt;v2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;
  &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;7&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;3&lt;/span&gt;
  &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;結果如同圖一(n)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Prim_fig/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(n)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;若參考&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch23&lt;/a&gt;所提供的Prim's Algorithm之虛擬碼(pseudo code)，將會發現其中有個「Min-Priority Queue」的資料結構，如果讀者有興趣，可以參考以下連結(筆者還在磨劍，請見諒)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://theoryofprogramming.com/2015/03/27/prims-algorithm/"&gt;Theory of Programming：Prim's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm"&gt;Rashid Bin Muhammad：Jarnik's (Prim's) Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上便是利用&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;尋找MST之介紹。&lt;br /&gt;
若讀者能夠花些時間比較這兩種種樹的策略，將會發現，兩邊都是天才啊。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch23&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm"&gt;Rashid Bin Muhammad：Jarnik's (Prim's) Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://theoryofprogramming.com/2015/03/27/prims-algorithm/"&gt;Theory of Programming：Prim's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/"&gt;GeeksforGeeks：Greedy Algorithms | Set 5 (Prim’s Minimum Spanning Tree (MST))&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;MST系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treekruskals-algorithm.html"&gt;Minimum Spanning Tree：Kruskal's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html"&gt;Minimum Spanning Tree：Prim's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Minimum Spanning Tree"></category><category term="Greedy Algorithm"></category><category term="Cut(partition)"></category></entry><entry><title>Minimum Spanning Tree：Kruskal's Algorithm</title><link href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treekruskals-algorithm.html" rel="alternate"></link><updated>2016-02-24T20:50:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-24:SecondRound/minimum-spanning-treekruskals-algorithm.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在上一篇文章&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;介紹過MST的問題情境以及演算法概念，這篇文章要接著介紹尋找MST的演算法之一：&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;說明演算法時將會用上專有名詞如「light edge」、「cross」，如果不太熟悉，可以參考&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;上一篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;將會用到&lt;strong&gt;Set&lt;/strong&gt;的概念來收集MST中的edge，建議讀者可以先閱讀&lt;a href="http://alrightchiu.github.io/SecondRound/setyi-arraybiao-shi.html"&gt;Set：以Array表示&lt;/a&gt;複習一下&lt;strong&gt;Set&lt;/strong&gt;之表示法。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;Kruskal's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;MST系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Kruskal's Algorithm&lt;/h2&gt;
&lt;p&gt;考慮圖二(a)的Graph，目標是要在此Graph上找到MST。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;之演算法將使用三個資料項目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;edgesetMST[]&lt;/code&gt;：用來收集所有MST中的edge，功能與&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html#theorem"&gt;Theorem1中的Set A&lt;/a&gt;相同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subset[]&lt;/code&gt;：用來記錄&lt;code&gt;edgesetMST[]&lt;/code&gt;中的edge之兩端vertex所屬的集合，目的是用來判斷是否形成&lt;strong&gt;cycle&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;increaseWeight[]&lt;/code&gt;：把Graph中的edge按照weight由小到大排序，依序放進&lt;code&gt;increaseWeight[]&lt;/code&gt;，當演算法在「挑選edge」形成最短路徑時，便是按照「weight由小到大」之順序挑選。&lt;br /&gt;
將圖二(a)的Graph之edge排序，可以得到如圖二(b)的&lt;code&gt;increaseWeight[]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;演算法步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把Graph中的每一個vertex都視為各自獨立且互斥的集合(disjoint set)，也就是把&lt;code&gt;subset[]&lt;/code&gt;的每一個元素都設為&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，如圖二(c)。&lt;ul&gt;
&lt;li&gt;負值表示每個vertex都是各自Set的root。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(|-1|=1\)&lt;/span&gt;表示每個Set裡面只有一個element。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;從Graph中，按照「weight由小到大」之順序得到如圖二(b)的&lt;code&gt;increaseWeight[]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;此時&lt;code&gt;edgesetMST[]&lt;/code&gt;還是空集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著開始進入「挑選edge」的迴圈。&lt;/p&gt;
&lt;p&gt;首先，根據&lt;code&gt;increaseWeight[]&lt;/code&gt;(從index(&lt;span class="math"&gt;\(0\)&lt;/span&gt;)開始取得edge)，整個Graph中weight最小的edge是edge(1,4)，便利用&lt;code&gt;FindSetCollapsing()&lt;/code&gt;與&lt;code&gt;subset[]&lt;/code&gt;判斷vertex(1)與vertex(4)是否屬於同一個Set，如果不是的話，便執行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將edge(1,4)加入&lt;code&gt;edgesetMST[]&lt;/code&gt;，見圖二(d)；&lt;/li&gt;
&lt;li&gt;並利用&lt;code&gt;UnionSet()&lt;/code&gt;將vertex(1)與vertex(4)合併成一個新的Set。&lt;ul&gt;
&lt;li&gt;因為兩個Set中的element數目相同，以何者作為合併後的Set之root不影響，便更新&lt;code&gt;subset[4]=1&lt;/code&gt;，&lt;code&gt;subset[1]=-2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據&lt;code&gt;increaseWeight[]&lt;/code&gt;，下一個為edge(4,6)，由於vertex(4)與vertex(6)屬於不同Set，便重複上述步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將edge(4,6)加入&lt;code&gt;edgesetMST[]&lt;/code&gt;，見圖二(e)；&lt;/li&gt;
&lt;li&gt;並利用&lt;code&gt;UnionSet()&lt;/code&gt;將vertex(4)與vertex(6)合併成一個新的Set。&lt;ul&gt;
&lt;li&gt;因為vertex(4)所屬的Set中有2個element，vertex(6)所屬的Set只有一個element，便將vertex(6)併入vertex(4)之Set，更新&lt;code&gt;subset[6]=1&lt;/code&gt;，&lt;code&gt;subset[1]=-3&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據&lt;code&gt;increaseWeight[]&lt;/code&gt;，下一個edge為edge(0,5)，由於vertex(0)與vertex(5)屬於不同Set，便重複上述步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將edge(0,5)加入&lt;code&gt;edgesetMST[]&lt;/code&gt;，見圖二(f)；&lt;/li&gt;
&lt;li&gt;並利用&lt;code&gt;UnionSet()&lt;/code&gt;將vertex(0)與vertex(5)合併成一個新的Set。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(f)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;關鍵是下一個edge：edge(1,6)。&lt;/p&gt;
&lt;p&gt;由於vertex(1)與vertex(6)屬於同一個Set，表示vertex(6)一定與Set中某個vertex具有edge相連(此例為vertex(4))，如果將edge(1,6)加入&lt;code&gt;edgesetMST[]&lt;/code&gt;，將會&lt;strong&gt;形成cycle&lt;/strong&gt;，便違反Tree的結構。&lt;br /&gt;
因此，即使在所有尚未加入&lt;code&gt;edgesetMST[]&lt;/code&gt;的edge中，edge(1,6)的weight最小，仍必須將其忽略。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(g)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;到目前為止可以得到結論：只要把像是edge(1,6)這樣會使得&lt;code&gt;edgesetMST[]&lt;/code&gt;中的vertex&lt;strong&gt;形成cycle&lt;/strong&gt;的edge忽略掉，再根據&lt;code&gt;increaseWeight[]&lt;/code&gt;，依序挑選weight最小的edge，即可找到MST。&lt;/p&gt;
&lt;p&gt;接下來的挑選過程如圖二(h)-(k)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(h)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(i)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(j)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;這裡有個小細節：為什麼&lt;code&gt;subset[5]&lt;/code&gt;變成&lt;span class="math"&gt;\(1\)&lt;/span&gt;？&lt;/p&gt;
&lt;p&gt;因為當&lt;code&gt;increaseWeight[]&lt;/code&gt;交出edge(5,4)作為當前具有最小weight之edge時，&lt;code&gt;FindSetCollapsing()&lt;/code&gt;會對vertex(5)與vertex(4)執行「找到所屬的Set之root」，以及「把vertex之&lt;strong&gt;parent/predecessor&lt;/strong&gt;指向root」，所以vertex(5)會因為「塌陷(Collapsing)」的關係，&lt;code&gt;subset[5]&lt;/code&gt;被更新成vertex(1)。&lt;br /&gt;
這使得往後在尋找「vertex(5)所屬之Set」時，只要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;的時間複雜度。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(k)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如圖二(k)，當&lt;code&gt;edgesetMST[]&lt;/code&gt;加入edge(4,3)後，MST便尋找完畢。&lt;/p&gt;
&lt;p&gt;用肉眼看起來，除了weight&lt;span class="math"&gt;\(=4\)&lt;/span&gt;的edge(1,6)，與weight&lt;span class="math"&gt;\(=6\)&lt;/span&gt;的edge(5,4)之外，確實是Graph上具有較小weight之edge都被挑進MST了。&lt;/p&gt;
&lt;p&gt;但是要怎麼驗證Kruskal's Algorithm不是運氣好呢？&lt;br /&gt;
答案就在上一篇文章提到的&lt;strong&gt;Theorem1&lt;/strong&gt;與&lt;strong&gt;Corollary2&lt;/strong&gt;裡面。&lt;/p&gt;
&lt;p&gt;根據&lt;strong&gt;Corollary2&lt;/strong&gt;，給定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Graph &lt;span class="math"&gt;\(G=(V,E)\)&lt;/span&gt;是一個connected、weighted、undirected graph；&lt;/li&gt;
&lt;li&gt;Set A是MST之edge的subset，&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;subgraph &lt;span class="math"&gt;\(C=(V_C,E_C)\)&lt;/span&gt;為「Forest &lt;span class="math"&gt;\(G_A=(V,A)\)&lt;/span&gt;」中的connected component，C可以視為一棵Tree；&lt;/li&gt;
&lt;li&gt;edge(X,Y)是所有在「Forest &lt;span class="math"&gt;\(G_A=(V,A)\)&lt;/span&gt;」中，連結各個connected component的light edge；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那麼，edge(X,Y)對Set A也會是&lt;strong&gt;安全的(safe)&lt;/strong&gt;，將edge(X,Y)加入Set A後，Set A必定能夠滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。    &lt;/p&gt;
&lt;p&gt;再看看Kruskal's Algorithm，演算法一開始會將所有vertex都視為各自獨立且互斥的Set，因此，每一個vertex都可以視為一個connected component，那麼，在所有連結connected component的edge(也就是連結各個vertex的edge)當中的light edge，就必定是MST的edge。&lt;/p&gt;
&lt;p&gt;因此，Kruskal's Algorithm按照「weight由小到大」的順序挑選edge，並且避免產生&lt;strong&gt;cycle&lt;/strong&gt;，即可找到MST。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;以下的程式範例包含了&lt;code&gt;struct Edge&lt;/code&gt;、&lt;code&gt;class Graph&lt;/code&gt;、Set相關函式與&lt;code&gt;main()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct Edge&lt;/code&gt;：因為&lt;code&gt;edgesetMST[]&lt;/code&gt;與&lt;code&gt;increaseWeight[]&lt;/code&gt;需要同時儲存edge的兩個端點vertex與weight，因此建立一個&lt;code&gt;struct&lt;/code&gt;結構表示edge。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class Graph&lt;/code&gt;：與&lt;a href=""&gt;BFS/DFS系列&lt;/a&gt;中的&lt;code&gt;class Graph&lt;/code&gt;不同的是，這裡使用了&lt;code&gt;Adjacency Matrix&lt;/code&gt;而不是&lt;code&gt;Adjacency List&lt;/code&gt;。&lt;br /&gt;
(為節省篇幅長度，與BFS/DFS相關的member(包含data和funtion)暫時隱藏。)  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;KruskalMST()&lt;/code&gt;為主要演算法，內容如前一節所介紹。  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetSortedEdge()&lt;/code&gt;是為了得到&lt;code&gt;increaseWeight[]&lt;/code&gt;，其中利用了C++標準函式庫(STL)的&lt;code&gt;sort()&lt;/code&gt;，因此有個自行定義的&lt;code&gt;WeightComp()&lt;/code&gt;，用來比較兩條edge之weight大小。&lt;br /&gt;
(關於STL的&lt;code&gt;sort()&lt;/code&gt;，請參考：&lt;a href="http://www.cplusplus.com/reference/algorithm/sort/?kw=sort"&gt;Cplusplus：std::sort()&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;與Set有關的兩個函式&lt;code&gt;FindSetCollapsing()&lt;/code&gt;與&lt;code&gt;UnionSet()&lt;/code&gt;內如也如本篇文章第一小節所介紹。&lt;/p&gt;
&lt;p&gt;最後，&lt;code&gt;main()&lt;/code&gt;利用&lt;code&gt;AddEdge()&lt;/code&gt;建立出Graph的&lt;code&gt;AdjMatrix&lt;/code&gt;，並執行&lt;code&gt;KruskalMST()&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for setw()&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="p"&gt;(){};&lt;/span&gt;
    &lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;GraphMST&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;KruskalMST&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;GetSortedEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;UnionSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;      &lt;span class="c1"&gt;// 用遞迴做collapsing&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// root&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;UnionSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;xroot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;yroot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 用rank比較, 負越多表示set越多element, 所以是值比較小的element比較多&lt;/span&gt;
    &lt;span class="c1"&gt;// xroot, yroot的subset[]一定都是負值&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;        &lt;span class="c1"&gt;// x比較多element或是一樣多的時候, 以x作為root&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;//  if (subset[xroot] &amp;gt; subset[yroot]), 表示y比較多element&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;xroot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;yroot&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;WeightComp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Edge&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Edge&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;GetSortedEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;edgearray&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;edgearray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]));&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 用std::sort 排序, 自己定義一個comparison&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;edgearray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;edgearray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;WeightComp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;KruskalMST&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Edge&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;edgesetMST&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;edgesetcount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;increaseWeight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;GetSortedEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;increaseWeight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              &lt;span class="c1"&gt;// 得到排好序的edge的vec&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;increaseWeight&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;increaseWeight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;FindSetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;increaseWeight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;edgesetMST&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;edgesetcount&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;increaseWeight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;UnionSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;increaseWeight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;increaseWeight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 以下僅僅是印出vertex與vertex之predecessor&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;v1&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; - &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;v2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; : weight&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;edgesetMST&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; - &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;edgesetMST&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; 
                  &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; : &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;edgesetMST&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;GraphMST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;AdjMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;GraphMST&lt;/span&gt; &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;MST found by Kruskal:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;KruskalMST&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MST&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="nl"&gt;Kruskal&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
 &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;  &lt;span class="nl"&gt;v2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;3&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="mi"&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;結果如同圖二(k)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_Kruskal_fig/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(k)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是利用&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;尋找MST之介紹。&lt;/p&gt;
&lt;p&gt;下一篇文章將介紹尋找MST的另一個基本款：&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch23&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/kruskalAlgor.htm"&gt;Rashid Bin Muhammad：Kruskal's Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=gcmjC-OcWpI"&gt;Dickson Tsai：Disjoint Sets - Data Structures in 5 Minutes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/"&gt;GeeksforGeeks：Greedy Algorithms | Set 2 (Kruskal’s Minimum Spanning Tree Algorithm)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hackerearth.com/notes/disjoint-set-union-union-find/"&gt;HackerEarth：Disjoint Set Union (Union Find)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cplusplus.com/reference/algorithm/sort/?kw=sort"&gt;Cplusplus：std::sort()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;MST系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treekruskals-algorithm.html"&gt;Minimum Spanning Tree：Kruskal's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html"&gt;Minimum Spanning Tree：Prim's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Minimum Spanning Tree"></category><category term="Greedy Algorithm"></category><category term="Cut(partition)"></category><category term="Set(Find and Union)"></category></entry><entry><title>Minimum Spanning Tree：Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html" rel="alternate"></link><updated>2016-02-23T12:36:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-23:SecondRound/minimum-spanning-treeintrojian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章旨在介紹Graph中常見的應用：Minimum Spanning Tree(MST，最小生成樹)。&lt;/p&gt;
&lt;p&gt;在介紹演算法時，繼續會用上Set(集合)的概念，如果對Set有基本概念，相信讀者一定可以躺著讀完這篇。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#mst"&gt;Minimum Spanning Tree(MST，最小生成樹)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法概念(Generic Algorithm)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#theorem"&gt;Theorom1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#proof"&gt;證明：Theorem1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#corollary"&gt;Corollary2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;MST系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="mst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Minimum Spanning Tree(MST，最小生成樹)&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;考慮一個connected、weighted的undirected graph，如圖一(a)，在Graph上能夠定義&lt;strong&gt;Spanning Tree&lt;/strong&gt;為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;連結所有Graph中的vertex的樹，見圖一(b)。&lt;/li&gt;
&lt;li&gt;因為是樹，所以&lt;strong&gt;沒有cycle&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;因為是樹，若Graph有&lt;span class="math"&gt;\(V\)&lt;/span&gt;個vertex，Spanning Tree只有&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;條edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由於Graph具有weight，因此，不同的Spanning Tree，可能有不同的&lt;strong&gt;weight總和&lt;/strong&gt;，而其中，具有&lt;strong&gt;最小weight總和&lt;/strong&gt;的樹，稱為&lt;strong&gt;Minimum Spanning Tree(MST)&lt;/strong&gt;，如圖一(c)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;小小提醒：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於Graph的weight只要求要是實數(real value)，而且不要求每一條edge的weight必須唯一，因此，Graph中的MST可能不唯一。&lt;/li&gt;
&lt;li&gt;由於MST的定義只要求「最小weight總和」，因此&lt;code&gt;root&lt;/code&gt;是哪個vertex、樹是否平衡、height(樹高)是否夠小等等問題，皆不在必要的考慮範圍內。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法概念(Generic Algorithm)&lt;/h2&gt;
&lt;p&gt;根據MST的定義，MST一定要包含Graph中的所有vertex，而且要使得連結所有vertex的edge之&lt;strong&gt;weight總和最小&lt;/strong&gt;，所以，關鍵便是「如何挑選edge」。&lt;/p&gt;
&lt;p&gt;尋找MST的演算法之大方向如下：&lt;br /&gt;
(此即為下兩篇文章將介紹的&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;與&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;的心法口訣)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立一個用來收集/表示「所有MST中的edge」之集合，稱為Set A。見圖二(a)。&lt;/li&gt;
&lt;li&gt;Set A起初是空集合，演算法將逐一挑選出「滿足MST」之edge，並利用Union(聯集)把edge視為element放進Set A中。見圖二(b)。&lt;/li&gt;
&lt;li&gt;因此，Set A會是一個逐漸長大的MST之edge的subset(子集合)，&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;演算法完成後，Set A就包含了所有MST的edge。見圖二(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著將介紹一個定理(theorem)與其等價的推論(corollary)，來說明怎麼樣的edge對Set A來說是&lt;strong&gt;安全的(safe)&lt;/strong&gt;，使得「該edge加入Set A後，Set A仍然滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;」。&lt;/p&gt;
&lt;p&gt;先定義四個名詞概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cut&lt;/strong&gt;：Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;是一種將Graph(&lt;span class="math"&gt;\(G=(V,E)\)&lt;/span&gt;)的V(vertex set)分成兩部分的&lt;strong&gt;partition(分割)&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;圖三(a)左，Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;將Graph中的vertex分割出兩個Set，&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,4\)&lt;/span&gt;}，&lt;span class="math"&gt;\(V-S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,2,3,5,6\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;圖三(a)右，Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;將Graph中的vertex分割出兩個Set，&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,4,6,0,5\)&lt;/span&gt;}，&lt;span class="math"&gt;\(V-S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(2,3\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cross&lt;/strong&gt;：若存在一條edge(X,Y)，其中&lt;span class="math"&gt;\(X\subseteq S\)&lt;/span&gt;，&lt;span class="math"&gt;\(Y\subseteq V-S\)&lt;/span&gt;，則稱這條edge「&lt;strong&gt;crosses&lt;/strong&gt;」Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;。&lt;ul&gt;
&lt;li&gt;把圖三(a)左圖調整成圖三(b)，觀察出edge(1,0)、edge(1,2)、edge(1,6)、edge(4,3)、edge(4,5)、edge(4,6)對Cut而言，都是crossing edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;respect&lt;/strong&gt;：若Set A中沒有任何一條edge是Cut的crossing edge，則稱這個Cut「&lt;strong&gt;respect&lt;/strong&gt;」Set A。(因為尊敬，所以不切開。)&lt;ul&gt;
&lt;li&gt;以圖三(b)為例，Set A&lt;span class="math"&gt;\(=\)&lt;/span&gt;{&lt;span class="math"&gt;\(edge(1,4)\)&lt;/span&gt;}，vertex(1)與vertex(4)都在&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,4\)&lt;/span&gt;}裡，因此edge(1,4)不是Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;的crossing edge，則稱Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;「&lt;strong&gt;respect&lt;/strong&gt;」Set A。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;light edge&lt;/strong&gt;：在考慮範圍內，「weight最小」的edge稱為&lt;strong&gt;light edge&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;以圖三(b)為例，若考慮所有的crossing edge，則edge(4,6)即為light edge。&lt;/li&gt;
&lt;li&gt;如果有多條edge的weight都相同，並且為極小值，那麼light edge將不止一條。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上專有名詞有點多，最重要的是釐清：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set A是&lt;strong&gt;edge的集合&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;Cut的兩個Set：&lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;是&lt;strong&gt;vertex的集合&lt;/strong&gt;。&lt;br /&gt;
&lt;/br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="theorem"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Theorom1&lt;/h3&gt;
&lt;p&gt;(對應&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms第23章，Theorem 23.1&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem1&lt;/strong&gt;要說的是，給定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Graph &lt;span class="math"&gt;\(G=(V,E)\)&lt;/span&gt;是一個connected、weighted、undirected graph；&lt;/li&gt;
&lt;li&gt;Set A是MST之edge的subset，&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt; 必須「respect」Set A；&lt;/li&gt;
&lt;li&gt;edge(X,Y)是crossing edge，也是light edge；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那麼，edge(X,Y)對Set A即為&lt;strong&gt;安全的(safe)&lt;/strong&gt;，將edge(X,Y)加入Set A後，Set A必定能夠滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。&lt;br /&gt;
換句話說，edge(X,Y)一定會是MST的edge。&lt;/p&gt;
&lt;p&gt;以圖四(a)為例，確認&lt;strong&gt;前三項條件皆滿足&lt;/strong&gt;，並且找到所有crossing edge中weight最小的edge為edge(4,6)，則edge(4,6)必定是MST的edge。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="proof"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;證明：Theorem1&lt;/h3&gt;
&lt;p&gt;如圖五(a)，考慮一個connected、weighted、undirected graph上的MST：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MST以T表示，&lt;span class="math"&gt;\(T=(V(T),E(T))\)&lt;/span&gt;；&lt;ul&gt;
&lt;li&gt;以圖五(a)為例，&lt;span class="math"&gt;\(E(T)=A\cup edge(Z,W)\cup edge(A,C)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Set A為T的edge之subset；&lt;ul&gt;
&lt;li&gt;以圖五(a)為例，&lt;span class="math"&gt;\(A=\)&lt;/span&gt;{&lt;span class="math"&gt;\(edge(X,Z),edge(Y,W),edge(W,B),edge(W,C)\)&lt;/span&gt;}；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;可以是任意「respect」Set A的Cut，並假設edge(X,Y)是Cut上所有crossing edge中的light edge，而且&lt;strong&gt;edge(X,Y)不屬於T&lt;/strong&gt;；&lt;ul&gt;
&lt;li&gt;圖五(a)中，找到Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;，其中 &lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(X,Z\)&lt;/span&gt;}，&lt;span class="math"&gt;\(V-S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(Y,W,B,C,A\)&lt;/span&gt;}，edge(X,Y)為light edge；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由於Cut「respect」Set A，因此&lt;strong&gt;edge(X,Y)不在Set A裡面&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;因為MST是一個Tree，所以T上的各個vertex之間&lt;strong&gt;只存在唯一的path&lt;/strong&gt;，因此，vertex(Y)到vertex(X)之間，必定在T上存在一條path，而且這條path中，&lt;strong&gt;將有一條edge會是Cut的crossing edge&lt;/strong&gt;，令這條crossing edge為edge(Z,W)。&lt;br /&gt;
同樣地，由於Cut「respect」Set A，&lt;strong&gt;edge(Z,W)也不會在Set A裡面&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;又因為edge(X,Y)是所有crossing edge中的light edge，所以：&lt;span class="math"&gt;\(weight(X,Y)\leq weight(Z,W)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此時，如果把edge(Z,W)從T中移除，T將分成兩個connected component，見圖五(b)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為edge(Z,W)不在Set A裡面，這兩個connected component的全部edge所形成之集合必定包含Set A。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再將這兩個connected component接上edge(X,Y)，形成一棵新的Tree，稱為T'，其中 &lt;span class="math"&gt;\(E(T')=E(T)-edge(Z,W)+edge(X,Y)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;因為&lt;span class="math"&gt;\(weight(X,Y)\leq weight(Z,W)\)&lt;/span&gt;，便得到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(weight(T')\leq weight(T)-weight(Z,W)+weight(X,Y)\)&lt;/span&gt;；&lt;br /&gt;
&lt;span class="math"&gt;\(weight(T')\leq weight(T)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，若T是MST，那麼T'也會是一棵MST。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖五(b)為例，經過&lt;span class="math"&gt;\(E(T')=E(T)-edge(Z,W)+edge(X,Y)\)&lt;/span&gt;後，新的&lt;span class="math"&gt;\(E(T')=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A+edge(X,Y)+edge(A,C)\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因為Set A與edge(X,Y)同屬於MST的edge之集合，因此edge(X,Y)對Set A會是&lt;strong&gt;安全的(safe)&lt;/strong&gt;，使得edge(X,Y)加入Set A後，Set A仍然能夠滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。(證明完畢)&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="corollary"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Corollary2&lt;/h3&gt;
&lt;p&gt;(對應&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms第23章，Corollary 23.2&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;與&lt;strong&gt;Theorem1&lt;/strong&gt;等價的&lt;strong&gt;Corollary2&lt;/strong&gt;要說的是，給定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Graph &lt;span class="math"&gt;\(G=(V,E)\)&lt;/span&gt;是一個connected、weighted、undirected graph；&lt;/li&gt;
&lt;li&gt;Set A是MST之edge的subset，&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;subgraph &lt;span class="math"&gt;\(C=(V_C,E_C)\)&lt;/span&gt;為「Forest &lt;span class="math"&gt;\(G_A=(V,A)\)&lt;/span&gt;」中的connected component，C可以視為一棵Tree；&lt;/li&gt;
&lt;li&gt;edge(X,Y)是所有在「Forest &lt;span class="math"&gt;\(G_A=(V,A)\)&lt;/span&gt;」中，連結各個connected component的light edge；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那麼，edge(X,Y)對Set A也會是&lt;strong&gt;安全的(safe)&lt;/strong&gt;，將edge(X,Y)加入Set A後，Set A必定能夠滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。    &lt;/p&gt;
&lt;p&gt;以圖四(b)為例，&lt;span class="math"&gt;\(G_A=(V,A)\)&lt;/span&gt;裡有兩個connected component，分別為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_1=(V_1,E_1)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(V_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,5\)&lt;/span&gt;}，&lt;span class="math"&gt;\(E_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(edge(0,5)\)&lt;/span&gt;}；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_2=(V_2,E_2)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(V_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,4,6\)&lt;/span&gt;}，&lt;span class="math"&gt;\(E_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(edge(1,4), edge(4,6)\)&lt;/span&gt;}。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據&lt;strong&gt;Theorem1&lt;/strong&gt;，若Cut &lt;span class="math"&gt;\((C_1,V-C_1)\)&lt;/span&gt;「respect」Set A，那麼Cut上的「crossing light edge」，一定也是MST的edge。&lt;/p&gt;
&lt;p&gt;觀察圖四(b)，顯然，Set A中的edge都沒有「cross」Cut &lt;span class="math"&gt;\((C_1,V-C_1)\)&lt;/span&gt;，而所有crossing edge中的light edge為edge(0,1)，因此，能夠將edge(0,1)加入Set A。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
關於MST的應用，筆者也還在摸索，這裡就放上兩個連結供讀者參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/applications-of-minimum-spanning-tree/"&gt;GeeksforGeeks：Applications of Minimum Spanning Tree Problem&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://courses.cs.vt.edu/cs5114/spring2009/lectures/lecture08-mst-applications.pdf"&gt;T. M. Murali：Applications of Minimum Spanning Tree Problem&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來，將以兩篇文章的篇幅介紹尋找MST的演算法：&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;與&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;與&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;都屬於&lt;strong&gt;Greedy Algorithm&lt;/strong&gt;，簡單來說，就是「追求當前的最佳情況，並期望所有最佳的當前情況，能夠歸結出最終的最佳情況」。&lt;br /&gt;
在尋找MST的問題中，最佳情況就是「挑選weight最小的edge」，並期望透過每一次都挑選weight最小之edge，最後能得到總和weight最小的MST。&lt;br /&gt;
這兩個演算法將以皆滿足&lt;strong&gt;Theorem1&lt;/strong&gt;與&lt;strong&gt;Corollary2&lt;/strong&gt;但不同的策略挑選edge，並且最後都能得到Graph上的MST。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch23&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/genericMST.htm"&gt;Rashid Bin Muhammad：Generic-Minimum Spanning Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/applications-of-minimum-spanning-tree/"&gt;GeeksforGeeks：Applications of Minimum Spanning Tree Problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://courses.cs.vt.edu/cs5114/spring2009/lectures/lecture08-mst-applications.pdf"&gt;T. M. Murali：Applications of Minimum Spanning Tree Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;MST系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treekruskals-algorithm.html"&gt;Minimum Spanning Tree：Kruskal's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html"&gt;Minimum Spanning Tree：Prim's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Minimum Spanning Tree"></category><category term="Intro"></category><category term="Cut(partition)"></category></entry><entry><title>Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)</title><link href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html" rel="alternate"></link><updated>2016-02-18T18:01:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-18:SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;有些事件具有絕對的「先後關係」，例如，襪子要在鞋子之前穿上，否則穿上鞋子後要再穿襪子需要一點奇蹟。&lt;/p&gt;
&lt;p&gt;若以Graph來表示，vertex(穿襪子)、vertex(穿鞋子)與edge(先後關係)如圖一(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;曾經提過的「課程與其先修課程」亦具有這樣的「先後關係」。&lt;br /&gt;
例如，學生一定要先修過「資料結構」，才能選修「演算法分析」，否則選課系統會生氣。&lt;/p&gt;
&lt;p&gt;那麼要如何確保在選修「演算法分析」之前，已經先選修「資料結構」，而在選修「資料結構」之前，已經先修完「程式(一)」與「離散數學」？&lt;/p&gt;
&lt;p&gt;本篇文章將要介紹的Topological Sort(拓撲排序)就是要解決這項煩惱。&lt;br /&gt;
如果找到了圖一(b)的Topological Sort(拓撲排序)，就能知道可行的修課順序，以確保在選修「演算法分析」之前，一定已經修過「資料結構」與「線性代數」。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#ts"&gt;Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;BFS/DFS系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ts"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Topological Sort(拓撲排序)&lt;/h2&gt;
&lt;p&gt;所謂的Topological Sort(拓撲排序)要求，若&lt;strong&gt;directed acyclic graph(DAG)&lt;/strong&gt;中存在一條edge(X,Y)，那麼序列中，vertex(X)一定要在vertex(Y)之前出現。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖二(a)為例，存在edge(2,6)、edge(6,9)，那麼Topological Sort中，vertex(2)一定要出現在vertex(6)之前，vertex(6)一定要在vertex(9)之前。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：將圖一(b)以符號表示。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據圖一(b)，選修「資料結構」與「線性代數」的先後順序顯然無所謂，「數值分析」與「離散數學」的修課順序也互相沒有影響，因為兩者之間沒有必然的先後關係。&lt;br /&gt;
因此，正確的Topological Sort可能不止一種，以下兩種排序皆為圖二(a)的可能結果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Topological&lt;/span&gt; &lt;span class="nl"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;Topological&lt;/span&gt; &lt;span class="nl"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最重要的一點：只有&lt;strong&gt;directed acyclic graph(DAG)&lt;/strong&gt;的Topological Sort(拓撲排序)才有意義。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖二(b)為例，若根據Topological Sort的定義：「若存在一條edge(X,Y)，則序列中，vertex(X)一定要在vertex(Y)之前出現」，那麼，存在edge(fish,rice)，序列可能是「魚、飯、肉、菜」，但是卻也同時存在edge(rice,pork)，序列可能是「飯、肉、菜、魚」，而第二個序列卻違反「存在edge(fish,rice)，魚要在飯之前吃」的限制。&lt;br /&gt;
因此，若directed graph中存在cycle，討論Topological Sort其實沒有什麼幫助。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;曾經提過DAG的性質：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在DAG上執行一次&lt;code&gt;DFS()&lt;/code&gt;，若存在一條path從vertex(X)到vertex(Y)，那麼&lt;code&gt;finish[X]&lt;/code&gt;一定比&lt;code&gt;finish[Y]&lt;/code&gt;還大。(&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/topoSort.htm"&gt;證明請點這裡&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，只要進行一次&lt;code&gt;DFS()&lt;/code&gt;，並且依照&lt;code&gt;finish[]&lt;/code&gt;由大到小印出vertex，就是Topological Sort(拓撲排序)了。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;是的，只要把&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;上一篇文章&lt;/a&gt;介紹過的&lt;code&gt;PrintSCCs()&lt;/code&gt;的前半部照抄，就能夠找到&lt;code&gt;finish&lt;/code&gt;由大到小的順序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for setw()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:white, 1:gray, 2:black&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adj List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetFinish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;VariableInitializeDFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 吃一個int, 表示起點vertex, 若沒給就從0開始&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="nf"&gt;GraphTranspose&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;TopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;TopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// 進行一次DFS用來取得 finish[]&lt;/span&gt;

    &lt;span class="c1"&gt;// 矩陣 finishLargetoSmall[] 用來儲存 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// QuickSort()會更新 finishLargetoSmall[] 成 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Topological Sort:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 建立如圖二(a)的DAG&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TopologicalSort&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Topological&lt;/span&gt; &lt;span class="nl"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;Topological&lt;/span&gt; &lt;span class="nl"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上的做法是另外呼叫一個修改過的&lt;code&gt;QuickSort()&lt;/code&gt;，對額外的矩陣&lt;code&gt;finishLargetoSmall[]&lt;/code&gt;進行排序，優點是不需要更動&lt;code&gt;DFS()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;還有些常見的方法就是修改&lt;code&gt;DFS()&lt;/code&gt;，主要有兩種，發生在當vertex要被標記為「已讀(visited)」或者「塗黑」時：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把剛剛塗黑的vertex放進&lt;code&gt;stack&lt;/code&gt;中，那麼按照順序，最先被塗黑的vertex就最先被放入&lt;code&gt;stack&lt;/code&gt;的vertex，也就最後被&lt;code&gt;pop()&lt;/code&gt;出&lt;code&gt;stack&lt;/code&gt;。&lt;br /&gt;
因此，對&lt;code&gt;stack&lt;/code&gt;依序進行&lt;code&gt;pop()&lt;/code&gt;便能夠維持&lt;code&gt;finish&lt;/code&gt;由大到小的順序。(&lt;a href="http://www.geeksforgeeks.org/topological-sorting/"&gt;詳見GeeksforGeeks：Topological Sorting&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;或者，把剛剛塗黑的vertex推進(push)一串Linked list，那麼，只要每次都是在Linked list的前端(front)加入vertex，當有下一個vertex被推入Linked list時，先前&lt;code&gt;finish&lt;/code&gt;較小的vertex就被往後挪。&lt;br /&gt;
最後，對Linked list進行一次traversal，得到的vertex順序就會是&lt;code&gt;finish&lt;/code&gt;由大到小。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是利用&lt;code&gt;DFS()&lt;/code&gt;來尋找DAG的Topological sort(拓撲排序)的介紹。&lt;br /&gt;
基本上是&lt;code&gt;DFS()&lt;/code&gt;的變形/延伸，再一次&lt;code&gt;finish&lt;/code&gt;又扮演關鍵角色拯救了世界。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/topoSort.htm"&gt;Rashid Bin Muhammad：Topological Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/topological-sorting/"&gt;GeeksforGeeks：Topological Sorting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;BFS/DFS系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="DFS"></category><category term="DAG"></category></entry><entry><title>Grpah: 利用DFS尋找Strongly Connected Component(SCC)</title><link href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html" rel="alternate"></link><updated>2016-02-17T21:49:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-17:SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在一個directed graph中，若對於任意兩個vertex(A)與vertex(B)之間，不是同時存在「從vertex(A)走到vertex(B)」以及「從vertex(B)走到vertex(A)」的path，那麼此directed graph就不是strongly connected，裡面一定包含了兩個以上的strongly connected component(SCC)。  &lt;/p&gt;
&lt;p&gt;如圖一(a)，經由path:0-1-2-5，可以從vertex(0)走到vertex(5)，但是無論經過任何vertex，都沒有辦法從vertex(5)走到vertex(0)，因此，圖一(a)的directed graph並不是strongly connected，其中包含了兩個以上的SCC(答案是三個)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;那麼，要如何分辨一個directed graph中的strongly connected component(SCC)，並列出每一個SCC中的所有vertex呢？&lt;/p&gt;
&lt;p&gt;本篇文章的目的就是要回應此問題。&lt;/p&gt;
&lt;p&gt;演算法將會用到&lt;strong&gt;Transpose of Graph&lt;/strong&gt;，如圖一(b)，把G中所有vertex維持不變，&lt;strong&gt;edge的方向顛倒&lt;/strong&gt;，就得到G&lt;sup&gt;T&lt;/sup&gt;，例如，原本的edge(0,1)改為edge(1,0)，edge(5,6)改為edge(6,5)。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最重要的是：&lt;strong&gt;G與G&lt;sup&gt;T&lt;/sup&gt;的SCC完全相同&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;原因在於，觀察G中包含在同一個SCC裡的vertex(2)與vertex(3)。G中同時存在「從vertex(2)走到vertex(3)」的path，以及「從vertex(3)走到vertex(2)」的path。在G進行「Transpose」得到G&lt;sup&gt;T&lt;/sup&gt;後，這兩條path分別變成與原方向之相反方向，但是存在於vertex(2)與vertex(3)之間的&lt;strong&gt;cycle&lt;/strong&gt;仍然存在。&lt;br /&gt;
因此，在G裡面屬於同一個SCC的vertex，在G&lt;sup&gt;T&lt;/sup&gt;裡將形成相同的SCC。 &lt;/p&gt;
&lt;p&gt;最後一點溫馨小提醒：一如往常，本篇文章將不會有嚴謹證明，不過在&lt;a href="#ref"&gt;參考資料&lt;/a&gt;會附上內有嚴謹證明的網站連結，請讀者務必前往一窺究竟。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#if_dfs_only"&gt;如果只有一次DFS不行嗎？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;BFS/DFS系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="if_dfs_only"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如果只有一次DFS不行嗎？&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;上一篇文章&lt;/a&gt;提到，只用一次&lt;code&gt;DFS()&lt;/code&gt;或&lt;code&gt;BFS()&lt;/code&gt;得到&lt;code&gt;predecessor&lt;/code&gt;後，便能夠找到undirected graph中的connected component。&lt;/p&gt;
&lt;p&gt;那如果用來找SCC？&lt;/p&gt;
&lt;p&gt;以下示範兩次&lt;code&gt;DFS()&lt;/code&gt;來說明，一次是按照「&lt;span class="math"&gt;\(8、7、...、2、1\)&lt;/span&gt;」之順序把vertex設為搜尋起點，另一次則是按照「&lt;span class="math"&gt;\(1、2、...、7、8\)&lt;/span&gt;」之順序。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：以vertex(8)作為起點，接著是vertex(5)、vertex(3)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖二(a)，首先以vertex(8)作為&lt;code&gt;DFS()&lt;/code&gt;的第一次起點，在搜尋完以vertex(8)作為&lt;code&gt;root&lt;/code&gt;的Depth-First Tree後，再以vertex(5)作為新的起點。同樣的，在搜尋完以vertex(5)作為&lt;code&gt;root&lt;/code&gt;的Depth-First Tree後，再以vertex(3)作為新的起點。&lt;br /&gt;
從圖二(a)的「時間軸」可以看出，此次&lt;code&gt;DFS()&lt;/code&gt;找到了一個Depth-First Forest，其中包含三棵Depth-First Tree，而這三棵Depth-First Tree分別就是Graph中的三個SCC。&lt;/p&gt;
&lt;p&gt;問題不就解決了嗎？&lt;br /&gt;
透過一次&lt;code&gt;DFS()&lt;/code&gt;就找到了directed graph中的SCC。&lt;/p&gt;
&lt;p&gt;再接著看圖二(b)，以vertex(0)作為&lt;code&gt;DFS()&lt;/code&gt;的起點。&lt;br /&gt;
很遺憾，「時間軸」裡形成了一整棵Depth-First Tree，directed graph中的三個SCC沒有被分開。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：以vertex(0)作為起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由於SCC需要兩個方向的path(「vertex(X)到vertex(Y)」和「vertex(Y)到vertex(X)」)都成立，但是&lt;code&gt;DFS()&lt;/code&gt;只在意「單方向」的edge，只要存在edge(X,Y)，便把&lt;code&gt;predecessor[Y]&lt;/code&gt;更新成vertex(X)，在Predecessor Subgraph裡，vertex(X)與vertex(Y)便在同一棵Depth-First Tree中。  &lt;/p&gt;
&lt;p&gt;因此，只有一次&lt;code&gt;DFS()&lt;/code&gt;的&lt;code&gt;predecessor&lt;/code&gt;是不夠的，圖二(a)只是運氣好。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
以下便開始本次的「拒絕運氣好大作戰」。&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;演算法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;若考慮具有多個SCC的directed graph，為了方便起見，定義其&lt;strong&gt;Component Graph&lt;/strong&gt;為&lt;span class="math"&gt;\(G^{SCC}=(V^{SCC},E^{SCC})\)&lt;/span&gt;，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(V^{SCC}\)&lt;/span&gt;：把每個SCC視為一個元素，並以該元素作為&lt;span class="math"&gt;\(V^{SCC}\)&lt;/span&gt;的vertex。&lt;ul&gt;
&lt;li&gt;例如圖三(a)，令&lt;span class="math"&gt;\(C_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,1,2,3\)&lt;/span&gt;}，&lt;span class="math"&gt;\(C_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(4,5\)&lt;/span&gt;}，&lt;span class="math"&gt;\(C_3=\)&lt;/span&gt;{&lt;span class="math"&gt;\(6,7,8\)&lt;/span&gt;}，則&lt;span class="math"&gt;\(V^{SCC}=\)&lt;/span&gt;{&lt;span class="math"&gt;\(C_1,C_2,C_3\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(E^{SCC}\)&lt;/span&gt;：考慮vertex(X)屬於&lt;span class="math"&gt;\(C_1\)&lt;/span&gt;，vertex(Y)屬於&lt;span class="math"&gt;\(C_2\)&lt;/span&gt;，若存在「連結兩個不同SCC」的edge(X,Y)，則edge(X,Y)便屬於&lt;span class="math"&gt;\(E^{SCC}\)&lt;/span&gt;。&lt;ul&gt;
&lt;li&gt;以圖三(a)為例，vertex(1)屬於&lt;span class="math"&gt;\(C_1\)&lt;/span&gt;，vertex(4)屬於&lt;span class="math"&gt;\(C_2\)&lt;/span&gt;，則edge(1,4)屬於&lt;span class="math"&gt;\(E^{SCC}\)&lt;/span&gt;，依此類推，便得到&lt;span class="math"&gt;\(E^{SCC}=\)&lt;/span&gt;{&lt;span class="math"&gt;\((1,4),(2,5),(4,6),(5,6),(5,7)\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：每一個directed graph，只要「以SCC作為基本元素(vertex)」，都會有其相對應的component graph。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由上述定義可以觀察出，每一個directed graph，只要「以SCC作為基本元素(vertex)」，都會有其相對應的component graph。&lt;/p&gt;
&lt;p&gt;而使用component graph的優點是：「component graph一定是&lt;strong&gt;directed acyclic graph(DAG)&lt;/strong&gt;」。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為SCC的定義&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;(請參閱：Graph: Intro(簡介))&lt;/a&gt;，若C&lt;sub&gt;1&lt;/sub&gt;與C&lt;sub&gt;2&lt;/sub&gt;之前存在&lt;strong&gt;cycle&lt;/strong&gt;，那就表示C&lt;sub&gt;1&lt;/sub&gt;和C&lt;sub&gt;2&lt;/sub&gt;都不應該自稱為SCC，而要合併C&lt;sub&gt;1&lt;/sub&gt;與C&lt;sub&gt;2&lt;/sub&gt;成為一個更大集合的SCC。因此，不同的SCC之間，一定不存在&lt;strong&gt;cycle&lt;/strong&gt;。  &lt;/li&gt;
&lt;li&gt;等價的性質：若directed graph中存在兩個SCC，分別為C&lt;sub&gt;1&lt;/sub&gt;與C&lt;sub&gt;2&lt;/sub&gt;，若存在一條path從C&lt;sub&gt;1&lt;/sub&gt;中的vertex(X)走到C&lt;sub&gt;2&lt;/sub&gt;中的vertex(Y)，就不可能同時存在一條path從C&lt;sub&gt;2&lt;/sub&gt;中的vertex(Z)走到C&lt;sub&gt;1&lt;/sub&gt;中的vertex(W)，否則即出現&lt;strong&gt;cycle&lt;/strong&gt;，應該合併成更大的SCC(C&lt;sub&gt;3&lt;/sub&gt;)，如圖三(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：SCC。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;考慮如圖三(c)的DAG(directed acyclic graph)，若&lt;code&gt;DFS()&lt;/code&gt;在每次尋找「新的搜尋起點時」，能夠按照「一條path上，從尾端至開頭」的vertex順序，那麼&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;就能長成「能夠分辨出SCC」的&lt;strong&gt;Depth-First Forest&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;圖三(c)中，由於從C&lt;sub&gt;3&lt;/sub&gt;無法往回走到C&lt;sub&gt;2&lt;/sub&gt;，從C&lt;sub&gt;2&lt;/sub&gt;無法往回走到C&lt;sub&gt;1&lt;/sub&gt;，因此，&lt;code&gt;DFS()&lt;/code&gt;的起點順序若為：C&lt;sub&gt;3&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;1&lt;/sub&gt;，就能夠把這三個component graph中的vertex(也就是directed graph的SCC)給分開。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;那麼，該如何確保每一次都能找到「一條path上，從尾端至開頭的vertex順序」？&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再觀察圖三(d)，分別以起點順序「C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;、C&lt;sub&gt;1&lt;/sub&gt;」與起點順序「C&lt;sub&gt;1&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;」進行&lt;code&gt;DFS()&lt;/code&gt;，配合圖三(c)，將發現，不論以哪個vertex作為起點，「&lt;code&gt;finish&lt;/code&gt;的大小順序一定是C&lt;sub&gt;1&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;」。&lt;/p&gt;
&lt;p&gt;更廣義地，假設現有C&lt;sub&gt;1&lt;/sub&gt;與C&lt;sub&gt;2&lt;/sub&gt;分別為directed graph中兩個互斥(disjoint)的SCC，並且vertex(X)屬於C&lt;sub&gt;1&lt;/sub&gt;，vertex(Y)屬於C&lt;sub&gt;2&lt;/sub&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若directed graph中存在edge(X,Y)，那麼，C&lt;sub&gt;1&lt;/sub&gt;集合中所有vertex的「最大&lt;code&gt;finish&lt;/code&gt;」一定比C&lt;sub&gt;2&lt;/sub&gt;集合中所有vertex的「最大&lt;code&gt;finish&lt;/code&gt;」還要大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖三(e)為例，component graph的&lt;span class="math"&gt;\(E^{SCC}\)&lt;/span&gt;存在「從C&lt;sub&gt;1&lt;/sub&gt;指向C&lt;sub&gt;2&lt;/sub&gt;」以及「從C&lt;sub&gt;2&lt;/sub&gt;指向C&lt;sub&gt;3&lt;/sub&gt;」的edge，因此，若以SCC中vertex的「最大&lt;code&gt;finish&lt;/code&gt;」代表&lt;code&gt;finish[SCC]&lt;/code&gt;，&lt;code&gt;finish&lt;/code&gt;的大小順序應為：&lt;code&gt;finish[C1]&lt;/code&gt;&amp;gt;&lt;code&gt;finish[C2]&lt;/code&gt;&amp;gt;&lt;code&gt;finish[C3]&lt;/code&gt;，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,1,2,3\)&lt;/span&gt;}，&lt;code&gt;finish[C1]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[3]&lt;/code&gt;&lt;span class="math"&gt;\(=18\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(4,5\)&lt;/span&gt;}，&lt;code&gt;finish[C2]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[5]&lt;/code&gt;&lt;span class="math"&gt;\(=10\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_3=\)&lt;/span&gt;{&lt;span class="math"&gt;\(6,7,8\)&lt;/span&gt;}，&lt;code&gt;finish[C3]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[8]&lt;/code&gt;&lt;span class="math"&gt;\(=6\)&lt;/span&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;考慮圖三(f)，仍然符合：&lt;code&gt;finish[C1]&lt;/code&gt;&amp;gt;&lt;code&gt;finish[C2]&lt;/code&gt;&amp;gt;&lt;code&gt;finish[C3]&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;finish[C1]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[0]&lt;/code&gt;&lt;span class="math"&gt;\(=18\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finish[C2]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[5]&lt;/code&gt;&lt;span class="math"&gt;\(=15\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finish[C3]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[6]&lt;/code&gt;&lt;span class="math"&gt;\(=13\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由以上推論，可以更新在圖三(c)時的說明至更廣義的結論：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要按照「&lt;code&gt;finish&lt;/code&gt;小到大」的順序選取SCC中的vertex作為&lt;code&gt;DFS()&lt;/code&gt;的起點，就能夠在&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;中以&lt;strong&gt;Depth-First Forest&lt;/strong&gt;分辨出所有SCC。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到這裡為止，可以確認：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要第一次&lt;code&gt;DFS()&lt;/code&gt;先取得&lt;code&gt;finish&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再根據剛取得的&lt;code&gt;finish&lt;/code&gt;之「順序」來判斷「第二次&lt;code&gt;DFS()&lt;/code&gt;」的起點順序。&lt;/li&gt;
&lt;li&gt;進行第二次&lt;code&gt;DFS()&lt;/code&gt;來取得&lt;code&gt;predecessor&lt;/code&gt;，並利用Predecessor Subgraph分辨出SCC。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是問題又來了。&lt;br /&gt;
如果真的是按照「第一次&lt;code&gt;finish&lt;/code&gt;由小到大」的順序選取SCC中的vertex作為第二次&lt;code&gt;DFS()&lt;/code&gt;的起點，還是有可能失敗，因為第一次&lt;code&gt;DFS()&lt;/code&gt;在選取起點時，並沒有對SCC的先備知識，可以視為隨機選取：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若第一次&lt;code&gt;DFS()&lt;/code&gt;結果如圖三(e)，則按照「&lt;code&gt;finish&lt;/code&gt;由小到大」的順序選取起點，將依序選中「vertex(7)、vertex(4)、vertex(1)」作為起點進行第二次&lt;code&gt;DFS()&lt;/code&gt;，那麼將得到如圖三(g)之結果，順利區分三個SCC。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是如果第一次&lt;code&gt;DFS()&lt;/code&gt;結果如圖三(f)，按照「&lt;code&gt;finish&lt;/code&gt;由小到大」的順序選取起點，只會選中vertex(3)作為起點，便把整個Graph搜尋完畢，最後Predecessor Subgraph又形成一整棵Depth-First Tree，如圖三(h)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;所以，先在Graph:G上執行第一次&lt;code&gt;DFS()&lt;/code&gt;，得到&lt;code&gt;finish&lt;/code&gt;後，按照&lt;code&gt;finish&lt;/code&gt;由小到大的順序，作為第二次在Graph:G上執行&lt;code&gt;DFS()&lt;/code&gt;的起點之方法，宣告失敗。&lt;/p&gt;
&lt;p&gt;不過，還好有&lt;strong&gt;Transpose of Graph: G&lt;sup&gt;T&lt;/sup&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;觀察圖三(i)中的G與G&lt;sup&gt;T&lt;/sup&gt;，發現：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兩個Graph的SCC完全相同，皆為C&lt;sub&gt;1&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;。&lt;/li&gt;
&lt;li&gt;SCC的&lt;code&gt;finish&lt;/code&gt;順序完全相反。&lt;ul&gt;
&lt;li&gt;在G上，從C&lt;sub&gt;3&lt;/sub&gt;無法往回走到C&lt;sub&gt;2&lt;/sub&gt;，從C&lt;sub&gt;2&lt;/sub&gt;無法往回走到C&lt;sub&gt;1&lt;/sub&gt;。&lt;/li&gt;
&lt;li&gt;在G&lt;sup&gt;T&lt;/sup&gt;上，從C&lt;sub&gt;1&lt;/sub&gt;無法往回走到C&lt;sub&gt;2&lt;/sub&gt;，從C&lt;sub&gt;2&lt;/sub&gt;無法往回走到C&lt;sub&gt;3&lt;/sub&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據以上特徵，若先在Graph:G上執行第一次&lt;code&gt;DFS()&lt;/code&gt;，得到&lt;code&gt;finish&lt;/code&gt;後，按照&lt;code&gt;finish&lt;/code&gt;由大到小的順序，會是「C&lt;sub&gt;1&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;」，而&lt;strong&gt;這個順序在Transpose of Graph: G&lt;sup&gt;T&lt;/sup&gt;，就正好是「&lt;/strong&gt;&lt;code&gt;finish&lt;/code&gt;&lt;strong&gt;小到大」的順序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，以「第一次&lt;code&gt;DFS()&lt;/code&gt;所得到的&lt;code&gt;finish&lt;/code&gt;之由大到小順序」選取起點，在G&lt;sup&gt;T&lt;/sup&gt;上進行第二次&lt;code&gt;DFS()&lt;/code&gt;，就可以先選到C&lt;sub&gt;1&lt;/sub&gt;，由於無法從C&lt;sub&gt;1&lt;/sub&gt;走回C&lt;sub&gt;2&lt;/sub&gt;，因此&lt;code&gt;DFS()&lt;/code&gt;在搜尋完C&lt;sub&gt;1&lt;/sub&gt;內的所有vertex後，便形成自己的Depth-First Tree。接著再依序挑選C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;為起點進行搜尋，並且建立起各自SCC的Depth-First Tree。&lt;/p&gt;
&lt;p&gt;如此一來，便找到了directed graph中的SCC。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;根據以上說明，演算法分成四個步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;對G執行&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;產生G&lt;sup&gt;T&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;按照第一次&lt;code&gt;DFS()&lt;/code&gt;所得到的&lt;code&gt;finish&lt;/code&gt;由大到小的順序選取起點，對G&lt;sup&gt;T&lt;/sup&gt;執行&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;從第二次&lt;code&gt;DFS()&lt;/code&gt;的&lt;code&gt;predecessor&lt;/code&gt;找到Predecessor Subgraph。若directed graph有多個SCC，那麼Predecessor Subgraph就會是Depth-First Forest，其中的每一棵Depth-First Tree都是一個SCC。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;範例程式碼延續上一篇文章定義的&lt;code&gt;class Graph&lt;/code&gt;，主要多了幾個函式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GetColor()&lt;/code&gt;、&lt;code&gt;GetFinish()&lt;/code&gt;、&lt;code&gt;GetPredecessor&lt;/code&gt;：用來取得&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;finish&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GraphTranspose()&lt;/code&gt;：產生G&lt;sup&gt;T&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VariableInitializeDFS()&lt;/code&gt;：把原先&lt;code&gt;DFS()&lt;/code&gt;主函式中，「配置記憶體」與「初始化」資料的部分獨立出來。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuickSort()&lt;/code&gt;等三個函式：用來得到&lt;code&gt;finish&lt;/code&gt;由大致小的vertex順序。&lt;ul&gt;
&lt;li&gt;若共有6個vertex，經過一次&lt;code&gt;DFS()&lt;/code&gt;後得到&lt;code&gt;finish&lt;/code&gt;如圖四，那麼&lt;code&gt;QuickSort()&lt;/code&gt;將會對&lt;code&gt;finish&lt;/code&gt;進行排序，並且在排序的過程，一併將&lt;code&gt;finish&lt;/code&gt;原先對應的vertex排序後，放入&lt;code&gt;finishLargetoSmall&lt;/code&gt;。之後再利用&lt;code&gt;finishLargetoSmall&lt;/code&gt;的順序，進行第二次&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PrintSCCs()&lt;/code&gt;：尋找SCC最主要的函式，主要包含上述的四個步驟。(其中有許多用以顯示資料項的指令，與尋找SCC無關)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:white, 1:gray, 2:black&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// for BFS()&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// for DFS()&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adj List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;              &lt;span class="c1"&gt;// 取得private data: color&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetFinish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;            &lt;span class="c1"&gt;// 取得private data: finish&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;  &lt;span class="c1"&gt;// 取得private data: predecessor&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;VariableInitializeDFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     &lt;span class="c1"&gt;// 對DFS()需要的資料：color, discover, finish, predecessor&lt;/span&gt;
                                      &lt;span class="c1"&gt;// 進行「配置記憶體」與「初始化」&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;           &lt;span class="c1"&gt;// 吃一個int, 表示起點vertex, 若沒給就從0開始&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// 列印出array[]&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// 列印出 finish[]&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// 列印出 predecessor[]&lt;/span&gt;

    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="nf"&gt;GraphTranspose&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// 產生Transpose of Graph&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 吃一個int, 表示起點vertex, 若沒給就從0開始&lt;/span&gt;

    &lt;span class="c1"&gt;// 利用QuickSort()得到 finish[] 由大致小的vertex順序&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 把 i + 1 當成下一個 recurrsive call 的 中間斷點&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// 第一次DFS(), 目的是取得finish[]&lt;/span&gt;
    &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 顯示 第一次DFS()後的finish[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;First DFS() on G, finish time:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// gT代表Transpose of Graph&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="nf"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GraphTranspose&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// 矩陣 finishLargetoSmall[] 用來儲存 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// QuickSort()會更新 finishLargetoSmall[] 成 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 列印出 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;finish time Large to Small:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 第二次DFS(), 執行在gT上, 先對四個資料「配置記憶體」且「初始化」&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;VariableInitializeDFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 顯示 第二次DFS()後的finish[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Second DFS() on gT, finish time:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// 顯示 第二次DFS()後的predecessor[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor[] before SetCollapsing:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 顯示 SetCollapsing後的predecessor[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor after SetCollapsing:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// 如同在undirected graph中尋找connected component&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;SCC#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;VariableInitializeDFS&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;discover&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;GraphTranspose&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Vertex(0) as starting point for the First DFS():&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Vertex(3) as starting point for the First DFS():&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;starting&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="mi"&gt;18&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;15&lt;/span&gt;  &lt;span class="mi"&gt;13&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;
&lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;Large&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="nl"&gt;Small&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;Second&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;  &lt;span class="mi"&gt;18&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;
&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="nl"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="n"&gt;after&lt;/span&gt; &lt;span class="nl"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; 
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; 
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; 

&lt;span class="n"&gt;Vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;starting&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="mi"&gt;15&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;  &lt;span class="mi"&gt;18&lt;/span&gt;  &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;13&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;Large&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="nl"&gt;Small&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;Second&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;18&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;
&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="nl"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="n"&gt;after&lt;/span&gt; &lt;span class="nl"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; 
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; 
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;結果如圖五(a)與圖五(b)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f14.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：第一次&lt;/strong&gt;&lt;code&gt;DFS()&lt;/code&gt;&lt;strong&gt;以vertex(0)作為起點。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f16.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：第一次&lt;/strong&gt;&lt;code&gt;DFS()&lt;/code&gt;&lt;strong&gt;以vertex(3)作為起點。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是利用&lt;code&gt;DFS()&lt;/code&gt;來尋找directed graph中的strongly connected component之應用。&lt;br /&gt;
其中，&lt;code&gt;finish&lt;/code&gt;之順序在DAG(directed acyclic graph)中扮演了關鍵角色。&lt;/p&gt;
&lt;p&gt;下一篇將介紹如何利用&lt;code&gt;DFS()&lt;/code&gt;尋找DAG的Topological sort(拓撲排序)，敬請期待。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/strongComponent.htm"&gt;Rashid Bin Muhammad：Strongly Connected Components&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/strongly-connected-components/"&gt;GeeksforGeeks：Strongly Connected Components&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;BFS/DFS系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="DFS"></category><category term="DAG"></category></entry><entry><title>Graph: 利用DFS和BFS尋找Connected Component</title><link href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html" rel="alternate"></link><updated>2016-02-12T22:55:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-12:SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在一個undirected graph中，若存在任意兩個vertex之間不具有path連結，那麼此undirected graph就不是connected，裡面一定包含了兩個以上的connected component。  &lt;/p&gt;
&lt;p&gt;如圖一(a)，vertex(0)與vertex(1)不論經過Graph中其他任何vertex都沒有辦法產生一條path連結，則此Graph就不是connected。&lt;br /&gt;
並且觀察，vertex(0)、vertex(2)、vertex(4)彼此皆有path能夠互相連結，因此subgraph：&lt;span class="math"&gt;\(G(V_1,E_1)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(V_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,2,4\)&lt;/span&gt;}與&lt;span class="math"&gt;\(E_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\((0,2),(0,4)\)&lt;/span&gt;}即為一個connected component；subgraph：&lt;span class="math"&gt;\(G(V_2,E_2)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(V_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,3\)&lt;/span&gt;}與&lt;span class="math"&gt;\(E_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\((1,3)\)&lt;/span&gt;}是另一個connected component。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再看圖一(b)，Graph中的任何vertex皆能經由一條path通往其餘vertex，因此，整個Graph所形成的集合即為一個connected component。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;本篇文章要示範強大的&lt;code&gt;DFS()&lt;/code&gt;與&lt;code&gt;BFS()&lt;/code&gt;的小小應用：尋找undirected graph中的&lt;strong&gt;connected component&lt;/strong&gt;。&lt;br /&gt;
若不太熟悉&lt;strong&gt;connected&lt;/strong&gt;的定義，可以先閱讀&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;稍稍複習。&lt;br /&gt;
此外，為了集中火力，&lt;code&gt;DFS()&lt;/code&gt;與&lt;code&gt;BFS()&lt;/code&gt;的程式碼就留在&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;裡面，如果還沒有對兩個演算法送出交友邀請，千萬不要客氣。&lt;/p&gt;
&lt;p&gt;最後一點溫馨小提醒：Graph與connected component的本質上是Set(集合)，因此，以下將會用到Set的觀點做說明。如果不熟悉Set也沒關係，只要知道Set是「一團不在意次序(order)的資料」就可以了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#how"&gt;DFS與BFS何德何能？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#scc"&gt;如果是Strongly Connected Component呢？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;BFS/DFS系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="how"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;DFS與BFS何德何能？&lt;/h2&gt;
&lt;p&gt;關鍵就是，兩個演算法都能產生&lt;code&gt;predecessor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若vertex(Y)的&lt;code&gt;predecessor[Y]&lt;/code&gt;是vertex(X)，表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vertex(Y)是被vertex(X)給找到。&lt;/li&gt;
&lt;li&gt;也就表示，在undirected graph中，存在edge(X,Y)。&lt;/li&gt;
&lt;li&gt;又因為是undirected graph，若存在edge(X,Y)，就能從vertex(X)走到vertex(Y)，也能從vertex(Y)走到vertex(X)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，若vertex(Y)的&lt;code&gt;predecessor[Y]&lt;/code&gt;是vertex(X)，就表示vertex(X)與vertex(Y)一定在同一個connected component裡面。&lt;/p&gt;
&lt;p&gt;這也就是為什麼&lt;code&gt;DFS()&lt;/code&gt;與&lt;code&gt;BFS()&lt;/code&gt;都能夠用來尋找undirected graph中的connected component的原因。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法&lt;/h2&gt;
&lt;p&gt;尋找connected component的演算法很直觀，只要三步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Graph上執行&lt;code&gt;DFS()&lt;/code&gt;或&lt;code&gt;BFS()&lt;/code&gt;得到&lt;code&gt;predecessor&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;進行&lt;code&gt;SetCollapsing()&lt;/code&gt;。（蛤？）&lt;/li&gt;
&lt;li&gt;印出共有幾個connected component，以及各個connected component中的vertex。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上步驟，顯然有個傢伙很突兀。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SetCollapsing()&lt;/code&gt;是稍後會用到的函式，其功能可以拆成兩個部分理解：一個是「Set」，一個是「Collapsing」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set(集合)：&lt;code&gt;SetCollapsing()&lt;/code&gt;處理的對象是Set，也就是不具「次序(order)」的資料，如圖二左，共有三個Set，分別是&lt;span class="math"&gt;\(S_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,1,4,5,7\)&lt;/span&gt;}、&lt;span class="math"&gt;\(S_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(3,6,8\)&lt;/span&gt;}、&lt;span class="math"&gt;\(S_3=\)&lt;/span&gt;{&lt;span class="math"&gt;\(2\)&lt;/span&gt;}。&lt;ul&gt;
&lt;li&gt;在Set上，時常要做的操作便是「查看某個元素(element)在哪一個Set裡面」，而Set通常是用&lt;code&gt;root&lt;/code&gt;代表，因此，若如圖二左的方式，以element(0)作為「存取點」(也就是這個Set的&lt;code&gt;root&lt;/code&gt;)，那麼要判斷element(7)是在element(0)所代表的Set內(而不是element(3)所代表的Set)，就需要&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;的搜尋時間(&lt;span class="math"&gt;\(N\)&lt;/span&gt;為Set內的元素數量)，從element(7)一路找到element(0)，才能判斷。&lt;/li&gt;
&lt;li&gt;如果能夠以圖二右的資料結構表示Set，那麼以element(0)、element(2)、element(3)代表Set，要判斷任何一個元素(element)是屬於哪一個Set，便只要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;的時間。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Collapsing(塌陷)：讓Set「塌陷」，使得所有element皆能直接指向其所在的Set之&lt;code&gt;root&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(以下先以&lt;code&gt;DFS()&lt;/code&gt;為例，稍後在程式碼的部分將會同步展示以&lt;code&gt;BFS()&lt;/code&gt;進行之結果)&lt;/p&gt;
&lt;p&gt;考慮圖三(a)的undirected graph：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;首先，對Graph進行&lt;code&gt;DFS()&lt;/code&gt;，取得&lt;code&gt;predecessor&lt;/code&gt;，以及圖三(b)的Depth-First Forest：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於是undirected graph，由任意vertex作為&lt;code&gt;DFS()&lt;/code&gt;起點，結果都會相同。此處以vertex(0)作為起點。&lt;/li&gt;
&lt;li&gt;圖三(b)中，vertex(0)、vertex(2)、vertex(3)的&lt;code&gt;predecessor&lt;/code&gt;皆為&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，表示這三者皆為Depth-First Tree的&lt;code&gt;root&lt;/code&gt;，也就是Set的&lt;code&gt;root&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;而其餘的vertex，皆能透過&lt;code&gt;predecessor&lt;/code&gt;回溯到&lt;code&gt;root&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接下來要進行&lt;code&gt;SetCollapsing()&lt;/code&gt;。&lt;br /&gt;
在此先以&lt;span class="math"&gt;\(Set\)&lt;/span&gt;:{&lt;span class="math"&gt;\(0,1,4,5,7\)&lt;/span&gt;}為例作說明，目標是從圖三(c)左轉換成圖三(c)右。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;先觀察：&lt;code&gt;SetCollapsing()&lt;/code&gt;什麼時候完成？&lt;br /&gt;
就是當Set中，除了&lt;code&gt;root&lt;/code&gt;之外的所有vertex(等義於element)的&lt;code&gt;predecessor&lt;/code&gt;都指向&lt;code&gt;root&lt;/code&gt;時，也就是當要被「塌陷」的vertex剩下&lt;code&gt;root&lt;/code&gt;的時候，&lt;code&gt;SetCollapsing()&lt;/code&gt;便完成。&lt;/p&gt;
&lt;p&gt;若現在要對vertex(7)進行&lt;code&gt;SetCollapsing()&lt;/code&gt;，見圖三(d)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(7)標記上&lt;code&gt;current&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;找到vertex(7)所在的Set的&lt;code&gt;root&lt;/code&gt;，也就是vertex(0)，標記上&lt;code&gt;root&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;找到vertex(7)的&lt;code&gt;predecessor&lt;/code&gt;，也就是vertex(5)，標記上&lt;code&gt;parent&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著判斷，若&lt;code&gt;current&lt;/code&gt;不等於&lt;code&gt;root&lt;/code&gt;(表示除了&lt;code&gt;root&lt;/code&gt;之外，還有vertex還沒有「塌陷」，因此&lt;code&gt;SetCollapsing()&lt;/code&gt;還沒有完成)，那麼就把：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;current&lt;/code&gt;的&lt;code&gt;predecessor&lt;/code&gt;更新成&lt;code&gt;root&lt;/code&gt;：&lt;code&gt;predecessor[7]&lt;/code&gt;更新成vertex(0)。&lt;/li&gt;
&lt;li&gt;並且把原先的&lt;code&gt;parent&lt;/code&gt;當成新的&lt;code&gt;current&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移動到vertex(5)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;現在&lt;code&gt;current&lt;/code&gt;變成了vertex(5)，不等於&lt;code&gt;root&lt;/code&gt;vertex(0)，因此繼續：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把&lt;code&gt;parent&lt;/code&gt;標記成vertex(4)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;current&lt;/code&gt;的&lt;code&gt;predecessor&lt;/code&gt;更新成&lt;code&gt;root&lt;/code&gt;：&lt;code&gt;predecessor[5]&lt;/code&gt;更新成vertex(0)。&lt;/li&gt;
&lt;li&gt;並且把原先的&lt;code&gt;parent&lt;/code&gt;當成新的&lt;code&gt;current&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移動到vertex(4)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接下來的&lt;code&gt;current&lt;/code&gt;依序會是vertex(4)、vertex(1)，因為&lt;code&gt;current&lt;/code&gt;還不是vertex(0)，便按照上述步驟「塌陷」。直到&lt;code&gt;current&lt;/code&gt;移到vertex(0)後，&lt;code&gt;SetCollapsing()&lt;/code&gt;便完成，見圖三(f)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f9)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;比較一下經過&lt;code&gt;SetCollapsing()&lt;/code&gt;處立前後的&lt;code&gt;predecessor&lt;/code&gt;，如圖四。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;只要先找到&lt;code&gt;predecessor&lt;/code&gt;為「負值」的vertex，就找到了代表某一connected component的Set之&lt;code&gt;root&lt;/code&gt;，再尋找哪些vertex的&lt;code&gt;predecessor&lt;/code&gt;指向該&lt;code&gt;root&lt;/code&gt;，便能找出該connected component所包含的所有vertex。&lt;/p&gt;
&lt;p&gt;大功告成。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;範例程式碼除了已經介紹過的&lt;code&gt;class Graph&lt;/code&gt;、&lt;code&gt;DFS()&lt;/code&gt;以及&lt;code&gt;BFS()&lt;/code&gt;之外，還多了四個函式。&lt;br /&gt;
其中，在undirected graph中尋找connected component的主要函式：&lt;code&gt;CCDFS(int vertex)&lt;/code&gt;與&lt;code&gt;CCBFS(int vertex)&lt;/code&gt;共包含三個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DFS()&lt;/code&gt;或者&lt;code&gt;BFS()&lt;/code&gt;，取得&lt;code&gt;predecessor&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetCollapsing&lt;/code&gt;是為了讓尋找connected component變得更簡單。&lt;/li&gt;
&lt;li&gt;最後，是利用「塌陷」過後的&lt;code&gt;predecessor&lt;/code&gt;找到connected component。&lt;br /&gt;
(&lt;code&gt;PrintPredecessor()&lt;/code&gt;是為了印出&lt;code&gt;predecessor&lt;/code&gt;以驗證&lt;code&gt;SetCollapsing&lt;/code&gt;的正確性，非必要。)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:white, 1:gray, 2:black&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// for BFS()&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// for DFS()&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adj List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                &lt;span class="c1"&gt;// 利用DFS &lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 利用BFS, 兩者邏輯完全相同&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// 印出predecessor, 供驗証用, 非必要&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// root&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// &lt;/span&gt;
    &lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Component#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Component#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// AdjList[2] empty&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; 
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; 
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; 

&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; 
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; 
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;聰明的讀者們一定已經發現了，不進行&lt;code&gt;SetCollapsing()&lt;/code&gt;，單單只靠&lt;code&gt;predecessor&lt;/code&gt;一樣可以找出connected component。  &lt;/p&gt;
&lt;p&gt;不過筆者認為使用&lt;code&gt;SetCollapsing()&lt;/code&gt;處理&lt;code&gt;predecessor&lt;/code&gt;，雖然不見得是最有效率的方法，但是概念上比較直觀，因為connected component就是Set。&lt;/p&gt;
&lt;p&gt;事實上，這兩種Set表示法(「塌陷」前後的&lt;code&gt;predecessor&lt;/code&gt;)，正好是在Set問題中永恆的兩難(trade-off)：「要&lt;strong&gt;Union&lt;/strong&gt;方便」還是「&lt;strong&gt;Find&lt;/strong&gt;方便」，有興趣的讀者可以看看這篇：&lt;a href="https://www.hackerearth.com/notes/disjoint-set-union-union-find/"&gt;Disjoint Set Union (Union Find)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="scc"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如果是Strongly Connected Component呢？&lt;/h2&gt;
&lt;p&gt;以上處理的是「在undirected graph中尋找connected component」，那如果要在「directed graph中尋找strongly connected component」呢？&lt;/p&gt;
&lt;p&gt;顯然，光是只有&lt;code&gt;predecessor&lt;/code&gt;是不夠的，因為在directed graph中，&lt;code&gt;predecessor&lt;/code&gt;能夠保證的是一個「有方向性」的edge，例如edge(X,Y)表示，從vertex(X)能夠走到vertex(Y)，卻不能打包票從vertex(Y)也能走回vertex(X)。因此，要找到strongly connected component需要更高級的方法才行。&lt;/p&gt;
&lt;p&gt;不過到這裡，是時候&lt;a href="https://www.youtube.com/watch?v=NrGxru6nqeQ"&gt;該說再見了朋友們&lt;/a&gt;。&lt;br /&gt;
更高級的方法，請待下回分曉。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hackerearth.com/notes/disjoint-set-union-union-find/"&gt;Hackerearth：Disjoint Set Union(Union Find)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29"&gt;Wikipedia：Set (abstract data type)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;BFS/DFS系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="BFS"></category><category term="DFS"></category></entry><entry><title>Graph: Depth-First Search(DFS，深度優先搜尋)</title><link href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html" rel="alternate"></link><updated>2016-02-11T22:36:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-11:SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#pre"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;中介紹過Pre-Order Traversal，其Visiting順序：「Current(V)-left(L)-right(R)」可以解讀成「先遇到的node就先Visiting」，因此，每一組「Current-left-right」必定是&lt;code&gt;CurrentNode&lt;/code&gt;先Visiting，接著是&lt;code&gt;leftchild&lt;/code&gt;，最後才是&lt;code&gt;rightchild&lt;/code&gt;。&lt;br /&gt;
若對圖一中的Binary Tree進行Pre-Order Traversal，定義Visiting為印出(print)資料，將得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Depth-First Search(DFS，深度優先搜尋)的核心精神便如同Pre-Order Traversal：「先遇到的vertex就先Visiting」，並且以先遇到的vertex作為新的搜尋起點，直到所有「有edge相連的vertex」都被探索過。&lt;/p&gt;
&lt;p&gt;以圖二的迷宮為例，把迷宮矩陣中的每一格定義成一個vertex，若兩個vertex之間有路，則建立edge相連。若要在迷宮中尋找抵達終點的路線，通常會先選擇其中一條路線，&lt;strong&gt;只要有路就繼續往前走&lt;/strong&gt;。有可能一路走到終點，也有可能遇到死路。若遇到死路則回到上一個岔路，往另一條路探索路線。依此類推，直到走出迷宮。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/maze.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：迷宮問題(maze problem)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#dfs"&gt;Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#discuss"&gt;討論&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#dff_dft"&gt;Depth-First Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4edge"&gt;4種edge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;BFS/DFS系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dfs"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Depth-First Search(DFS，深度優先搜尋)&lt;/h2&gt;
&lt;p&gt;考慮圖三(a)的Graph(沒有weight的directed graph)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若以vertex(A)為起點進行&lt;code&gt;DFS()&lt;/code&gt;，可以得到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若Graph中的vertex與vertex(A)之間存在至少一條path，則&lt;code&gt;DFS()&lt;/code&gt;必定能找到其中一條path從vertex(A)抵達該vertex。但是這條path未必保證是最短路徑(shortest path)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起來好像沒有&lt;code&gt;BFS()&lt;/code&gt;這麼殺手級，雖然找到一條路卻不保證是最短路徑。&lt;br /&gt;
但其實&lt;code&gt;DFS()&lt;/code&gt;還是很有用的，因為經過一次&lt;code&gt;DFS()&lt;/code&gt;後，將得到一項資料稱作&lt;code&gt;finish&lt;/code&gt;，而&lt;code&gt;finish&lt;/code&gt;竟然可以用來...！？&lt;/p&gt;
&lt;p&gt;別轉台，看下去。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法&lt;/h2&gt;
&lt;p&gt;以下介紹的&lt;code&gt;DFS()&lt;/code&gt;需要資料項目共有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt;：在整個&lt;code&gt;DFS()&lt;/code&gt;的過程會有一條「時間軸」，若Graph中有&lt;span class="math"&gt;\(N\)&lt;/span&gt;個vertex，「時間軸」上一共會有&lt;span class="math"&gt;\(2N\)&lt;/span&gt;個「時間點」。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discover&lt;/code&gt;與&lt;code&gt;finish&lt;/code&gt; array：每個vertex會被標記上兩個「時間點」，分別是「被發現(&lt;code&gt;discover&lt;/code&gt;)」的時間與「結束(&lt;code&gt;finish&lt;/code&gt;)」的時間：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;discover&lt;/code&gt;：例如，vertex(B)被vertex(A)找到，則&lt;code&gt;discover[B]&lt;/code&gt;會是&lt;code&gt;discover[A]&lt;/code&gt;加一，表示vertex(B)在整個時間軸上是在vertex(A)之後被找到(這其中便存在「ancestor-descendant」的關係)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finish&lt;/code&gt;：若vertex(B)已經經由有效edge探索過所有與之相連的vertex，表示以vertex(B)為起點的探索已經結束，便標上&lt;code&gt;finish[B]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt; array：利用color標記哪些vertex已經「被發現」與「結束」。&lt;ul&gt;
&lt;li&gt;白色表示該vertex還沒有「被發現」；&lt;/li&gt;
&lt;li&gt;灰色表示該vertex已經「被發現」，但是還沒有「結束」。&lt;/li&gt;
&lt;li&gt;黑色表示該vertex已經「結束」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor&lt;/code&gt; array：記錄某個vertex是被哪一個vertex找到的，如此便能回溯路徑(如同&lt;code&gt;BFS()&lt;/code&gt;，&lt;code&gt;DFS()&lt;/code&gt;亦能生成一個&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;DFS()&lt;/code&gt;的方法如下：&lt;/p&gt;
&lt;p&gt;初始化(initialization)，見圖三(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把&lt;code&gt;time&lt;/code&gt;設為&lt;code&gt;0&lt;/code&gt;，表示還沒有任何vertex「被發現」。&lt;/li&gt;
&lt;li&gt;把所有vertex塗成白色。&lt;/li&gt;
&lt;li&gt;把所有vertex的&lt;code&gt;predecessor&lt;/code&gt;清除(或者設成&lt;code&gt;NULL&lt;/code&gt;、&lt;code&gt;-1&lt;/code&gt;，視資料形態(data type)而定)。&lt;/li&gt;
&lt;li&gt;把所有vertex的&lt;code&gt;discover&lt;/code&gt;與&lt;code&gt;finish&lt;/code&gt;設成&lt;code&gt;0&lt;/code&gt;，表示還沒有開始進行&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以vertex(A)作為起點，見圖三(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將vertex(A)塗成灰色，表示已經「被發現」。&lt;/li&gt;
&lt;li&gt;由於vertex(A)已經「被發現」，便把&lt;code&gt;discover[A]&lt;/code&gt;設為&lt;code&gt;++time&lt;/code&gt;。原本&lt;code&gt;time=0&lt;/code&gt;，而vertex(A)是&lt;code&gt;DFS()&lt;/code&gt;的起點，所以&lt;code&gt;++time&lt;/code&gt;之後&lt;code&gt;distance[A]=1&lt;/code&gt;便表示vertex(A)是第一個被發現。&lt;/li&gt;
&lt;li&gt;接著尋找所有與vertex(A)相連之vertex，只要遇到第一個&lt;strong&gt;仍為白色&lt;/strong&gt;的vertex，便把該vertex設為新的搜尋起點，並將該vertex之&lt;code&gt;predecessor&lt;/code&gt;設為vertex(A)。  &lt;ul&gt;
&lt;li&gt;圖三(a)之&lt;code&gt;Adjacency List&lt;/code&gt;中，第一個與vertex(A)相連的vertex為vertex(B)，接著便&lt;strong&gt;以vertex(B)為起點&lt;/strong&gt;，繼續尋找與vertex(B)相連之「最近的」vertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由於從vertex(A)找到了vertex(B)，便表示「從vertex(A)出發的path」還在更新，於是vertex(A)便還沒有「結束」，所以&lt;code&gt;finish[A]&lt;/code&gt;不需要更新。  &lt;ul&gt;
&lt;li&gt;那麼，什麼時候會更新&lt;code&gt;finish[A]&lt;/code&gt;呢？&lt;br /&gt;
在&lt;code&gt;Adjacency List&lt;/code&gt;中，與vertex(A)相連之vertex有vertex(B)與vertex(C)，要在這兩個vertex都「作為搜尋起點」，並且「探索完所有相連的vertex」後(也就是更新完&lt;code&gt;finish[B]&lt;/code&gt;與&lt;code&gt;finish[C]&lt;/code&gt;後)，才會更新到&lt;code&gt;finish[A]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;圖三(c)中的「Time Stamp(時間戳記)」即為「時間軸」。&lt;br /&gt;
此時進入「剛發現vertex(A)」，並且尚未結束「以vertex(A)作為搜尋起點」的階段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;從vertex(A)作為探索起點，「最先發現」的是vertex(B)，便以其作為新的起點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(B)塗成灰色，表示已經「被發現」。&lt;/li&gt;
&lt;li&gt;由於vertex(B)已經「被發現」，便把&lt;code&gt;discover[B]&lt;/code&gt;設為&lt;code&gt;++time&lt;/code&gt;，也就是&lt;code&gt;distance[B]=2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;接著，找到&lt;code&gt;Adjacency List&lt;/code&gt;中第一個與vertex(B)相連，且為&lt;strong&gt;白色&lt;/strong&gt;的vertex(D)，將vertex(D)視為新的搜尋起點。&lt;/li&gt;
&lt;li&gt;此時圖三(d)的「時間軸」表示，「以vertex(A)作為起點」之搜尋尚未結束(vertex(A)還沒有被塗黑)，而且「以vertex(B)作為起點」之搜尋剛剛開始。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;來到「以vertex(D)作為起點」之搜尋，大致上與「以vertex(B)作為起點」之搜尋相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(D)塗成灰色，表示已經「被發現」。&lt;/li&gt;
&lt;li&gt;由於vertex(D)已經「被發現」，便把&lt;code&gt;discover[D]&lt;/code&gt;設為&lt;code&gt;++time&lt;/code&gt;，也就是&lt;code&gt;distance[D]=3&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;接著，找到&lt;code&gt;Adjacency List&lt;/code&gt;中第一個與vertex(D)相連，且為&lt;strong&gt;白色&lt;/strong&gt;的vertex(E)，將vertex(E)視為新的搜尋起點。&lt;/li&gt;
&lt;li&gt;此時圖三(e)的「時間軸」表示，「以vertex(A)與vertex(B)作為起點」之搜尋都還沒結束(vertex(A)、vertex(B)還沒有被塗黑)，而且「以vertex(D)作為起點」之搜尋剛剛開始。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;來到「以vertex(E)作為起點」之搜尋，與前兩個步驟相同，不再贅述，見圖三(f)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;關鍵是圖三(g)。&lt;br /&gt;
當vertex(E)再也找不到任何「能夠抵達、且為白色」的vertex時(見圖三(g)中Graph的箭頭方向，並對照圖三(a)之&lt;code&gt;Adjacency List&lt;/code&gt;)，就表示「以vertex(E)作為起點」之搜尋已經「結束」，此時：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(E)塗成黑色，表示「以vertex(E)作為起點」之搜尋已經「結束」。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;finish[E]&lt;/code&gt;設成&lt;code&gt;++time&lt;/code&gt;。  &lt;ul&gt;
&lt;li&gt;原先在vertex(E)「被發現」時&lt;code&gt;time=4&lt;/code&gt;，更新後，表示vertex(E)之搜尋在&lt;code&gt;time=5&lt;/code&gt;時「結束」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;當vertex(E)「結束」後，便回到vertex(E)的&lt;code&gt;predecessor&lt;/code&gt;，也就是「發現vertex(E)」的vertex(D)，繼續探索其他vertex(D)能夠走到的vertex。&lt;/li&gt;
&lt;li&gt;此時，圖三(g)的「時間軸」表示，&lt;code&gt;discover[E]=4&lt;/code&gt;，&lt;code&gt;finish[E]=5&lt;/code&gt;，往後搜尋過程就不會再有vertex(E)出現。而以vertex(A)、vertex(B)、vertex(D)作為起點的搜尋則持續進行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，從vertex(E)退回到vertex(D)，並從vertex(D)繼續發現vertex(F)還是白色，於是便以「vertex(F)作為起點」進行搜尋：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(F)塗成灰色。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;discover[F]&lt;/code&gt;設為&lt;code&gt;++time&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;繼續尋找所有從vertex(F)能夠走到，且為白色的vertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;觀察圖三(i)的Graph與圖三(a)的&lt;code&gt;Adjacency List&lt;/code&gt;，發現從vertex(F)能夠走到vertex(B)，但是由於vertex(B)已經是「灰色」，表示「以vertex(B)為起點」之搜尋已經開始且尚未結束，於是vertex(F)無法「發現」vertex(B)，也無法走到其餘vertex，所以，vertex(F)便宣告「結束」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(F)塗成黑色，表示「以vertex(F)作為起點」之搜尋已經「結束」。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;finish[F]&lt;/code&gt;設成&lt;code&gt;++time&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;當vertex(F)「結束」後，便回到vertex(F)的&lt;code&gt;predecessor&lt;/code&gt;，也就是「發現vertex(F)」的vertex(D)，繼續探索其他vertex(D)能夠走到的vertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如圖三(j)，所有vertex(D)能夠抵達的vertex都已經變成黑色，於是「以vertex(D)作為起點」之搜尋便結束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(D)塗成黑色，表示「以vertex(D)作為起點」之搜尋已經「結束」。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;finish[D]&lt;/code&gt;設成&lt;code&gt;++time&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;當vertex(D)「結束」後，便回到vertex(D)的&lt;code&gt;predecessor&lt;/code&gt;，也就是「發現vertex(D)」的vertex(B)，繼續探索其他vertex(B)能夠走到的vertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(j)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著便以上述邏輯重複步驟，直到vertex(A)被塗成黑色，見圖三(k)-(n)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(k)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(l)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(m)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(n)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在「以vertex(A)為起點」之搜尋結束後，必須確認Graph中還有沒有白色的vertex，如圖三(n)，Graph裡還有vertex(G)與vertex(H)仍然是白色，因此挑選其中一個vertex作為新的起點。這裡是按照&lt;code&gt;Adjacency List&lt;/code&gt;的順序，由於vertex(G)在vertex(H)之前，便先挑選vertex(G)，接著重複上述步驟，見圖三(o)-(r)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(o)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(p)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(q)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(r)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;當Graph中所有vertex都被塗成黑色，便完成&lt;code&gt;DFS()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;由以上說明可以觀察出，&lt;code&gt;DFS()&lt;/code&gt;本質上是一種「&lt;strong&gt;遞迴(recursion)結構&lt;/strong&gt;」，而遞迴結構其實是利用了系統的「&lt;strong&gt;堆疊(stack)&lt;/strong&gt;」，因此，這兩種方式皆能實現&lt;code&gt;DFS()&lt;/code&gt;，以下提供的範例程式碼將以遞迴形式完成。&lt;/p&gt;
&lt;p&gt;如同上一篇&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html#code"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;，以下將使用&lt;code&gt;int&lt;/code&gt;處理資料，把&lt;span class="math"&gt;\(9\)&lt;/span&gt;個vertex&lt;code&gt;char A~I&lt;/code&gt;依序對應到&lt;code&gt;int 0~8&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;範例程式碼包含兩個部分&lt;code&gt;main()&lt;/code&gt;與&lt;code&gt;class Graph&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;中，主要兩件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立如圖三(a)的&lt;code&gt;Adjacency List&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;進行&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在&lt;code&gt;class Graph&lt;/code&gt;中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private member：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;num_vertex&lt;/code&gt;：需要在定義&lt;code&gt;Graph&lt;/code&gt;的object(物件)時，給定vertex的數目，以便建立&lt;code&gt;Adjacency List&lt;/code&gt;(或者&lt;code&gt;Adjacency Matrix&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt; std::list&amp;lt;int&amp;gt; &amp;gt; AdjList&lt;/code&gt;：利用C++標準函式庫(STL)提供的container(容器):&lt;code&gt;std::vector&lt;/code&gt;與&lt;code&gt;std::list&lt;/code&gt;來實現。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;discover&lt;/code&gt;、&lt;code&gt;finish&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;：將在&lt;code&gt;DFS()&lt;/code&gt;中使用，功能如上述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;public member：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Constructor:Graph(int num_vertex)&lt;/code&gt;：在定義Graph的object(物件)時，需要知道vertex的數目，並在&lt;code&gt;constructor&lt;/code&gt;中定義好&lt;code&gt;AdjList&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddEdgeList(int from, in to)&lt;/code&gt;：功能便是在&lt;code&gt;AdjList&lt;/code&gt;新增從&lt;code&gt;from&lt;/code&gt;到&lt;code&gt;to&lt;/code&gt;的edge。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DFS(int Start)&lt;/code&gt;：需要知道起點vertex。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DFSVisit(int vertex, int &amp;amp;time)&lt;/code&gt;：利用遞迴函式呼叫，進行&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;discover&lt;/code&gt;、&lt;code&gt;finish&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;等資料更新的主要函式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:white, 1:gray, 2:black&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adj List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 定義見上一篇文章&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;           &lt;span class="c1"&gt;// 配置記憶體位置&lt;/span&gt;
    &lt;span class="n"&gt;discover&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                          &lt;span class="c1"&gt;// 初始化, 如圖三(b)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 檢查所有Graph中的vertex都要被搜尋到&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;               &lt;span class="c1"&gt;// 若vertex不是白色, 則進行以該vertex作為起點之搜尋&lt;/span&gt;
            &lt;span class="n"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                             &lt;span class="c1"&gt;// j會把AdjList完整走過一遍, 確保所有vertex都被搜尋過&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   &lt;span class="c1"&gt;// 一旦有vertex被發現而且是白色, 便進入DFSVisit()&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                         &lt;span class="c1"&gt;// 把vertex塗成灰色&lt;/span&gt;
    &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 更新vertex的discover時間&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// for loop參數太長&lt;/span&gt;
         &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                    &lt;span class="c1"&gt;// 分成兩段&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 若搜尋到白色的vertex&lt;/span&gt;
            &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 更新其predecessor&lt;/span&gt;
            &lt;span class="n"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              &lt;span class="c1"&gt;// 立刻以其作為新的搜尋起點, 進入新的DFSVisit()&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                         &lt;span class="c1"&gt;// 當vertex已經搜尋過所有與之相連的vertex後, 將其塗黑&lt;/span&gt;
    &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// 並更新finish時間&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="c1"&gt;// 定義一個具有八個vertex的Graph&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// 建立如圖三之Graph&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// AdjList[4] is empty&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 以vertex(0), 也就是vertex(A作為DFS()的起點&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="discuss"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;討論&lt;/h2&gt;
&lt;p&gt;若在&lt;code&gt;DFS()&lt;/code&gt;函式主體的最後多加入幾行程式來檢查&lt;code&gt;predecessor&lt;/code&gt;、&lt;code&gt;discover&lt;/code&gt;與&lt;code&gt;finish&lt;/code&gt;三項資料是否符合預期：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
 &lt;span class="c1"&gt;// after for loop&lt;/span&gt;
 &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 印出 A(0) ~ H(7)的predecessor&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;discover time:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 印出 A(0) ~ H(7)的discover time&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;finish time:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 印出 A(0) ~ H(7)的finish time&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;便能得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;discover&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;10&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;  &lt;span class="mi"&gt;13&lt;/span&gt;  &lt;span class="mi"&gt;14&lt;/span&gt;
&lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
  &lt;span class="mi"&gt;12&lt;/span&gt;   &lt;span class="mi"&gt;9&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;與預期的結果相同，如圖四。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dff_dft"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Depth-First Tree&lt;/h3&gt;
&lt;p&gt;如同&lt;code&gt;BFS()&lt;/code&gt;，在Graph上進行&lt;code&gt;DFS()&lt;/code&gt;同樣可以得到&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;，又稱為&lt;strong&gt;Depth-First Tree&lt;/strong&gt;。若Graph本身不是&lt;strong&gt;(strongly) connected component&lt;/strong&gt;，則有可能得到&lt;strong&gt;Depth-First Forest&lt;/strong&gt;，如圖五：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據圖五的「時間軸」，可以直接由&lt;code&gt;discover&lt;/code&gt;與&lt;code&gt;finish&lt;/code&gt;觀察出各個vertex之間的「ancestor-descendant」關係(也就包含了&lt;code&gt;predecessor&lt;/code&gt;關係)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若&lt;code&gt;discover[X]&lt;/code&gt;比&lt;code&gt;discover[Y]&lt;/code&gt;大，而且&lt;code&gt;finish[X]&lt;/code&gt;比&lt;code&gt;finish[Y]&lt;/code&gt;小，表示vertex(X)比vertex(Y)較晚「被發現」，而且較早「結束」，則vertex(X)必定是vertex(Y)的descendant。&lt;ul&gt;
&lt;li&gt;以vertex(E)與vertex(A)為例，vertex(E)的「搜尋生命週期」完全在vertex(A)的「搜尋生命週期」&lt;strong&gt;之內&lt;/strong&gt;，因此vertex(E)必定是vertex(A)的descendant。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相反，若&lt;code&gt;discover[X]&lt;/code&gt;比&lt;code&gt;discover[Y]&lt;/code&gt;小，而且&lt;code&gt;finish[X]&lt;/code&gt;比&lt;code&gt;finish[Y]&lt;/code&gt;大，表示vertex(X)比vertex(Y)較早「被發現」，而且較晚「結束」，則vertex(X)必定是vertex(Y)的ancestor。&lt;ul&gt;
&lt;li&gt;以vertex(B)與vertex(F)為例，vertex(B)的「搜尋生命週期」&lt;strong&gt;完全包覆&lt;/strong&gt;住vertex(F)的「搜尋生命週期」，因此vertex(B)必定是vertex(F)的ancestor。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三種情形，若兩個vertex的「搜尋生命週期」完全沒有重疊，那麼這兩個vertex在Depth-First Forest中：&lt;ol&gt;
&lt;li&gt;有可能在同一棵Depth-First Tree，但是互相沒有「ancestor-descendant」的關係，例如vertex(D)與vertex(C)。此時，&lt;code&gt;discover[D]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;discover[C]&lt;/code&gt;，而且&lt;code&gt;finish[D]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;finish[C]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;也有可能在不同棵Depth-First Tree，例如vertex(C)與vertex(H)。此時，&lt;code&gt;discover[C]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;discover[H]&lt;/code&gt;，而且&lt;code&gt;finish[C]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;finish[H]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="4edge"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4種edge&lt;/h3&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過&lt;code&gt;DFS()&lt;/code&gt;後，還可以分類出四種edge：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Tree edge&lt;/strong&gt;：若vertex(Y)是被vertex(X)「發現」，則edge(X,Y)即為Tree edge，也就是Depth-First Tree中的edge。&lt;ul&gt;
&lt;li&gt;透過顏色判斷edge：當vertex(X)搜尋到vertex(Y)，且vertex(Y)為「白色」時，就會建立出Tree edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Back edge&lt;/strong&gt;：所有指向ancestor的edge，稱為Back edge。如圖六中，edge(F,B)與edge(H,G)。&lt;ul&gt;
&lt;li&gt;透過顏色判斷edge：當vertex(X)搜尋到vertex(Y)，且vertex(Y)為「灰色」，就會建立起Back edge，見圖三(j)、圖三(q)與圖六。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Forward edge&lt;/strong&gt;：所有指向descendant但不是Tree edge的edge，稱為Forward edge。觀察「時間軸」，若Graph存在例如：edge(A,D)、edge(A,E)或者edge(B,E)，即可稱之為Forward edge。很遺憾的，圖六中，沒有Forward edge。&lt;ul&gt;
&lt;li&gt;透過顏色判斷edge：當vertex(X)搜尋到vertex(Y)時，vertex(Y)為「黑色」，並且&lt;code&gt;discover[X]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;discover[Y]&lt;/code&gt;，edge(X,Y)即為Forward edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cross edge&lt;/strong&gt;：若兩個vertex不在同一棵Depth-First Tree上，例如vertex(C)與vertex(H)，或者兩個vertex在同一棵Depth-First Tree上卻沒有「ancestor-descendant」的關係，例如vertex(C)與vertex(F)，則稱連結此兩個vertex的edge為Cross edge。&lt;ul&gt;
&lt;li&gt;透過顏色判斷edge：當vertex(X)搜尋到vertex(Y)時，vertex(Y)為「黑色」，並且&lt;code&gt;discover[X]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;gt;\)&lt;/span&gt;&lt;code&gt;discover[Y]&lt;/code&gt;，edge(X,Y)即為Cross edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分類出四種edge除了可以作為大腦體操，還可以根據Graph中是否具有/不具有某些edge來區分Graph的性質：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若在undirected graph上執行一次&lt;code&gt;DFS()&lt;/code&gt;，所有的edge不是Tree edge就是Back edge。&lt;/li&gt;
&lt;li&gt;若在directed graph上執行一次&lt;code&gt;DFS()&lt;/code&gt;，沒有產生Back edge，則此directed graph必定是&lt;strong&gt;acyclic&lt;/strong&gt;(沒有迴路)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;諸如此類的，是不是很有趣呢？&lt;br /&gt;
(好像也還好。)&lt;/p&gt;
&lt;p&gt;最後再看一次&lt;code&gt;DFS()&lt;/code&gt;的流程，見圖七：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/DFS_Flow.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是Depth-First Search(DFS，深度優先搜尋)的介紹。&lt;br /&gt;
在接下來的文章中，將利用&lt;code&gt;DFS()&lt;/code&gt;與神奇的&lt;code&gt;finish&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;進行&lt;strong&gt;Topological Sort(拓撲排序)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;找到directed graph中的&lt;strong&gt;Strongly Connected Component(SCC)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過在這之前，會先介紹利用&lt;code&gt;BFS()&lt;/code&gt;與&lt;code&gt;DFS()&lt;/code&gt;找到undirected graph中的&lt;strong&gt;connected component&lt;/strong&gt;作為暖身。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codereview.stackexchange.com/questions/82476/depth-first-search-and-breadth-first-search-in-c"&gt;Code Review：Depth First Search and Breadth First Search in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;BFS/DFS系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="DFS"></category></entry><entry><title>Graph: Breadth-First Search(BFS，廣度優先搜尋)</title><link href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html" rel="alternate"></link><updated>2016-02-06T14:15:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-06:SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#level"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;兩篇文章裡，介紹了如何利用&lt;code&gt;queue&lt;/code&gt;在Binary Tree中進行&lt;strong&gt;Level-Order Traversal&lt;/strong&gt;，其概念便是：各個node相對於&lt;code&gt;root&lt;/code&gt;有其對應的level，按照level由小到大依序對node進行Visiting。&lt;br /&gt;
而level便代表了node與&lt;code&gt;root&lt;/code&gt;之「距離」，以Graph的語言來說，「距離」便是path的&lt;strong&gt;length(長度)/distance(距離)&lt;/strong&gt;。如圖一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Level=2：path(A-B)、path(A-C)之length為&lt;span class="math"&gt;\(1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;Level=3：path(A-B-D)、path(A-B-E)、path(A-C-F)之length為&lt;span class="math"&gt;\(2\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;Level=4：path(A-B-E-G)、path(A-B-E-H)之length為&lt;span class="math"&gt;\(3\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而Breadth-First Search(BFS，廣度優先搜尋)便是廣義的Level-Order Traversal，將使用情境從Tree推廣至Graph。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="level-order" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;溫馨小提醒：在解釋演算法時，可能會用到Graph中的專有名詞，如&lt;strong&gt;undirected&lt;/strong&gt;、&lt;strong&gt;connected component&lt;/strong&gt;、&lt;strong&gt;weight&lt;/strong&gt;等等，若覺得這些名詞像被打了馬賽克糊糊的，可以先回到&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;狠狠回憶一番。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bfs"&gt;Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#discuss"&gt;討論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;BFS/DFS系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bfs"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Breadth-First Search(BFS，廣度優先搜尋)&lt;/h2&gt;
&lt;p&gt;所以&lt;code&gt;BFS()&lt;/code&gt;的功能有哪些呢？&lt;/p&gt;
&lt;p&gt;考慮圖二(a)的Graph(沒有weight、是connected的undirected graph)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若選定以vertex(A)作為起點，對圖二(a)的G進行&lt;code&gt;BFS()&lt;/code&gt;，可以得到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;從vertex(A)抵達在Graph裡所有「與vertex(A)在同一個connected component裡」的vertex的最短距離(shortest path)。&lt;br /&gt;
(由於圖二(a)的Graph是connected undirected graph，所以從G中任何一點出發進行&lt;code&gt;BFS()&lt;/code&gt;皆能抵達其餘所有vertex。)&lt;/li&gt;
&lt;li&gt;不僅僅能夠得到vertex(I)與vertex(A)的最短距離為&lt;span class="math"&gt;\(3\)&lt;/span&gt;，還能夠指出一條可能的path，說明要如何從vertex(A)走到vertex(I)，例如path:A-C-F-I，或者path:A-C-G-I。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法&lt;/h2&gt;
&lt;p&gt;在正式開始之前，需要先準備四項武器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;queue&lt;/code&gt;：如同Level-Order Traversal，&lt;code&gt;BFS()&lt;/code&gt;將使用&lt;code&gt;queue&lt;/code&gt;來確保「先被搜尋到的vertex，就先成為新的搜尋起點」。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt; array：利用color標記哪些vertex已經被「找到」，哪些還沒有。&lt;ul&gt;
&lt;li&gt;白色表示該vertex還沒有被找過；&lt;/li&gt;
&lt;li&gt;灰色表示該vertex已經被某個vertex找過；&lt;/li&gt;
&lt;li&gt;黑色表示該vertex已經從&lt;code&gt;queue&lt;/code&gt;的隊伍中移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distance&lt;/code&gt; array：記錄每一個vertex與起點vertex之距離。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor&lt;/code&gt; array：記錄某個vertex是被哪一個vertex找到的，如此便能回溯路徑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;BFS()&lt;/code&gt;的方法如下：&lt;/p&gt;
&lt;p&gt;初始化(initialization)，如圖二(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把所有vertex塗成白色，表示還沒有任何vertex被「找到」。&lt;/li&gt;
&lt;li&gt;把所有vertex的&lt;code&gt;distance&lt;/code&gt;設為無限大，表示從起點vertex走不到，或者還沒有走到。&lt;/li&gt;
&lt;li&gt;把所有vertex的&lt;code&gt;predecessor&lt;/code&gt;清除(或者設成&lt;code&gt;NULL&lt;/code&gt;、&lt;code&gt;-1&lt;/code&gt;，可以辨識出何者為「起點」即可)。&lt;/li&gt;
&lt;li&gt;建立空的&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;把起點vertex(A)推進&lt;code&gt;queue&lt;/code&gt;，如圖二(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將vertex(A)塗成灰色，表示vertex(A)在之後的&lt;code&gt;BFS()&lt;/code&gt;過程中，將不可能再被其他vertex「找到」。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distance[A]&lt;/code&gt;設為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。換句話說，&lt;code&gt;distance&lt;/code&gt;為&lt;span class="math"&gt;\(0\)&lt;/span&gt;的vertex就是在「一個connected component」上進行&lt;code&gt;BFS()&lt;/code&gt;的起點。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor[A]&lt;/code&gt;不更動。若將&lt;code&gt;predecessor&lt;/code&gt;初始化成&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，即表示，在&lt;code&gt;BFS()&lt;/code&gt;結束後，&lt;code&gt;predecessor&lt;/code&gt;仍為&lt;span class="math"&gt;\(-1\)&lt;/span&gt;的vertex即為起點。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，以&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;當作新的起點搜尋。&lt;br /&gt;
新的起點是vertex(A)，便檢查所有與vertex(A)相鄰的vertex(見圖二(a)的&lt;code&gt;Adjacency List&lt;/code&gt;)，修改其&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;distance&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;。&lt;br /&gt;
如圖二(d)，vertex(B)、vertex(C)、vertex(D)與vertex(A)相鄰，如果vertex的顏色是白色，表示還沒有被其他vertex「找到」，便執行以下步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將三個vertex的&lt;code&gt;color&lt;/code&gt;塗成灰色。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;distance[B]、distance[C]、distance[D]&lt;/code&gt;設成&lt;code&gt;distance[A]&lt;/code&gt;&lt;span class="math"&gt;\(+1=1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;predecessor[B]、predecessor[C]、predecessor[D]&lt;/code&gt;設成vertex(A)。&lt;/li&gt;
&lt;li&gt;把三個vertex按照「找到」的順序，依序推進&lt;code&gt;queue&lt;/code&gt;裡。&lt;/li&gt;
&lt;li&gt;最後，把vertex(A)塗黑，移出&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;經過以上步驟，vertex(B)、vertex(C)、vertex(D)便被vertex(A)「找到」，並把&lt;code&gt;predecessor&lt;/code&gt;設成vertex(A)，所以回溯路徑時，任何經過vertex(B)的path，必定是由vertex(A)來。同理，vertex(C)與vertex(D)也是。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;distance[B]&lt;/code&gt;是vertex(A)的&lt;code&gt;distance[A]&lt;/code&gt;加一，如此一來，只要到達vertex(A)是經由最短路徑，那麼從vertex(A)走到vertex(B)的路徑，也會是最短路徑。&lt;br /&gt;
由於vertex(A)是起點，&lt;code&gt;distance[A]&lt;/code&gt;&lt;span class="math"&gt;\(=0\)&lt;/span&gt;，因此，&lt;code&gt;distance[B]&lt;/code&gt;&lt;span class="math"&gt;\(=1\)&lt;/span&gt;一定是從vertex(A)走到vertex(B)的最短距離。&lt;/p&gt;
&lt;p&gt;由於推進&lt;code&gt;queue&lt;/code&gt;的順序正好是vertex被「找到」的順序，因此，之後要取得&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;作為新的起點做搜尋時，便能確保按照先前被「找到」的順序(如同Tree的Level-Order Traversal)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：以vertex(A)作為搜尋起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，繼續以&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;當作新的起點搜尋。&lt;br /&gt;
新的起點是vertex(B)，檢查所有與其相鄰的vertex，共有vertex(A)與vertex(E)。由於vertex(A)已經被「找到」過(顏色為灰色或黑色)，因此，vertex(B)只能找到vertex(E)，便進行以下步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將vertex(E)的&lt;code&gt;color&lt;/code&gt;塗成灰色。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;distance[E]&lt;/code&gt;設成&lt;code&gt;distance[B]&lt;/code&gt;&lt;span class="math"&gt;\(+1=2\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;predecessor[E]&lt;/code&gt;設成vertex(B)。&lt;/li&gt;
&lt;li&gt;將vertex(E)推進&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最後，把vertex(B)塗黑，移出&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)：以vertex(B)作為搜尋起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由於vertex(B)是第一個&lt;code&gt;distance&lt;/code&gt;為&lt;span class="math"&gt;\(1\)&lt;/span&gt;且被視為搜尋起點的vertex，這就表示，所有&lt;code&gt;distance&lt;/code&gt;為&lt;span class="math"&gt;\(0\)&lt;/span&gt;的vertex都已經&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;被當作搜尋起點。&lt;/li&gt;
&lt;li&gt;搜尋過其相鄰之vertex。&lt;/li&gt;
&lt;li&gt;被塗成黑色。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;往後&lt;code&gt;queue&lt;/code&gt;裡面只會出現&lt;code&gt;distance&lt;/code&gt;&lt;span class="math"&gt;\(\geq 1\)&lt;/span&gt;的vertex。
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;接下來，繼續以&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;，得到vertex(C)作為新的起點，檢查其相鄰的vertex的顏色，如果是灰色或黑色(vertex(A)與vertex(E)已經被「找到」)則忽略，若是白色(vertex(F)、vertex(G)、vertex(H))，見圖二(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;color&lt;/code&gt;修改成灰色。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;distance&lt;/code&gt;修改成&lt;code&gt;distance[C]&lt;/code&gt;&lt;span class="math"&gt;\(+1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;predecessor&lt;/code&gt;修改成vertex(C)。&lt;/li&gt;
&lt;li&gt;將vertex按照被「找到」的順序，推進&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;將vertex(C)塗黑，移出&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(f)：以vertex(C)作為搜尋起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，從&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;找到vertex(D)，可惜所有與vertex(D)相鄰的vertex(A)與vertex(H)不是灰色就是黑色，都已經被「找到」，見圖二(g)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將vertex(D)塗黑，移出&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(g)：以vertex(D)作為搜尋起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，重複上述之步驟，直到&lt;code&gt;queue&lt;/code&gt;被清空，即結束&lt;code&gt;BFS()&lt;/code&gt;搜尋，見圖二(h)-(l)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(h)：以vertex(E)作為搜尋起點。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(i)：以vertex(F)作為搜尋起點，將vertex(I)推進&lt;code&gt;queue&lt;/code&gt;。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(j)：以vertex(G)作為搜尋起點。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(k)：以vertex(H)作為搜尋起點。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(l)：以vertex(I)作為搜尋起點。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;當&lt;code&gt;queue&lt;/code&gt;中的vertex都被移除(&lt;code&gt;pop()&lt;/code&gt;)，表示&lt;code&gt;Adjacency List&lt;/code&gt;中的所有vertex都被當作起點搜尋過其相鄰的vertex，此時&lt;code&gt;BFS()&lt;/code&gt;便完成，得到以vertex(A)為起點，所有其餘vertex之相對應&lt;code&gt;distance&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;，如圖二(m)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(m)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;(為了簡化程式，以下程式將使用&lt;code&gt;int&lt;/code&gt;處理資料，把&lt;span class="math"&gt;\(9\)&lt;/span&gt;個vertex&lt;code&gt;char A~I&lt;/code&gt;依序對應到&lt;code&gt;int 0~8&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;範例程式碼包含兩個部分&lt;code&gt;main()&lt;/code&gt;與&lt;code&gt;class Graph&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;中，主要有兩件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立如圖二(a)的&lt;code&gt;Adjacency List&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;進行&lt;code&gt;BFS()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在&lt;code&gt;class Graph&lt;/code&gt;中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private member：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;num_vertex&lt;/code&gt;：需要在定義&lt;code&gt;Graph&lt;/code&gt;的object(物件)時，給定vertex的數目，以便建立&lt;code&gt;Adjacency List&lt;/code&gt;(或者&lt;code&gt;Adjacency Matrix&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt; std::list&amp;lt;int&amp;gt; &amp;gt; AdjList&lt;/code&gt;：利用C++標準函式庫(STL)提供的container(容器):&lt;code&gt;std::vector&lt;/code&gt;與&lt;code&gt;std::list&lt;/code&gt;來實現。這樣的寫法的優點是：不需要使用到&lt;code&gt;new operator&lt;/code&gt;，便能夠將記憶體控管交給STL，不需要自行處理&lt;code&gt;delete operator&lt;/code&gt;，以避免記憶體遺漏(memory leak)，詳細討論請參考&lt;a href="http://codereview.stackexchange.com/questions/82476/depth-first-search-and-breadth-first-search-in-c"&gt;Code Review：Depth First Search and Breadth First Search in C++&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;distance&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;：將在&lt;code&gt;BFS()&lt;/code&gt;中使用，功能如上述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;public member：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Constructor:Graph(int num_vertex)&lt;/code&gt;：在定義Graph的object(物件)時，需要知道vertex的數目，並在&lt;code&gt;constructor&lt;/code&gt;中定義好&lt;code&gt;AdjList&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddEdgeList(int from, in to)&lt;/code&gt;：功能便是在&lt;code&gt;AdjList&lt;/code&gt;新增從&lt;code&gt;from&lt;/code&gt;到&lt;code&gt;to&lt;/code&gt;的edge。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BFS(int Start)&lt;/code&gt;：前面提到的Graph恰好是connected undirected graph，因此只要一次&lt;code&gt;BFS()&lt;/code&gt;就能走到Graph中的所有vertex。然而，有些Graph並不是connected graph，無法以任意vertex作為起點走到其餘所有vertex(Graph中具有多個connected component)，因此，需要再多一個迴圈(以下是用&lt;code&gt;for loop&lt;/code&gt;)確保Graph中的全部vertex都被「找到」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:白色, 1:灰色, 2:黑色&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// 0:起點, 無限大:從起點走不到的vertex&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// -1:沒有predecessor, 表示為起點vertex&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;           &lt;span class="c1"&gt;// default constructor&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;        &lt;span class="c1"&gt;// constructor with input: number of vertex&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adjacency List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// 初始化，如圖二(b)&lt;/span&gt;
        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                       &lt;span class="c1"&gt;// 0:白色;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// -1表示沒有predecessor&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// num_vertex個vertex, &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;                                       &lt;span class="c1"&gt;// 最長距離 distance = num_vertex -1條edge&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// j從0數到num_vertex-1, 因此j會走過graph中所有vertex&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 第一次i會是起點vertex, 如圖二(c)&lt;/span&gt;
            &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// 1:灰色&lt;/span&gt;
            &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 每一個connected component的起點之距離設成0&lt;/span&gt;
            &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 每一個connected component的起點沒有predecessor&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                  &lt;span class="c1"&gt;// u 為新的搜尋起點&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// for loop 太長&lt;/span&gt;
                     &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                         &lt;span class="c1"&gt;// 分成兩段&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 若被「找到」的vertex是白色&lt;/span&gt;
                        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// 塗成灰色, 表示已經被「找到」&lt;/span&gt;
                        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 距離是predecessor之距離加一&lt;/span&gt;
                        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 更新被「找到」的vertex的predecessor&lt;/span&gt;
                        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                      &lt;span class="c1"&gt;// 把vertex推進queue&lt;/span&gt;
                    &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// 把u移出queue&lt;/span&gt;
                &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 並且把u塗成黑色&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// 若一次回圈沒有把所有vertex走過, 表示graph有多個connected component&lt;/span&gt;
        &lt;span class="c1"&gt;// 就把i另成j, 繼續檢查graph中的其他vertex是否仍是白色, 若是, 重複while loop&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    
    &lt;span class="c1"&gt;// 建立出圖二(a)的Adjacency List&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;g1.BFS(0)&lt;/code&gt;後，若觀察&lt;code&gt;distance&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;，應該能看到如圖二(n)的結果：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(n)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="discuss"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;討論&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由於&lt;code&gt;BFS()&lt;/code&gt;是用&lt;code&gt;AdjList&lt;/code&gt;來判斷edge的連結狀況，因此，&lt;code&gt;BFS()&lt;/code&gt;對undirected graph或directed graph皆適用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若將&lt;code&gt;predecessor array&lt;/code&gt;中，所有vertex的「前後關係」以edge連結，可以得到&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;。以圖三(a)的subgraph為例，因為其connected與acyclic的性質，使得Predecessor Subgraph會是一棵以起點vertex為&lt;code&gt;root&lt;/code&gt;的Tree，又稱為&lt;strong&gt;Breadth-First Tree&lt;/strong&gt;，而所有Predecessor Subgraph出現的edge稱為&lt;strong&gt;tree edge&lt;/strong&gt;。&lt;br /&gt;
(若Graph本身是由多個(strongly) connected component，則有可能得到&lt;strong&gt;Breadth-First Forest&lt;/strong&gt;，詳見&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖三(a)的&lt;strong&gt;Breadth-First Tree&lt;/strong&gt;可能不止有一種可能，原因在於「建立&lt;code&gt;Adjacency List&lt;/code&gt;時的順序」，將會影響到&lt;code&gt;BFS()&lt;/code&gt;中的&lt;code&gt;for loop&lt;/code&gt;在「找到」vertex時的順序。&lt;ul&gt;
&lt;li&gt;如圖三(b)，若更改圖二(a)之&lt;code&gt;AdjList&lt;/code&gt;，把vertex(A)之Linked list中，vertex(B)與vertex(C)之順序對調，使得&lt;code&gt;BFS()&lt;/code&gt;在搜尋vertex時，vertex(C)會比vertex(B)更早進入&lt;code&gt;queue&lt;/code&gt;，也就更早成為搜尋的新起點，那麼最後得到的Breadth-First Tree就會不同。&lt;/li&gt;
&lt;li&gt;不過，雖然Breadth-First Tree不一樣，但是每個vertex相對於起點vertex的&lt;code&gt;distance&lt;/code&gt;保證相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本篇文章所提供的&lt;code&gt;BFS()&lt;/code&gt;演算法，其&lt;code&gt;color&lt;/code&gt;之灰色與黑色可以合併，換句話說，若只使用白色與黑色，同樣能完成&lt;code&gt;BFS()&lt;/code&gt;。不過在下一篇文章將介紹的&lt;code&gt;DFS()&lt;/code&gt;演算法中，白色、灰色與黑色將分別具有不同功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是Breadth-First Search(BFS，廣度優先搜尋)之介紹。&lt;br /&gt;
下一篇將介紹另一種在Graph同樣常見的搜尋方法：Depth-First Search(DFS，深度優先搜尋)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codereview.stackexchange.com/questions/82476/depth-first-search-and-breadth-first-search-in-c"&gt;Code Review：Depth First Search and Breadth First Search in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://theoryofprogramming.com/adjacency-list-using-cpp-stl/"&gt;Theory of Programming：Adjacency List using C++ STL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/detect-cycle-undirected-graph/"&gt;GeeksforGeeks：Detect cycle in an undirected graph&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;BFS/DFS系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="BFS"></category></entry><entry><title>Graph: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html" rel="alternate"></link><updated>2016-02-03T23:49:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-03:SecondRound/graph-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在經歷過&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree系列文章&lt;/a&gt;的洗禮後，接著要介紹的是Graph(圖)。&lt;/p&gt;
&lt;p&gt;Graph比Tree更加廣義，其定義僅僅使用了集合(Set)，並且不限制結構裡的node/vertex只能有唯一的&lt;code&gt;parent field&lt;/code&gt;，因此，更多的問題能夠以Graph建立模型。 &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#course"&gt;初探Graph的美妙：以課程與其先修科目為例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#graph"&gt;Graph的定義&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#represent"&gt;表示法(representation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#terminology"&gt;一些名詞解釋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#app"&gt;預告：Graph的應用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Graph系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="course"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;初探Graph的美妙：以課程與其先修科目為例&lt;/h2&gt;
&lt;p&gt;有一間大學的計算機科學學位之必修課程，以及與該課程相關的先修科目設計如表一：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Course name&lt;/th&gt;
&lt;th&gt;Prerequisites&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Programming I(程式設計 I)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discrete Mathematics(離散數學)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data Structures(資料結構)&lt;/td&gt;
&lt;td&gt;Programming I, Discrete Mathematics&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calculus I(微積分 I)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calculus II(微積分 II)&lt;/td&gt;
&lt;td&gt;Calculus I&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linear Algebra(線性代數)&lt;/td&gt;
&lt;td&gt;Calculus II&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Analysis of Algorithm(演算法分析)&lt;/td&gt;
&lt;td&gt;Data Structures, Linear Algebra&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Assembly Language(組合語言)&lt;/td&gt;
&lt;td&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Operating Systems(作業系統)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm, Assembly Language&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Programming Language(程式語言)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compiler Design(編譯器設計)&lt;/td&gt;
&lt;td&gt;Programming Language&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Artificial Intelligence(人工智慧)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Computational Theory(計算機理論)  &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parallel Algorithms(平行演算法)&lt;/td&gt;
&lt;td&gt;Computational Theory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Numerical Analysis(數值方法)&lt;/td&gt;
&lt;td&gt;Calculus II&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：某計算機科學學位之必修課程表&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;第一眼或許不太容易立即由表格獲得修課順序的資訊，因為表格受限於上至下、左至右的格式，只能逐項列出資訊，不容易表達資料與資料間的「先後關係」。&lt;/p&gt;
&lt;p&gt;現在換個方式，將具有先後修課順序的課程以線段與箭號連接，若A是B的先修課程，則箭號由A指向B，即可將表一轉換成圖一：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="prerequisites" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由圖一，將資料與資料的「先後關係」以「資料節點」與「線段(箭號)」表示，攻讀這門計算機科學學位的修課流程圖便一目了然。&lt;/p&gt;
&lt;p&gt;這樣的想法，不只是將表格轉換成對人類視覺上有意義的「圖」而已，對電腦來說，由於以Graph建立之模型能夠保持資料之間的「關係」，使得各種巧妙的演算法能夠在Graph中完成各種任務。&lt;br /&gt;
(反例：若要把在Graph上實現的各種演算法，如法炮製在以二維陣列表示的表一上，將會非常困難。)&lt;/p&gt;
&lt;p&gt;本篇文章的重點著重在介紹Graph(圖)的定義與實現方式，而接下來的文章將介紹一些基本的與Graph相關之演算法。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="graph"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Graph的定義&lt;/h2&gt;
&lt;p&gt;在圖一中，每一門課程被視為「資料節點」，且課程與課程之間有「線段(箭號)」連結：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;vertex&lt;/strong&gt;：稱每一個「資料節點」為vertex(或是node)，並定義所有的vertex所形成之集合(Set)為&lt;span class="math"&gt;\(V\)&lt;/span&gt;或&lt;span class="math"&gt;\(V(G)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;edge&lt;/strong&gt;：稱每一個「線段(箭號)」為edge(實際上是用一對vertex表示edge，例如&lt;span class="math"&gt;\((V_i,V_j)\)&lt;/span&gt;即為連結V&lt;sub&gt;i&lt;/sub&gt;與V&lt;sub&gt;j&lt;/sub&gt;的edge)，並定義所有的edge所形成之集合(Set)為&lt;span class="math"&gt;\(E\)&lt;/span&gt;或&lt;span class="math"&gt;\(E(G)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;則Graph定義為&lt;span class="math"&gt;\(V\)&lt;/span&gt;與&lt;span class="math"&gt;\(E\)&lt;/span&gt;所形成的集合，表示成&lt;span class="math"&gt;\(G(V,E)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再根據edge是否具有「方向性」，可以將Graph分成「directed graph(有向圖)」與「undirected graph(無向圖)」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;directed graph(有向圖)&lt;/strong&gt;：edge的方向性表示資料間的關係，若vertex(A)與vertex(B)之關係是「單向的」，那麼連結vertex(A)與vertex(B)的edge即具有方向性。  &lt;ul&gt;
&lt;li&gt;以圖一中的課程與其先修科目為例，vertex(Data Structures)是vertex(Analysis of Algorithm)的先修課程，相反則否，因此，連結兩個vertex之edge具有方向性，而所有vertex與edge形成之集合即為directed graph；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undirected graph(無向圖)&lt;/strong&gt;：edge的方向性表示資料間的關係，若vertex(A)與vertex(B)的關係是「雙向的」，那麼連結vertex(A)與vertex(B)之edge就不具有方向性。  &lt;ul&gt;
&lt;li&gt;如圖二中，如果可以開車從玉山抵達太魯閣，就能夠從太魯閣原路折返回到玉山，因此，這兩個地理位置之間的交通路線便不具有方向性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="google_map" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：Google Map路線規劃，開車過去要4小時34分鐘。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再看幾個Graph的範例。&lt;br /&gt;
圖三(a)中的G&lt;sub&gt;1&lt;/sub&gt;與G&lt;sub&gt;2&lt;/sub&gt;為undirected graph，圖三(b)中的G&lt;sub&gt;3&lt;/sub&gt;與G&lt;sub&gt;4&lt;/sub&gt;為directed graph。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="undirected" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：Tree(樹)也是undirected graph(無向圖)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="directed" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：directed graph(有向圖)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="represent"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;表示法(representation)&lt;/h3&gt;
&lt;p&gt;那麼該如何表示Graph呢？&lt;br /&gt;
一般有兩種常用的表示法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Adjacency Matrix(相鄰矩陣)&lt;/strong&gt;：一個二維矩陣，若從vertex(A)到vertex(B)有edge，則矩陣位置[A][B]值為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，反之，則為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。  &lt;ul&gt;
&lt;li&gt;以圖四為例，在undireced graph中，vertex(X)與vertex(Y)之間有edge，則矩陣位置[X][Y]與[Y][X]之值皆為&lt;span class="math"&gt;\(1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;在directed graph中，有從vertex(X)指向vertex(Y)的edge，則矩陣位置[X][Y]之值為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，但是沒有反向的edge，因此矩陣位置[Y][X]之值為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adjacency List(相鄰串列)&lt;/strong&gt;：先以一個一維陣列列出所有的vertex，再以Linked list表示所有與vertex相連的vertex。&lt;br /&gt;
(vertex接進Linked list的順序不重要，因為是Graph是定義成Set。)  &lt;ul&gt;
&lt;li&gt;以圖四為例，在undireced graph中，vertex(W)與vertex(Z)、vertex(Y)、vertex(V)具有edge相連，則在一維陣列中表示vertex(W)之位置之後，依序接上vertex(Z)、vertex(Y)、vertex(V)。&lt;/li&gt;
&lt;li&gt;在direced graph中，vertex(W)僅僅剩下指向vertex(Y)與vertex(V)的edge，因此，在一維陣列中表示vertex(W)之位置之後，只要接上vertex(Y)與vertex(V)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="selfloop" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：Adjacency Matrix與Adjacency List適用於directed graph與undirected graph。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;比較兩者的差異：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用記憶體空間：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：一定會用到&lt;span class="math"&gt;\(O(|V|^2)\)&lt;/span&gt;，因此，若Graph較為「稠密(dense)」，各vertex之間的edge數量較多則適合使用Adjacency Matrix；&lt;/li&gt;
&lt;li&gt;Adjacency List：將使用&lt;span class="math"&gt;\(O(|V|+|E|)\)&lt;/span&gt;，因此，若Graph較為「稀疏(sparse)」，edge數量較少，如圖一的Graph，即適合使用Adjacency List。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;存取資料：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：由於Matrix是連續記憶體，在存取資料時會稍微快一些；&lt;/li&gt;
&lt;li&gt;Adjacency List：同理，若是使用動態記憶體配置建立Linked list，則資料存取會稍慢(這項缺點可以使用C++的STL::Vector解決，不過STL::Vector不適合用在動態改變的Graph上)。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;新增edge：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：在Matrix中增加一條edge僅僅是把矩陣中相對應位置的值從&lt;span class="math"&gt;\(0\)&lt;/span&gt;設成&lt;span class="math"&gt;\(1\)&lt;/span&gt;，只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Adjacency List：若每次都把新的vertex加在List的最前端(front)，也只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;。不過，最壞情況(worst case)發生在「某個vertex與其他vertex全部相連」，因此需要&lt;span class="math"&gt;\(O(|E|)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;刪除edge：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：在Matrix中刪除edge僅僅是把矩陣中相對應位置的值從&lt;span class="math"&gt;\(1\)&lt;/span&gt;設成&lt;span class="math"&gt;\(0\)&lt;/span&gt;，只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Adjacency List：如同在Linked list中刪除資料，需要&lt;span class="math"&gt;\(O(|E|)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="terminology"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;一些名詞解釋&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;adjacent(相鄰)&lt;/strong&gt;：若在vertex(A)與vertex(B)之間有一條edge(不論是否具有方向性)，則稱vertex(A)與vertex(B)為adjacent(相鄰)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;subgraph(子圖)&lt;/strong&gt;：若構成G'的兩個集合滿足&lt;span class="math"&gt;\(V(G')\subseteq V(G), E(G')\subseteq E(G)\)&lt;/span&gt;，則稱G'為G的subgraph，如圖五。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：G與G的subgraph。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;path(路徑)&lt;/strong&gt;：若從vertex(V&lt;sub&gt;1&lt;/sub&gt;)到vertex(V&lt;sub&gt;k&lt;/sub&gt;)存在一連串前後相接的edge(&lt;span class="math"&gt;\((V_i,V_{i+1})\subseteq E(G),i=1,2,...,k-1\)&lt;/span&gt;)，則稱這一連串edge為「從vertex(V&lt;sub&gt;1&lt;/sub&gt;)到vertex(V&lt;sub&gt;k&lt;/sub&gt;)的path」。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;length(長度)/distance(距離)&lt;/strong&gt;：length(或distance)即是path中的edge數。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;simple path(簡單路徑)&lt;/strong&gt;：若一條path中，除了起點vertex與終點vertex之外，沒有vertex被重複經過，則稱這條path為simple path。  &lt;ul&gt;
&lt;li&gt;如圖六中，path:X-Y-Z即為simple path，path:W-Y-Z-V-W也是simple path，即使W有重複，但是因為分別是起點與終點，所以仍符合定義。而path:Y-X-Y-W就不是simple path，因為第二次經過Y時，Y不是終點。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cycle(循環)&lt;/strong&gt;：若有ㄧ條「simple path」的起點vertex與終點vertex相同，則稱這條path為cycle。  &lt;ul&gt;
&lt;li&gt;圖六中的path:W-Y-Z-V-W，稱為directed cycle(有向循環)；&lt;/li&gt;
&lt;li&gt;圖七中的path:Y-V-W-Y與path:X-Y-W-Z-X皆為undirected cycle(無向循環)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acyclic graph(無循環圖)&lt;/strong&gt;：若graph中不存在cycle，則稱這個graph為acyclic graph，見圖七。  &lt;ul&gt;
&lt;li&gt;在Tree中找不到任何一條simple path的起點與終點是相同vertex(node)，因此Tree一定是acyclic graph。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;weight(權重)&lt;/strong&gt;：若要表示兩個地理位置之間的「距離」或是運送「成本」，可以在edge上加上weight，這樣的graph又稱為weighted graph，如圖八。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖八：weight的值可能為正或是負。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;connected&lt;/strong&gt;：若存在從vertex(A)指向vertex(B)、以及從vertex(B)指向vertex(A)的edge(若是在directed graph中，需要兩條edge；若是undirected graph只需要一條edge)，則稱vertex(A)與vertex(B)為connected，見圖九(a)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(a)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;connected in undirected graph&lt;/strong&gt;：若在undirected graph中，對任意兩個vertex都存在一條path連結這兩個vertex，則稱此undirected graph是connected。  &lt;ul&gt;
&lt;li&gt;圖九(b)中，G&lt;sub&gt;1&lt;/sub&gt;中的所有vertex都可以經過一條path到達其他vertex，因此G&lt;sub&gt;1&lt;/sub&gt;為connected。  &lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;2&lt;/sub&gt;中，vertex:X、S、Z分別與vertex:Y、W、T之間皆不存在path，因此G&lt;sub&gt;2&lt;/sub&gt;不是connected。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;connected component&lt;/strong&gt;：若在一個undirected graph中，存在某一個subgraph是connected，而且沒有任何vertex、edge再加入這個subgraph之集合後仍能使得這個subgraph維持connected特性，則稱此subgraph為connected component(最大集合的connected subgraph)。  &lt;ul&gt;
&lt;li&gt;圖九(b)中，右上方為G&lt;sub&gt;1&lt;/sub&gt;的其中一個subgraph。此subgraph不是connected component，原因在於，再加入vertex:W、T，以及edge:(Y,W)、(Y,T)，也就是變回G&lt;sub&gt;1&lt;/sub&gt;後，仍然維持connected特性，因此這個subgraph並不是「可以維持connected的最大集合」。&lt;br /&gt;
換句話說，在一個connected的undirected graph中，只會有一個connected component，就是graph本身。  &lt;/li&gt;
&lt;li&gt;圖九(b)的G&lt;sub&gt;2&lt;/sub&gt;本身不是connected，而是由兩個connected component組成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(b)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;strongly connected in directed graph&lt;/strong&gt;：若在directed graph中，對任意兩個vertex(A)與vertex(B)同時存在「從vertex(A)走到vertex(B)」以及「從vertex(B)走到vertex(A)」的path，則稱此directed graph是strongly connected。&lt;ul&gt;
&lt;li&gt;圖九(c)，G&lt;sub&gt;3&lt;/sub&gt;中的所有vertex都可以經過一條path到達其他vertex，因此G&lt;sub&gt;3&lt;/sub&gt;為strongly connected。&lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;4&lt;/sub&gt;並非strongly connected，例如，雖然path:S-X-T-Z可以從vertex(S)走到vertex(Z)，但是從vertex(Z)卻無法經由任何一條path到達vertex(S)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;strongly connected component&lt;/strong&gt;：若在一個directed graph中，存在某一個subgraph是strongly connected，而且沒有任何vertex、edge再加入這個subgraph之集合後仍能使得這個subgraph維持strongly connected特性，則稱此subgraph為strongly connected component(最大集合的strongly connected subgraph)。&lt;ul&gt;
&lt;li&gt;圖九(c)中，右上方為G&lt;sub&gt;3&lt;/sub&gt;的其中一個subgraph。此subgraph不是strongly connected component，原因在於，再加入edge:(W,Z)後(也就是變回G&lt;sub&gt;3&lt;/sub&gt;)，仍然維持connected特性，因此這個subgraph並不是「可以維持connected的最大集合」。&lt;br /&gt;
如同undirected graph，若一個directed graph本身是strongly sonnected，則本身也是唯一的strongly connected component。&lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;4&lt;/sub&gt;是由三個strongly connected component組成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(c)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;self-loop(自我迴圈)&lt;/strong&gt;：若有edge從vertex(A)指向vertex(A)，即稱為self-edge或是self-loop。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;multigraph(多邊圖)&lt;/strong&gt;：若在graph中相同的edge重複出現多次，則稱此圖為multigraph，之後要討論的Graph將排除此種情形。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="selfloop" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖十：self-loop與multigraph在directed graph和undirected graph中定義皆相同。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="app"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;預告：Graph的應用&lt;/h2&gt;
&lt;p&gt;在接下來的文章，主要將探討以下三個應用的演算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Minimum Spanning Tree(MST，最小生成樹)&lt;/strong&gt;：給定一個connected、weighted的undirected graph，要在這個graph中，找到(1)連結所有vertex，而且(2)edge上的weight總和最小的「Tree」。&lt;br /&gt;
例如，鄉公所要鋪路，先以鄉公所為中心(&lt;code&gt;root&lt;/code&gt;)，把所有馬路必須到達的地區視為vertex，則路就是edge，那麼，鋪路的目標便是利用最低成本(weight總和最小)將馬路延伸到所有必須抵達的地區，這就是MST的問題。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Shortest Path(最短路徑)&lt;/strong&gt;：顧名思義，最短路徑即是找到vertex(A)與vertex(B)之間「成本」最小的path，例如以Google Map規劃時間成本最小的路線。&lt;br /&gt;
其中又可以分為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Single-Pair Shortest Path&lt;/strong&gt;：從一個vertex，抵達特定的另一個vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single-Source Shortest Path&lt;/strong&gt;：從一個vertex，抵達graph中其餘所有vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single-Destination Shortest Path&lt;/strong&gt;：從每一個graph中的vertex抵達特定的vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All-Pairs Shortest Path&lt;/strong&gt;：graph中的所有vertex抵達其餘所有vertex之最短路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Network Flow(網路流)&lt;/strong&gt;：若現在有一個複雜的水管系統，水從入水口流入，經過許多互相連結、且孔徑不一的水管後，從出水口流出，目標是一次流入最大量的水。&lt;br /&gt;
其中可能遇到的問題如：由於水管的孔徑各不相同，若先流過一條半徑只有2公分的水管，則接在其後的水管的半徑即使再大，水流量仍會被半徑2公分的水管所限制，因此整體流量也就受限制。&lt;br /&gt;
如何分配水流在水管之間的流法，即是Network Flow要處理的問題。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過在介紹以上三項主題之前，下兩篇文章將先介紹在Graph中最基本的搜尋(Search)方法：Breadth-First Search(BFS，廣度優先搜尋)與Depth-First Search(DFS，深度優先搜尋)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hackerearth.com/notes/graph-theory-part-i/"&gt;Hacker Earth：Graph Theory - Part I &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://theoryofprogramming.com/2014/12/24/graph-theory-basics/"&gt;Theory of Programming：Graph Theory Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Tree_%28graph_theory%29"&gt;Wikipedia：Tree(graph theory)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Shortest_path_problem"&gt;Wikipedia：Shortest path problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.google.com.tw/maps/dir/%E7%8E%89%E5%B1%B1%E5%9C%8B%E5%AE%B6%E5%85%AC%E5%9C%92%E7%AE%A1%E7%90%86%E8%99%95+553%E5%8D%97%E6%8A%95%E7%B8%A3%E6%B0%B4%E9%87%8C%E9%84%89%E4%B8%AD%E5%B1%B1%E8%B7%AF%E4%B8%80%E6%AE%B5300%E8%99%9F/%E8%8A%B1%E8%93%AE%E7%B8%A3%E5%A4%AA%E9%AD%AF%E9%96%A3%E5%9C%8B%E5%AE%B6%E5%85%AC%E5%9C%92%E7%AE%A1%E7%90%86%E8%99%95/@23.9945162,121.0278493,10.35z/data=!4m13!4m12!1m5!1m1!1s0x34692ae27ea40fff:0xab9c90d0fc985ac5!2m2!1d120.8504096!2d23.8128448!1m5!1m1!1s0x34688286a79bc241:0x9c0222099dc32245!2m2!1d121.621627!2d24.158708?hl=zh-TW"&gt;Google Map：從玉山國家公園到太魯閣國家公園&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;Graph系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html"&gt;Minimum Spanning Tree：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treekruskals-algorithm.html"&gt;Minimum Spanning Tree：Kruskal's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm.html"&gt;Minimum Spanning Tree：Prim's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeprims-algorithm-using-min-priority-queue.html"&gt;Minimum Spanning Tree：Prim's Algorithm using Min-Priority Queue&lt;/a&gt;  &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html"&gt;Shortest Path：Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathbellman-ford-algorithm.html"&gt;Single-Source Shortest Path：Bellman-Ford Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathon-dagdirected-acyclic-graph.html"&gt;Single-Source Shortest Path：on DAG(directed acyclic graph)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html"&gt;Single-Source Shortest Path：Dijkstra's Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/all-pairs-shortest-pathfloyd-warshall-algorithm.html"&gt;All-Pairs Shortest Path：Floyd-Warshall Algorithm&lt;/a&gt;  &lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/flow-networksmaximum-flow-ford-fulkerson-algorithm.html"&gt;Flow Networks：Maximum Flow &amp;amp; Ford-Fulkerson Algorithm&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Intro"></category></entry><entry><title>Red Black Tree: Delete(刪除資料)與Fixup(修正)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html" rel="alternate"></link><updated>2016-01-30T14:11:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-30:SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;如同&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;，RBT之Delete(刪除資料)方法同樣是先沿用&lt;code&gt;DeleteBST()&lt;/code&gt;，再對顏色利用&lt;code&gt;Rotation&lt;/code&gt;進行修正。&lt;br /&gt;
建議讀者在閱讀本篇文章之前，先復習&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#delete"&gt;BST::DeleteBST(刪除資料)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;，會比較容易上手。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#violate"&gt;於RBT中Delete(刪除資料)可能違反RBT之特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bst"&gt;如同於BST中Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fixup"&gt;修正：DeleteFixUpRBT()&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#case1"&gt;Case1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case2"&gt;Case2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case3"&gt;Case3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case4"&gt;Case4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#example"&gt;範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;RBT系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="violate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;於RBT中Delete(刪除資料)可能違反RBT之特徵&lt;/h2&gt;
&lt;p&gt;在RBT中執行Delete(刪除資料)時，若刪除之node為黑色，有可能違反三點RBT特徵：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;圖一(a)：若要刪除的node恰好為&lt;code&gt;root&lt;/code&gt;，而刪除後恰好是紅色的node遞補成為新的&lt;code&gt;root&lt;/code&gt;，此時便違反RBT之第二點特徵：&lt;code&gt;root&lt;/code&gt;一定要是黑色；&lt;/li&gt;
&lt;li&gt;圖一(b)：若刪除node後，出現紅色與紅色node相連之情形，則違反RBT之第四點特徵：紅色node之&lt;code&gt;child&lt;/code&gt;一定要是黑色；&lt;/li&gt;
&lt;li&gt;圖一(b)：若刪除之node是黑色，則所有包含被刪除node的path上之黑色node數必定會減少，若恰好被刪除之node不是&lt;code&gt;root&lt;/code&gt;，將會違反RBT之第五點特徵：站在任何一個node上，所有從該node走到其任意descendant的path上之黑色node數必定相同。&lt;br /&gt;
圖一(b)左：從&lt;code&gt;root&lt;/code&gt;node(B)出發至任意leaves的path上都有三個黑色node(包含&lt;code&gt;NIL&lt;/code&gt;)；&lt;br /&gt;
圖一(b)右：刪除node(D)後，path(node(B)-node(E)-node(C))上之黑色node數剩下&lt;span class="math"&gt;\(2\)&lt;/span&gt;個(包含&lt;code&gt;NIL&lt;/code&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，需要對顏色進行修正，以滿足RBT特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="violate" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：違反RBT之第二點與第四點特徵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="violate" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：違反RBT之第四點與第五點特徵。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如同於BST中Delete(刪除資料)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RBT::DeleteRBT()&lt;/code&gt;之範例程式碼分成兩個部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一部分，如同&lt;code&gt;DeleteBST()&lt;/code&gt;，依照欲刪除之node的&lt;code&gt;child&lt;/code&gt;個數分成三種情形處理：&lt;ol&gt;
&lt;li&gt;先確認BST中有沒有要刪除的node；&lt;/li&gt;
&lt;li&gt;把要刪除的node調整成「至多只有一個&lt;code&gt;child&lt;/code&gt;」；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;child&lt;/code&gt;指向新的&lt;code&gt;parent&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;parent&lt;/code&gt;指向新的&lt;code&gt;child&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若實際上刪除的是「替身」，再把替身的資料放回BST中；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第二部分，若刪除的node是黑色，需要進行修正(Fix-Up)，引進函式：&lt;code&gt;DeleteFixedUpRBT()&lt;/code&gt;。 &lt;br /&gt;
&lt;/br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;              &lt;span class="c1"&gt;// 要刪除具有KEY的node&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;             &lt;span class="c1"&gt;// 先確認BST中是否有具有KEY的node&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;data not found.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 真正要被刪除並釋放記憶體的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 要被刪除的node的child&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                                           &lt;span class="c1"&gt;// 經過以上的if-else, y至多只有一個child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;// 將x設成y的child, 可能是實際資料, 也有可能是NIL&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 即使x是NIL也要把x的parent指向有效的記憶體位置&lt;/span&gt;
                                           &lt;span class="c1"&gt;// 因為在FixUp時需要藉由x-&amp;gt;parent判斷x為leftchild或是rightchild&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                 &lt;span class="c1"&gt;// 再將要被刪除的node之parent指向新的child&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 若實際上是「替身」被刪除, 要把「替身」的資料放回RBT中&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                   &lt;span class="c1"&gt;// 若刪除的node是黑色, 則要從x進行修正&lt;/span&gt;
        &lt;span class="n"&gt;DeleteFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="fixup"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;修正：DeleteFixUpRBT()&lt;/h2&gt;
&lt;p&gt;考慮在圖二之RBT中刪除node(B)，由於node(B)是黑色，必定違反RBT之特徵，因此需要修正。&lt;br /&gt;
(以下圖示中，白色的node表示顏色可能為黑色也可能為紅色，而且可能是一棵subtree或是&lt;code&gt;NIL&lt;/code&gt;，需視情況而定。)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="original" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據&lt;code&gt;sibling&lt;/code&gt;之顏色與&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;child&lt;/code&gt;之顏色，可以分為下列四種情形(Case)，如圖三：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Case1：&lt;code&gt;sibling&lt;/code&gt;為紅色；&lt;/li&gt;
&lt;li&gt;Case2：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的兩個&lt;code&gt;child&lt;/code&gt;都是黑色；&lt;/li&gt;
&lt;li&gt;Case3：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;是黑色；&lt;/li&gt;
&lt;li&gt;Case4：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;是紅色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="4cases" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DeleteFixUpRBT()&lt;/code&gt;的情形(Case)較為複雜，圖四是所有情形之循環圖：&lt;br /&gt;
(&lt;code&gt;current&lt;/code&gt;即是被刪除的node之&lt;code&gt;child&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;current&lt;/code&gt;是黑色的，而且&lt;code&gt;current&lt;/code&gt;不為&lt;code&gt;root&lt;/code&gt;，則依情況進入四個Case；&lt;/li&gt;
&lt;li&gt;若進入Case1，修正後，將進入Case2、Case3或Case4；&lt;/li&gt;
&lt;li&gt;若進入Case2，有可能修正後即符合RBT特徵，也有可能根據新的&lt;code&gt;current&lt;/code&gt;之情形重新判斷起；&lt;/li&gt;
&lt;li&gt;若進入Case3，修正後必定進入Case4；&lt;/li&gt;
&lt;li&gt;若進入Case4，修正後必定符合RBT之特徵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="flow" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case1&lt;/h3&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為紅色，修正方法如下，見圖五(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成黑色：node(E)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;塗成紅色：node(C)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;做Left Rotation：對node(C)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移動到&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移動至node(D)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在上述步驟中，並沒有更改&lt;code&gt;current&lt;/code&gt;之記憶體位置和顏色，&lt;code&gt;current&lt;/code&gt;仍為黑色。不過其&lt;code&gt;sibling&lt;/code&gt;必定會變成黑色，因此將進入Case2、Case3或Case4。&lt;/p&gt;
&lt;p&gt;為什麼Case1經過以上修正還沒有結束？原因要回到刪除node之前的RBT。&lt;br /&gt;
圖五(b)左，展示了刪除node之前，以node(C)為&lt;code&gt;root&lt;/code&gt;的RBT(或是更大的RBT之subtree)的其中一種可能情況。&lt;br /&gt;
從node(C)往任何一個descendant leaf的path上之黑色node數為&lt;span class="math"&gt;\(3\)&lt;/span&gt;，刪除node(B)後，使得其中一條path的黑色node數減少，經過上述方法之調整，仍然無法使得所有path之黑色node數相同，如圖五(b)右。&lt;br /&gt;
不過Case1所提出的修正方法能夠將情況調整成Case2、Case3或Case4，並且修正至滿足RBT之特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case2&lt;/h3&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之兩個&lt;code&gt;child&lt;/code&gt;皆為黑色，修正的方法如下，見圖五(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(E)塗成紅色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;currnet&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移至node(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(c)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過上述步驟，根據新的&lt;code&gt;current&lt;/code&gt;node(C)之顏色，可以分成兩種情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若node(C)為紅色，則跳出迴圈，把node(C)塗黑，即可滿足RBT之特徵，如圖五(d)，其邏輯便是：將從node(C)出發往&lt;code&gt;leftchild&lt;/code&gt;與&lt;code&gt;rightchild&lt;/code&gt;path的黑色數目調整成與刪除之前(Original)相同；&lt;/li&gt;
&lt;li&gt;若node(C)為黑色，且node(C)不是&lt;code&gt;root&lt;/code&gt;，則繼續下一輪迴圈，重新判斷其屬於四種情況之何者並修正，如圖五(e)，從node(G)出發至任意descendant leaf之path上的黑色node數並不完全相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(d)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(e)：圖中的「Original」僅代表其中一種可能的情形。此時的RBT還要繼續修正，見Case3。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case3"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case3&lt;/h3&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為黑色，修正的方法如下，見圖五(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;塗成黑色：node(D)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(E)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;sibling&lt;/code&gt;進行Right Rotation：對node(E)進行Right Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移至node(D)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(f)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過以上修正步驟，&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;成為紅色，便進入Case4。&lt;/p&gt;
&lt;p&gt;&lt;a name="case4"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case4&lt;/h3&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，修正的方法如下，見圖五(g)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：若node(C)是紅色，則將node(E)塗成紅色，若node(C)是黑色，則將node(E)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(C)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(F)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(C)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;br /&gt;
(注意：圖五(d)之node(E)未必是RBT之&lt;code&gt;root&lt;/code&gt;。)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(g)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如圖五(h)所示，Case4修正方法的邏輯便是：在刪除node(B)之後的RBT(或是subtree)中，將所有從&lt;code&gt;root&lt;/code&gt;位置(調整前是node(C)，調整後是node(E))出發往任意descendant leaf之path上的黑色數目調整成與刪除之前(Original)相同，因此，經過Case4的修正一定能夠滿足RBT之特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(h)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;範例&lt;/h3&gt;
&lt;p&gt;接著以一個簡單的範例(圖六(a)之RBT)操作上述四種Case的修正方法。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(a)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若考慮刪除node(19)，由於node(19)是黑色，需要修正。&lt;br /&gt;
接著判斷，node(19)的&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為黑色，且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為黑色，符合Case3的描述，因此利用Case3之修正方法，見圖六(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;塗成黑色：node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(27)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;sibling&lt;/code&gt;進行Right Rotation：對node(27)進行Right Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移至node(24)；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著進入Case4：&lt;code&gt;subling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，進行修正：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：node(22)是黑色，則將node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(22)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(27)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(22)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(b)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如此一來便再次滿足RBT之特徵限制，如圖六(c)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(c)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再考慮刪除黑色的node(45)，判斷：node(45)之&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為黑色，且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，符合Case4的描述，並利用Case4方法修正，見圖六(d)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：node(22)是黑色，則將node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(22)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(27)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(22)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(d)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如此一來便再次滿足RBT之特徵限制，如圖六(e)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(e)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著考慮刪除黑色的node(39)，判斷：node(45)之&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為紅色，符合Case1之描述，便利用Case1之方法，調整成Case4，見圖六(f)：&lt;/p&gt;
&lt;p&gt;Case1調整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成黑色：node(52)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;塗成紅色：node(41)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;做Left Rotation：對node(41)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移動到&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移動至node(48)；  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再利用Case4的方法修正，便能滿足RBT之特徵，見圖六(g)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(f)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(g)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若要刪除黑色的node(7)，由於其&lt;code&gt;child&lt;/code&gt;之&lt;code&gt;sibling&lt;/code&gt;為黑色，且具有兩個黑色的&lt;code&gt;child&lt;/code&gt;(都是&lt;code&gt;NIL&lt;/code&gt;)，符合Case2的情況，便修正如下，見圖六(h)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(10)塗成紅色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;currnet&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移至node(9)；&lt;/li&gt;
&lt;li&gt;若新的&lt;code&gt;current&lt;/code&gt;node(9)為紅色，即跳出迴圈，並將&lt;code&gt;current&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;經修正後，便符合RBT之特徵，見圖六(i)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(h)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(i)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後，若要刪除黑色的node(3)呢？由於node(3)的&lt;code&gt;child&lt;/code&gt;node(1)為紅色，並不需要考慮到Case1(&lt;code&gt;sibling&lt;/code&gt;為紅色)，只要將node(1)塗黑即可，如圖六(j)。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete23.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(j)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DeleteFixedUpRBT()&lt;/code&gt;之範例程式碼分成以下幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖四所示，修正的過程可能經歷不止一個Case，因此利用&lt;code&gt;while&lt;/code&gt;來實現，條件式為：&lt;code&gt;current&lt;/code&gt;不是&lt;code&gt;root&lt;/code&gt;，而且&lt;code&gt;current&lt;/code&gt;為黑色；&lt;/li&gt;
&lt;li&gt;若&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;，其&lt;code&gt;sibling&lt;/code&gt;就必須是&lt;code&gt;rightchild&lt;/code&gt;，反之亦然，而兩種情形之&lt;code&gt;Rotation&lt;/code&gt;修正之方向正好相反，因此，如同&lt;code&gt;InsertFixedUpRBT()&lt;/code&gt;，必須區分出「&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;」與「&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;」兩種情況；&lt;/li&gt;
&lt;li&gt;分別進行Case1、Case2、Case3與Case4之修正；&lt;/li&gt;
&lt;li&gt;最後，在line74的&lt;code&gt;current-&amp;gt;color = 1&lt;/code&gt;將&lt;code&gt;current&lt;/code&gt;之顏色塗黑，有可能在Case2用上，見圖五(d)與圖六(h)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// Case0:(i)  current是紅色的, 不影響黑色在path上的數量&lt;/span&gt;
    &lt;span class="c1"&gt;//       (ii) current是root,&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// current是leftchild&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// Case1: 如果sibling是紅色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 進入 Case2、3、4: sibling是黑色&lt;/span&gt;
            &lt;span class="c1"&gt;// Case2: sibling的兩個child都是黑色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// Case3 &amp;amp; 4:&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// case3: sibling的right child是黑的, 不管left child, 因為馬上會被塗黑&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 經過Case3後, 一定會變成Case4&lt;/span&gt;
                &lt;span class="c1"&gt;// Case 4: sibling的right child 是紅色的&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 只要進到Case4後, 一定跳出回圈&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// current是rightchild&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// Case1: 如果sibling是紅色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 進入 Case2、3、4: sibling是黑色&lt;/span&gt;
            &lt;span class="c1"&gt;// Case2: sibling的兩個child都是黑色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// Case3 &amp;amp; 4:&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// case3: sibling的left child是黑的, 不管right child, 因為馬上會被塗黑&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 經過Case3後, 一定會變成Case4&lt;/span&gt;
                &lt;span class="c1"&gt;// Case 4: sibling的right child 是紅色的&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 只要進到Case4後, 一定跳出回圈&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是於Red Black Tree(紅黑樹)中進行Delete(刪除資料)與Delete後的Fixup(修正)之介紹。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;RBT系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Insert(新增資料)與Fixup(修正)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html" rel="alternate"></link><updated>2016-01-27T20:09:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-27:SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項*&lt;/h3&gt;
&lt;p&gt;RBT也是一棵BST，而RBT之Insert(新增資料)方法便是先沿用&lt;code&gt;InsertBST()&lt;/code&gt;，再對顏色進行修正。而修正的方法將用上&lt;code&gt;Rotation()&lt;/code&gt;，因此，建議在閱讀本篇文章之前，先熟悉&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;會很有幫助。 &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bst"&gt;如同於BST中Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fixup"&gt;修正：InsertFixUpRBT()&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#case1"&gt;Case1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case3"&gt;Case3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case2"&gt;Case2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#example"&gt;幾個範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;RBT系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如同於BST中Insert(新增資料)&lt;/h2&gt;
&lt;p&gt;RBT也是一棵BST，在Insert(新增資料)時，必須滿足：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，因此，RBT的&lt;code&gt;InsertRBT()&lt;/code&gt;前半部演算法與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#insert"&gt;BST的函式：InsertBST()大同小異&lt;/a&gt;。&lt;br /&gt;
需要修改/擴充的部分有三處：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;NIL&lt;/code&gt;：所有原先在BST中指向&lt;code&gt;NULL&lt;/code&gt;的pointer，在RBT中需要修正成指向&lt;code&gt;NIL&lt;/code&gt;，包括條件式與新增node的&lt;code&gt;child pointer&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;顏色：如同在&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html#fail"&gt;RBT：Rotation(旋轉)&lt;/a&gt;所說，一般預設新增node為紅色，因此，若新增node接在黑色node之後，仍能滿足RBT的特徵，但是若新增node接在紅色node之後，則違反了&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html#rbt"&gt;RBT之第四點特徵&lt;/a&gt;，必須進行修正。&lt;/li&gt;
&lt;li&gt;引進函式：&lt;code&gt;InsertFixedUpRBT()&lt;/code&gt;進行修正。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;InsertRBT()&lt;/code&gt;的程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// 前半部與 InsertBST()之邏輯完全相同, 僅僅需要修改 NULL &amp;lt;-&amp;gt; NIL&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// default copy constructor&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     &lt;span class="c1"&gt;// 把root初始化成neel, 這裡就可以用neel來做判斷&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 以下是對RBT之node的設定, 將child pointer指向NIL, 顏色設為紅色&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 顏色可以在constructor中預設&lt;/span&gt;

    &lt;span class="n"&gt;InsertFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 對可能出現紅色與紅色node相連之情形做修正&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="fixup"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;修正：InsertFixUpRBT()&lt;/h2&gt;
&lt;p&gt;什麼情況需要對&lt;code&gt;InsertRBT()&lt;/code&gt;做修正？&lt;br /&gt;
當新增node接在紅色的node的&lt;code&gt;child pointer&lt;/code&gt;，形成紅色與紅色相連時。&lt;/p&gt;
&lt;p&gt;考慮以下情況，如圖一(a)，新增的node將要接在node(X)上：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node(X)為其&lt;code&gt;parent&lt;/code&gt;，顏色為紅色；&lt;/li&gt;
&lt;li&gt;node(Y)為其&lt;code&gt;uncle&lt;/code&gt;，其顏色&lt;strong&gt;可能為紅色或黑色&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;node(Z)為其grandparent(&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;)，顏色必定為黑色；&lt;/li&gt;
&lt;li&gt;node(W)的顏色&lt;strong&gt;可能是紅色或黑色&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;所有灰色node(如node(a)、node(b)、node(c)、node(d))表示：只要不影響RBT之特徵，是否實際攜帶資料或為&lt;code&gt;NIL&lt;/code&gt;並不影響結果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據&lt;code&gt;uncle&lt;/code&gt;的顏色是紅色或者黑色，可以將修正(FixUp)分成三種情形(case)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Case1：&lt;code&gt;uncle&lt;/code&gt;是紅色，不論新增的node是node(X)的&lt;code&gt;leftchild&lt;/code&gt;或&lt;code&gt;rightchild&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case2：&lt;code&gt;uncle&lt;/code&gt;是黑色，而且新增的node為node(X)的&lt;code&gt;rightchild&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case3：&lt;code&gt;uncle&lt;/code&gt;是黑色，而且新增的node為node(X)的&lt;code&gt;leftchild&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="case1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case1&lt;/h3&gt;
&lt;p&gt;圖一(b)左，此時&lt;code&gt;current&lt;/code&gt;指向新增的node(A)，而node(A)成為node(X)的&lt;code&gt;rightchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是紅色的。&lt;br /&gt;
修正的方法就是「把債還給上一代的上一代」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(X)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;uncle&lt;/code&gt;塗成黑色：node(Y)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(Z)塗成紅色：&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;從node(A)移到node(Z)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此時，如圖一(b)右，從node(Z)出發往其descendant leaves的任一path上之黑色node數皆相同，這個subtree便滿足了RBT的特徵。  &lt;/p&gt;
&lt;p&gt;接著必需根據node(W)的顏色採取不同行動：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若node(W)為黑色，就不需要再做調整；&lt;/li&gt;
&lt;li&gt;若node(W)為紅色，則node(Z)與node(W)再次形成紅色node與紅色node相連，必須重複同樣的判斷流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若node(A)成為node(X)的&lt;code&gt;leftchild&lt;/code&gt;，如圖一(c)，修正的方法同上。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case3"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case3&lt;/h3&gt;
&lt;p&gt;圖一(d)，新增的node(A)成為node(X)的&lt;code&gt;leftchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色。 &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;事實上，若&lt;code&gt;current&lt;/code&gt;指向之node(此為node(A))是新增的node，則根據RBT之第五點特徵，其&lt;code&gt;uncle&lt;/code&gt;node(Y)必定是&lt;code&gt;NIL&lt;/code&gt;，如圖一(e)左。&lt;/p&gt;
&lt;p&gt;不過，在稍後的範例中將會看到，&lt;code&gt;current&lt;/code&gt;不一定是「剛剛新增的node」，也有可能是「修正到一半，出現紅色與紅色相連的node」，但因為是「修正到一半」，尚未調整node(Z)的顏色，因此所有從node(Z)往其descendant leaves的任意path上之黑色node數必定不變，此時，若node(Y)不為&lt;code&gt;NIL&lt;/code&gt;，則node(X)以及node(A)必定還有黑色的&lt;code&gt;child pointer&lt;/code&gt;，如圖一(e)右所示，node(a)、node(b)與node(c)皆為黑色。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正方法如下，見圖一(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(X)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(Z)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;node(Z)進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過&lt;strong&gt;Case3&lt;/strong&gt;的修正，必定會滿足RBT之規則，原因在於：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先考慮圖一(e)，若從node(A)往其descendant leaves的任意path上之黑色node數為&lt;span class="math"&gt;\(M\)&lt;/span&gt;，則從node(Z)往其descendant leaves的任意path上之黑色node數為&lt;span class="math"&gt;\(M+1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;再看圖一(g)，因為在修正的過程中，node(Z)從黑色被修改成紅色，因此從node(Z)往其descendant leaves的任意path上之黑色node數下修為&lt;span class="math"&gt;\(M\)&lt;/span&gt;，與node(A)相同，使得整棵樹滿足RBT之特徵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(g)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case2&lt;/h3&gt;
&lt;p&gt;圖一(h)，新增的node(A)成為node(X)的&lt;code&gt;rightchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(h)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如同Case3，圖一(h)的&lt;code&gt;uncle&lt;/code&gt;node(Y)同樣有兩種可能：攜帶實際資料的黑色node，或者&lt;code&gt;NIL&lt;/code&gt;，如圖一(i)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(i)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;而修正Case2的方法就是將其轉換成Case3，再利用上述Case3的方法調整成正確的RBT。&lt;br /&gt;
從Case2調整成Case3，如圖一(j)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;：將&lt;code&gt;current&lt;/code&gt;從node(A)移到node(X)；&lt;/li&gt;
&lt;li&gt;對新的&lt;code&gt;current&lt;/code&gt;進行Left Rotation：對node(X)進行Left Rotation。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;圖一(j)右符合Case3：「&lt;code&gt;current&lt;/code&gt;成為其&lt;code&gt;parent&lt;/code&gt;的&lt;code&gt;leftchild&lt;/code&gt;，且其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色」，因此，只要再進行如同圖一(f)之修正流程即可。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(j)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;幾個範例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Example1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考慮一棵RBT如圖二(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想新增node(75)，由於其將接在node(80)的&lt;code&gt;leftchild&lt;/code&gt;位置上，而node(80)為紅色，因此需要進行修正。&lt;br /&gt;
接著觀察，node(75)之&lt;code&gt;uncle&lt;/code&gt;為node(60)，同樣是紅色，因此可以使用Case1的方法，如圖二(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;與&lt;code&gt;uncle&lt;/code&gt;塗黑：node(80)與node(60)塗黑；&lt;/li&gt;
&lt;li&gt;將grandparent塗紅：node(70)塗紅；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至node(70)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;進入下一個迴圈&lt;/strong&gt;判斷node(70)是否與其&lt;code&gt;parent&lt;/code&gt;形成紅色與紅色node相連。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恰好，node(50)為&lt;code&gt;root&lt;/code&gt;，一定是黑色，因此新增node(75)便算是完成。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想繼續新增node(25)，由於其將接在node(30)的&lt;code&gt;leftchild&lt;/code&gt;，而node(30)為紅色，因此需要修正。&lt;br /&gt;
接著觀察，node(25)之&lt;code&gt;uncle&lt;/code&gt;為&lt;code&gt;NIL&lt;/code&gt;是黑色，而node(25)本身是&lt;code&gt;leftchild&lt;/code&gt;，因此可以使用Case3的方法，如圖二(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(30)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(40)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;node(40)進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想繼續新增node(79)，由於其將接在node(75)的&lt;code&gt;rightchild&lt;/code&gt;，而node(75)為紅色，因此需要修正。&lt;br /&gt;
接著觀察，node(79)之&lt;code&gt;uncle&lt;/code&gt;為&lt;code&gt;NIL&lt;/code&gt;是黑色，而node(79)本身是&lt;code&gt;rightchild&lt;/code&gt;，因此可以使用Case2的方法，先將問題從Case2轉換成Case3，再由Case3之方法修正，如圖二(d)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考慮一棵RBT如圖三(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;要在其中新增node(4)，則會依序經歷case1、case2直到case3完成修正，如圖三(b)、圖三(c)、圖三(d)與圖三(e)所示。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據以上說明，可以歸納出對於&lt;code&gt;InsertRBT()&lt;/code&gt;的修正(Fix-Up)之情形(Case)間的循環圖，如圖四：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當新增node之&lt;code&gt;parent&lt;/code&gt;為紅色時，需要對RBT進行修正；&lt;/li&gt;
&lt;li&gt;若進入Case1，有可能執行一次即完成，也有可能再次出現紅色與紅色相連的情況，如圖三(b)-(c)；&lt;/li&gt;
&lt;li&gt;若進入Case2，就轉換成Case3的情境；&lt;/li&gt;
&lt;li&gt;一旦進入Case3，經過修正後必定能滿足RBT之特徵限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後還有一點需要說明。&lt;/p&gt;
&lt;p&gt;圖五中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左圖是本篇文章介紹修正(Fix-Up)的出發點：將新增的node接在node(X)上，而node(X)是node(Z)的&lt;code&gt;leftchild&lt;/code&gt;(&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;leftchild&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;還有另外一半的情況就如圖五之右圖：將新增的node接在node(Y)上，而node(Y)是node(Z)的&lt;code&gt;rightchild&lt;/code&gt;(&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;必須要區分這兩者的原因有二：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是&lt;code&gt;uncle&lt;/code&gt;：因為&lt;code&gt;parent&lt;/code&gt;與&lt;code&gt;uncle&lt;/code&gt;分別為&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;與&lt;code&gt;rightchild&lt;/code&gt;，若&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;left-&lt;/code&gt;，&lt;code&gt;uncle&lt;/code&gt;就要是&lt;code&gt;right-&lt;/code&gt;，反之亦然，兩者屬於互斥(exclusive)的、不能同時發生的情境；&lt;/li&gt;
&lt;li&gt;二是Rotation(旋轉)：在Case2與Case3中必須使用Left/Right Rotation，因此，延續第一點原因，考慮到&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;leftchild&lt;/code&gt;或是&lt;code&gt;rightchild&lt;/code&gt;的不同，Left/Right Rotation的方向也會相反。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;InsertFixedUpRBT()&lt;/code&gt;之範例程式碼分成以下幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義&lt;code&gt;color&lt;/code&gt;：0為紅色，1為黑色；&lt;/li&gt;
&lt;li&gt;如同圖四所示，修正的過程可能歷經不止一個Case，因此利用&lt;code&gt;while&lt;/code&gt;迴圈實現，條件式便是判斷當前&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;是否為紅色；&lt;/li&gt;
&lt;li&gt;分別進行Case1(圖一(b)與圖一(c))、Case2(圖一(j))與Case3(圖一(f))之修正；&lt;/li&gt;
&lt;li&gt;最後，在&lt;strong&gt;line50&lt;/strong&gt;出現一行&lt;code&gt;root-&amp;gt;color=1&lt;/code&gt;，將&lt;code&gt;root&lt;/code&gt;之顏色塗黑，這是為了Case1所設，由於Case1之修正方法是把「紅色與紅色node相連」之可能性往&lt;code&gt;root&lt;/code&gt;方向傳遞，有可能&lt;code&gt;root&lt;/code&gt;恰好是&lt;code&gt;current&lt;/code&gt;的grandparent而被塗成紅色，如圖六，但因為RBT之第二點特徵要求&lt;code&gt;root&lt;/code&gt;一定是黑色，因此必須作此預防。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// Case0: parent是黑色, 就不用進迴圈&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// 若parent是紅色即進入迴圈&lt;/span&gt;
        &lt;span class="c1"&gt;// 上半部：parent為grandparent的leftchild之情況，如圖五左&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是紅色：Case1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//grandparent改成紅色&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是黑色：Case2 or Case3&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;// 若current是rightchild：Case2  &lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;        
                    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 若current是leftchild：Case3&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// 下半部：parent為grandparent的rightchild之情況，如圖五右&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是紅色：Case1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//grandparent改成紅色&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是黑色：Case2 or Case3&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是於Red Black Tree(紅黑樹)中進行Insert(新增資料)與Insert後的Fixup(修正)之介紹。&lt;/p&gt;
&lt;p&gt;下一篇文章將介紹於Red Black Tree(紅黑樹)中進行Delete(刪除資料)與Delete後的Fixup(修正)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;RBT系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Rotation(旋轉)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html" rel="alternate"></link><updated>2016-01-24T23:06:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-24:SecondRound/red-black-tree-rotationxuan-zhuan.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;雖說是Rotation(旋轉)，但其實沒有這麼神奇，只是視覺上看起來像旋轉，在電腦實際將讀取的程式碼實現上，僅僅是數個pointer之指向的重新改寫，所以千萬別害怕。&lt;/p&gt;
&lt;p&gt;本篇文章的第一部分將以Insert(新增資料)與Delete(刪除資料)來說明為什麼需要Rotation(旋轉)，但是讀者可以先不必理會細節，因為實際上的Insert與Delete將有更多情況必須考慮，此部分將留待後續文章逐項說明，在本篇文章只要掌握Rotation(旋轉)即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#fail"&gt;於RBT中進行Insert與Delete後竟然不符合RBT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rotation"&gt;Rotation(旋轉)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#left-rotate"&gt;Left Rotation(向左轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#right-rotate"&gt;Right Rotation(向右轉)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;RBT系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="fail"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;於RBT中進行Insert與Delete後竟然不符合RBT&lt;/h2&gt;
&lt;p&gt;現考慮如圖一(a)之RBT，欲進行Insert(新增資料)與Delete(刪除資料)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：一棵符合規則的RBT。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;為滿足RBT之特徵第五點：從&lt;code&gt;root&lt;/code&gt;走向任何一個leaf node(&lt;code&gt;NIL&lt;/code&gt;)的任何一條path上之黑色node數皆相同，一般在RBT中Insert(新增資料)時，會先將欲新增的node塗成紅色。&lt;br /&gt;
若幸運地，新增的node接在黑色node上，則RBT仍然是一棵RBT，如圖一(b)，新增node(15)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：在RBT中新增node(15)，新增完後仍然滿足RBT之規則。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;但是，若要在RBT中新增node(31)，因為node(34)是紅色，此處便會出現紅色與紅色相連的情況，違反RBT之第四點特徵，因此需要修正，如圖一(c)。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：在RBT中新增node(31)，新增完後無法滿足RBT之規則。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正的方法便是將node(35)塗成紅色，node(34)塗成黑色，並且對&lt;strong&gt;node(35)&lt;/strong&gt;進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;，如此一來，RBT便能維持其基本特徵。&lt;br /&gt;
值得注意的是，在執行Rotation時，有時會順便調整RBT的height(樹高)，使得RBT維持在平衡(balanced)的狀態。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：使用&lt;/strong&gt;Rotation&lt;strong&gt;對Insert(新增資料)進行修正。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在正確新增node(31)後，若要刪除node(20)，因為node(20)是黑色，若將其刪除則違反RBT之第五點特徵：從&lt;code&gt;root&lt;/code&gt;走向任何一個leaf node(&lt;code&gt;NIL&lt;/code&gt;)的任何一條path上之黑色node數皆相同，因此同樣需要進行修正。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：因為node(20)是黑色，若將其刪除會違反RBT之第五點特徵。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正的方法則是將node(30)塗黑，node(34)塗紅，然後對&lt;strong&gt;node(34)&lt;/strong&gt;進行&lt;strong&gt;Left Rotation(向左旋轉)&lt;/strong&gt;，如此一來，RBT便能維持其基本特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：使用&lt;/strong&gt;Rotation&lt;strong&gt;對Delete(刪除資料)進行修正。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過以上說明，應該能體會到Rotation在修正Insert(新增資料)與Delete(刪除資料)時的威力，接著便來實地走訪Rotation實際上是哪些pointer在指來指去。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="rotation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Rotation(旋轉)&lt;/h2&gt;
&lt;p&gt;在說明Rotation(旋轉)之前有兩點需要先申明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若是要應用在BST上，則Rotation(旋轉)前後的BST必須要維持相同之Key排序。此處介紹的Rotation(旋轉)便屬於此類。&lt;/li&gt;
&lt;li&gt;Rotation(旋轉)與node是否具有顏色無關，即使是在一般的BST，亦能夠使用Rotation(旋轉)來調整height(樹高)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="left-rotate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Left Roration(向左旋轉)&lt;/h3&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;從圖二(a)中可以看出，要對以node(X)為&lt;code&gt;root&lt;/code&gt;之subtree進行Left Rotation，必須調整的pointer分別長在node(X)、node(Y)、node(A)與node(j)身上，其中node(j)有可能為&lt;code&gt;NIL&lt;/code&gt;，不過為求完整，在此將以node(j)不為&lt;code&gt;NIL&lt;/code&gt;作說明。&lt;br /&gt;
另外，node(i)與node(k)是否為&lt;code&gt;NIL&lt;/code&gt;皆不影響Left Rotation。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖二(b)將所有可能需要更動的pointer列出，其中，藍色箭頭表示由&lt;code&gt;parent pointer&lt;/code&gt;指向&lt;code&gt;child pointer&lt;/code&gt;，紅色箭頭則為&lt;code&gt;child pointer&lt;/code&gt;指向&lt;code&gt;parent pointer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Left Roration(向左旋轉)之步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Left Rotation完成後，node(Y)的&lt;code&gt;leftchild&lt;/code&gt;將會接上node(X)，因此要先把原先node(Y)的&lt;code&gt;leftchild&lt;/code&gt;(也就是node(j))放到node(X)的&lt;code&gt;rightchild&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;圖二(c)左：將node(X)的&lt;code&gt;rightchild&lt;/code&gt;指向node(j)；&lt;/li&gt;
&lt;li&gt;圖二(c)右：將node(j)的&lt;code&gt;parent&lt;/code&gt;指向node(X)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Left Rotation完成後，node(X)的&lt;code&gt;parent&lt;/code&gt;將會是node(Y)，而node(Y)的&lt;code&gt;parent&lt;/code&gt;要改成原先node(X)的&lt;code&gt;parent&lt;/code&gt;(也就是node(A))：&lt;ul&gt;
&lt;li&gt;圖二(d)左：將node(Y)的&lt;code&gt;parent&lt;/code&gt;指向node(A)。&lt;/li&gt;
&lt;li&gt;圖二(d)右：接著判斷，若原先node(X)是node(A)的&lt;code&gt;leftchild&lt;/code&gt;，那麼node(Y)同樣是node(A)的&lt;code&gt;leftchild&lt;/code&gt;，反之，node(Y)則成為node(A)的&lt;code&gt;rightchild&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最後，只要再把node(Y)的&lt;code&gt;rightchild&lt;/code&gt;指向node(X)，如圖二(e)左，並把node(X)的&lt;code&gt;parent&lt;/code&gt;接上node(Y)，如圖二(e)右，Left Rotation便完成了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後再看一次圖二(a)，若忽略node(A)，左圖中，其餘node之Key順序為&lt;span class="math"&gt;\(i&amp;lt;X&amp;lt;j&amp;lt;Y&amp;lt;k\)&lt;/span&gt;，而右圖中的順序亦為&lt;span class="math"&gt;\(i&amp;lt;X&amp;lt;j&amp;lt;Y&amp;lt;k\)&lt;/span&gt;，因此，如上所述的Left Rotation能夠應用在BST上。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Left Rotation之程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 把y設成x的rightchild&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 圖二(c)左&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 圖二(c)右, 若node(j)為NIL則忽略&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 圖二(d)左&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;// 圖二(d)右&lt;/span&gt;
        &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 圖二(e)左&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 圖二(e)右&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="right-rotate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Right Roration(向左旋轉)&lt;/h3&gt;
&lt;p&gt;Right Rotation的邏輯與Left Rotation完全相同，只要確實地把與node(X)、node(Y)、node(A)與node(j)有關的pointer重新指向正確的記憶體位置，就能夠完成Right Rotation。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Right Rotation之程式範例如下，把所有&lt;code&gt;LeftRotation()&lt;/code&gt;中的&lt;code&gt;left-&lt;/code&gt;與&lt;code&gt;right-&lt;/code&gt;對調就是了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 把x設成y的leftchild&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 把x的rightchild放到y的leftchild    &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;// 若x的rightchild不為NIL, 將其parent指向y&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 將x的parent指向原先y的parent&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 以下一組if-else將修改原先y的parent之child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;// 若y原先是root, x將成為新的root&lt;/span&gt;
        &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// 若原先y是其parent之leftchild, &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;//   x亦成為其新的parent之leftchild&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;                                 &lt;span class="c1"&gt;// 若原先y是其parent之rightchild, &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;//   x亦成為其新的parent之rightchild&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 將y設為x之rightchild&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 將x設為y之parent&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是Rotation(旋轉)的說明，在接下來介紹Insert(新增資料)與Delete(刪除資料)的兩篇文章中將會再次與各位相會。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;RBT系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html" rel="alternate"></link><updated>2016-01-23T16:09:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-23:SecondRound/red-black-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在閱讀過BST系列文章後可以發現，在BST中的操作，不論是Insert(新增資料)或是Delete(刪除資料)，皆需要先做Search(搜尋)，而Search(搜尋)的效率，取決於BST的height(樹高)，如果一棵樹越矮、越平衡(balanced)，則在此BST中搜尋資料的速度較快，理想狀況為Complete Binary Tree(時間複雜度：&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;)。反之，若由於輸入資料的順序使得BST沒長好、偏一邊，則在此BST中搜尋資料的最壞情況將有可能如同在Linked List做搜尋(時間複雜度：&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;)。  &lt;/p&gt;
&lt;p&gt;本篇文章將介紹BST的進階版Red Black Tree(RBT，紅黑樹)之基本性質，會說是進階版，原因在於RBT其實也是BST(滿足&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;)，不過RBT的node比BST多加了「顏色」(紅色或黑色)，而正因為多了「顏色」，便能修正BST有可能退化成Linked list(連結串列)的潛在缺陷。 &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="anarchy" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/biasedtree.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：不平衡的BST。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;另外，本篇文章將不進行「RBT之時間複雜度如何能視同Complete Binary Tree」之論證(筆者火侯不夠，請見諒)，建議讀者可以參考&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms，第13章&lt;/a&gt;，不過結論就是，RBT可以被視為如同Complete Binary Tree的BST，所有與Search(搜尋)有關的操作(Leftmost、Successor、Insert、Delete等等)，都能夠在&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;內完成。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#why"&gt;為什麼需要Red Black Tree？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rbt"&gt;Red Black Tree的特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;RBT系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="why"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;為什麼需要Red Black Tree？&lt;/h2&gt;
&lt;p&gt;若考慮最壞情況，在建立BST時，輸入資料的Key恰好被排序過(例如：1、2、3、4...)，那麼這顆BST便會退化成Linked List(接續前例，所有leftchild pointer都指向&lt;code&gt;NULL&lt;/code&gt;，只有rightchild child被使用)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 依序加入Key為1、2、3...之資料&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;圖二中，右側的藍色數字表示「搜尋該node需要比較(&lt;code&gt;if KEY == current-&amp;gt;key&lt;/code&gt;)的次數」，也就是迴圈的次數。考慮一串Linked List共有N個node，若要尋找第K個node，則最壞情況即是一路找到最後一個node，需要N次。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="linked list" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：BST退化成Linked List。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再比較Complete Binary Tree，如圖三。其中，node裡的數字即為Key，node旁邊的藍色數字代表該node在Complete Binary Tree中的位置順序，右側的藍色數字代表迴圈次數。&lt;br /&gt;
位置順序與迴圈次數有以下關係：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位置&lt;span class="math"&gt;\(2^3=8\)&lt;/span&gt;與&lt;span class="math"&gt;\(2^4=16\)&lt;/span&gt;之間的node(&lt;span class="math"&gt;\(2^3\leq i&amp;lt;2^4, i=8\sim 15\)&lt;/span&gt;)，只需要&lt;span class="math"&gt;\(3+1\)&lt;/span&gt;次比較(comparison)即可找到。&lt;/li&gt;
&lt;li&gt;依此類推，若BST中有N個node，則所有node保證能夠在&lt;span class="math"&gt;\(\lfloor {\log N} \rfloor +1\)&lt;/span&gt;次 (&lt;span class="math"&gt;\(2^k\leq N&amp;lt;2^{k+1}, k\leq\log N\)&lt;/span&gt;)迴圈以內找到。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：搜尋BST的理想情況：Complete Binary Tree。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上兩個範例為一棵具有N個node的BST之height(樹高)提供了邊界：&lt;span class="math"&gt;\(\log N\leq height\leq N\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因此，BST越平衡，在樹中搜尋資料的時間就越短，連帶地Insert(新增資料)、Delete(刪除資料)也會變得更有效率。&lt;br /&gt;
這就是RBT值得被介紹的原因。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="rbt"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Red Black Tree的特徵&lt;/h2&gt;
&lt;p&gt;Red Black Tree(RBT)是node塗了「顏色」的Binary Search Tree(BST)，藉由控制顏色，能夠保證在RBT中，&lt;strong&gt;最長path(路徑)不會超過最短path的兩倍&lt;/strong&gt;(若最短的path是5，最長的path至多只能是10)，如此，RBT便能夠近似地視為平衡，如圖四。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：最短的path為3(最右path:26-41-47)，其餘path最長只能是6(最左path:26-17-14-10-7-3)。&lt;br /&gt;
若蓋住&lt;code&gt;NIL&lt;/code&gt;與顏色，此即為BST。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖四中，所有原本在BST中指向&lt;code&gt;NULL&lt;/code&gt;的pointer，在RBT中，全部指向了&lt;code&gt;NIL&lt;/code&gt;。然而什麼是&lt;code&gt;NIL&lt;/code&gt;？&lt;code&gt;NIL&lt;/code&gt;是永遠為黑色、並且實際占有記憶體的node，因為有配置記憶體，因此能夠以&lt;code&gt;Node-&amp;gt;color&lt;/code&gt;的方式取得某個node之顏色(若使用&lt;code&gt;NULL&lt;/code&gt;則無法)，此優勢將在後續介紹如何於RBT中Insert(新增資料)與Delete(刪除資料)時派上用場。&lt;/p&gt;
&lt;p&gt;接著來看RBT的五項特徵：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RBT中的每一個node不是黑色就是紅色。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root&lt;/code&gt;一定是黑色。&lt;/li&gt;
&lt;li&gt;每一個leaf node(也就是&lt;code&gt;NIL&lt;/code&gt;)一定是黑色。&lt;/li&gt;
&lt;li&gt;如果某個node是紅色，那麼其兩個child必定是黑色，不能有兩個紅色node相連，如圖四中的node(17)、node(30)。&lt;br /&gt;
若某個node為黑色，其child之顏色沒有限制，如圖四中的node(38)、node(26)、node(21)。&lt;/li&gt;
&lt;li&gt;站在任何一個node上，所有從該node走到其任意descendant的path上之黑色node數必定相同。&lt;br /&gt;
以圖四為例，站在node(14)上，所有從node(14)走向其descendant leaves(也就是&lt;code&gt;NIL&lt;/code&gt;)的path上之黑色node數必為3： &lt;ul&gt;
&lt;li&gt;path1:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-7(&lt;strong&gt;b&lt;/strong&gt;)-3(r)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path2:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-7(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path3:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-12(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path4:14(&lt;strong&gt;b&lt;/strong&gt;)-16(&lt;strong&gt;b&lt;/strong&gt;)-15(r)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path5:14(&lt;strong&gt;b&lt;/strong&gt;)-16(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根據上述特徵的第四點與第五點，RBT中path可能的長度最小值一定是全部node皆為黑色，而path可能的長度最大值並定是紅色-黑色相間(如圖四)，如此便確保RBT擁有&lt;strong&gt;最長path(路徑)不會超過最短path的兩倍&lt;/strong&gt;的特性。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;實際的程式實現上，會把所有&lt;code&gt;NIL&lt;/code&gt;視為同一個&lt;code&gt;NIL&lt;/code&gt;，並把&lt;code&gt;root&lt;/code&gt;的parent指向&lt;code&gt;NIL&lt;/code&gt;，以節省記憶體空間，如圖五。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class RBT&lt;/code&gt;之資料成員(data member)程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 0: Red,  1: Black&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 此即為NIL, 常被稱為sentinel&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(為了避開某些IDE將&lt;code&gt;NIL&lt;/code&gt;設定成保留關鍵字(reserved keywords，例如&lt;code&gt;template&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;struct&lt;/code&gt;等等)，因此使用&lt;code&gt;neel&lt;/code&gt;。)&lt;/p&gt;
&lt;p&gt;為求畫面簡潔，往後的篇幅裡將把RBT示意圖中的&lt;code&gt;NIL&lt;/code&gt;隱藏起來，只顯示RBT中的internal node，如圖六，不過心裡要記得，RBT無時無刻都被&lt;code&gt;NIL&lt;/code&gt;充滿著。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上便是RBT之初探，最重要的結論為：就時間複雜度而言，RBT能夠被視為平衡的BST，所有操作皆能在時間複雜度為&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;內完成。&lt;/p&gt;
&lt;p&gt;在接下來的三篇文章中，將依序介紹Rotation(旋轉)、Insert(新增資料)與Delete(刪除資料)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;RBT系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category><category term="Intro"></category></entry><entry><title>Binary Search Tree: Sort(排序)、Delete(刪除資料)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html" rel="alternate"></link><updated>2016-01-15T21:27:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-15:SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;由於Sort與Delete會用到先前在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#in_parent"&gt;Binary Tree：Traversal介紹過的Leftmost()、Rightmost()、Successor()與Predecessor()&lt;/a&gt;，因此建議在開始閱讀本篇文章之前，先復習上述四個函式操作。  &lt;/p&gt;
&lt;p&gt;在文章最後將會附上四個函式的範例程式碼。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sort"&gt;Sort(排序)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delete"&gt;BST::DeleteBST(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#main"&gt;main()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4function"&gt;Leftmost、Rightmost、Successor、Predecessor範例程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;BST系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="sort"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Sort(排序)&lt;/h2&gt;
&lt;p&gt;讀者可能會發現，在&lt;code&gt;class BST&lt;/code&gt;的定義中，根本就沒有類似&lt;code&gt;SortBST()&lt;/code&gt;的函式，沒錯，因為在BST中，每一個&lt;code&gt;Treenode&lt;/code&gt;都有&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;的性質，這正好與Inorder(LVR)之順序相同，因此，對整棵樹進行Inorder Traversal，就能夠對資料由小到大(依照Key)進行Visiting。&lt;/p&gt;
&lt;p&gt;以上一篇&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao"&gt;Binary Search Tree: Search()、Insert()&lt;/a&gt;的&lt;code&gt;main()&lt;/code&gt;所建立的BST為例，如圖一，要將此樹中的資料按照Key之順序由小到大印出，只需要對整棵樹做一次Inorder Traversal即可。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以下範例程式，將Visiting用作列印資料(print)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// Visiting&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 移動至current的Successor&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;克林&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;龜仙人&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;比克&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;悟空&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="delete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;BST::DeleteBST(刪除資料)&lt;/h2&gt;
&lt;p&gt;要在BST上執行刪除資料(被刪除的node稱為A)，必須讓刪除A後的BST仍然維持BST的性質，因此，所有「具有指向A的pointer」之node(也就是A的&lt;code&gt;parent&lt;/code&gt;、A的&lt;code&gt;leftchild&lt;/code&gt;與A的&lt;code&gt;rightchild&lt;/code&gt;)都必須指向新的記憶體位置。&lt;/p&gt;
&lt;p&gt;刪除資料的工作，根據欲刪除之node「有幾個child pointer」分成三類：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Case1：欲刪除之node沒有&lt;code&gt;child pointer&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case2：欲刪除之node只有一個&lt;code&gt;child pointer&lt;/code&gt;(不論是&lt;code&gt;leftchild&lt;/code&gt;或&lt;code&gt;rightchild&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;Case3：欲刪除之node有兩個&lt;code&gt;child pointer&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以圖二(a)為例，依序刪除撒旦、弗力札與西魯：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case1&lt;/strong&gt;：由於撒旦沒有&lt;code&gt;child pointer&lt;/code&gt;，因此只要考慮撒旦的parent(普烏)，將普烏的&lt;code&gt;leftchild&lt;/code&gt;指向&lt;code&gt;NULL&lt;/code&gt;即可維持BST的正確性，如圖二(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case2&lt;/strong&gt;：由於弗力札有一個&lt;code&gt;leftchild&lt;/code&gt;(基紐)，因此在刪除弗力札之前，需要先將基紐的parent指向弗力札的&lt;code&gt;parent&lt;/code&gt;(龜仙人)，並且將龜仙人的&lt;code&gt;rightchild&lt;/code&gt;從原本的弗力札指向基紐，因為基紐原本就位於龜仙人的right subtree(右子樹)，因此，上述操作仍能維持BST的正確性，如圖二(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Case3&lt;/strong&gt;：由於西魯有兩個&lt;code&gt;child&lt;/code&gt;，若直接刪除西魯的資料，並釋放其記憶體位置，要牽動的node較多。變通的祕訣就是「找替身」，原本要刪西魯，但是實際上是釋放西魯的「Successor(達爾)」的記憶體位置(或是「Predecessor(16號)」)，最後再把「Successor(達爾)」(或是「Predecessor(16號)」)的資料放回到西魯的記憶體位置上，又因為BST的特徵，所有「具有兩個&lt;code&gt;child&lt;/code&gt;」的node的Successor或是Predecessor一定是leaf node或是只有一個&lt;code&gt;child&lt;/code&gt;，如此，便回到如同撒旦與弗力札「至多只有一個&lt;code&gt;child&lt;/code&gt;」的情境。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驗證「具有兩個&lt;code&gt;child&lt;/code&gt;的node的Successor或是Predecessor一定是leaf node或是只有一個&lt;code&gt;child&lt;/code&gt;」：若某個node有兩個&lt;code&gt;child&lt;/code&gt;，則Successor找的是「right subtree中Key最小的node」，而Predecessor找的是「left subtree中Key最大的node」，因此Successor和Predecessor必定不會同時也有兩個child。以圖二(d)為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;龜仙人(8)的Predecessor為克林(2)，Successor為基紐(69)；&lt;/li&gt;
&lt;li&gt;比克(513)的Predecessor為基紐(69)，Successor為16號(520)；&lt;/li&gt;
&lt;li&gt;悟飯(888)的Predecessor為達爾(881)，Successor為普烏(999)；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;現欲刪除西魯，就去找西魯的Successor(達爾)當做替身，因為達爾沒有&lt;code&gt;child&lt;/code&gt;，其刪除方法便如同上述刪除撒旦的方法，如圖二(e)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最後再將達爾的資料放進原先存放西魯資料的記憶體位置，便完成了刪除西魯的操作，如圖二(f)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BST::DeleteBST()&lt;/code&gt;之範例程式碼分成以下幾個步驟：：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先確認BST中有沒有要刪除的node；&lt;/li&gt;
&lt;li&gt;把要刪除的node調整成「至多只有一個&lt;code&gt;child&lt;/code&gt;」；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;child&lt;/code&gt;指向新的&lt;code&gt;parent&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;parent&lt;/code&gt;指向新的&lt;code&gt;child&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若實際上刪除的是「替身」，再把替身的資料放回BST中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即完成BST之刪除資料操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;               &lt;span class="c1"&gt;// 要刪除具有KEY的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              &lt;span class="c1"&gt;// 先確認BST中是否有具有KEY的node&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;data not found.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 真正要被刪除並釋放記憶體的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 要被刪除的node的child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                                            &lt;span class="c1"&gt;// 經過以上的if-else, y至多只有一個child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;// 將x設成y的child, 可能是有效記憶體, 也有可能是NULL&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                          
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 此即為圖二(c)中, 基紐指向龜仙人的實作方式&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                  &lt;span class="c1"&gt;// 再將要被刪除的node之parent指向新的child&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                 &lt;span class="c1"&gt;// y即是達爾, delete_node即是西魯&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;   &lt;span class="c1"&gt;// 實際被刪除的是y, 因此最後要再將y的資料放進delete_node的記憶體位置&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="main"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;main()&lt;/h2&gt;
&lt;p&gt;延續上一篇文章&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao"&gt;Binary Search Tree: Search()、Insert()&lt;/a&gt;的&lt;code&gt;main()&lt;/code&gt;，加入&lt;code&gt;BST::DeleteBST&lt;/code&gt;，把龜仙人(8)刪除，應該會得到如圖三的BST，比克(513)成為新的&lt;code&gt;root&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;龜仙人&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;悟空&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;克林&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;比克&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 刪除龜仙人&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;克林&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;比克&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;悟空&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="4function"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Leftmost、Rightmost、Successor、Predecessor範例程式碼&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是BST中&lt;code&gt;BST::DeleteBST()&lt;/code&gt;之介紹，關鍵即在Successor與Predecessor。  &lt;/p&gt;
&lt;p&gt;在接下來將介紹的Red Black Tree(RBT，紅黑樹)中，BST的&lt;code&gt;Insert()&lt;/code&gt;與&lt;code&gt;Delete()&lt;/code&gt;會再次出現，不過，需要再「多一道手續」以滿足RBT的性質。&lt;/p&gt;
&lt;p&gt;最後，因為RBT的圖比較複雜，所以圈圈裏面放名字會太擠，有礙觀瞻，因此要忍痛讓「悟空」、「克林」退居幕後，直接在node裡面放上Key。 
不過，相信透過這三篇BST的介紹，讀者對七龍珠也有一定程度的了解，後面的部分一定可以靠自學來搜集龍珠了。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch12&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;BST系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category></entry><entry><title>Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html" rel="alternate"></link><updated>2016-01-03T20:17:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-03:SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在開始介紹search(搜尋資料)與insert(新增資料)之前，先定義好&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class BST&lt;/code&gt;，順便對未來將介紹的其他member function(成員函式)留下美好的第一印象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// constructor&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// default copy constructor&lt;/span&gt;
    &lt;span class="c1"&gt;// default destructor&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;   

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 放在 private 或 public 都可以 &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// class BST&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;origNode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// preorder traversal, 用在 copy constructor和 operator=&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PostorderDelete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;     &lt;span class="c1"&gt;// default constructor&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// copy constructor&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// destructor&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;    &lt;span class="c1"&gt;// 確認BST是否存有資料&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文章內容將著重於BST這個資料結構，並提供此資料結構中可行的演算法，因此，有關C++的實作方法並不唯一，筆者相信有更優秀的寫法(有效利用記憶體、避免memory leak(記憶體洩漏)等議題)，建議讀者可以多多參考例如&lt;a href="http://codereview.stackexchange.com/"&gt;Stack Exchange:Code Review&lt;/a&gt;等等眾多優秀的網站，看網友的程式碼的寫法以及由該份程式碼所開啟的討論串，應該會對實際寫作技巧有些幫助。&lt;br /&gt;
(筆者也還在學啊啊啊啊)&lt;/p&gt;
&lt;p&gt;另外，用以測試的&lt;code&gt;main()&lt;/code&gt;將在BST系列的演算法都介紹完後登場。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#search"&gt;BST::Search(搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#insert"&gt;BST::InsertBST(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#main"&gt;main()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;BST系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="search"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;BST::Search(搜尋)&lt;/h2&gt;
&lt;p&gt;BST的&lt;code&gt;Search()&lt;/code&gt;操作，便是根據BST的特徵：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，判斷&lt;code&gt;Current&lt;/code&gt;node應該往left subtree走，還是往right subtree走。&lt;/p&gt;
&lt;p&gt;現有一棵BST如圖一(a)所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;搜尋結果可能成功，可能失敗，以下便分別以兩個KEY值作說明。&lt;/p&gt;
&lt;h3&gt;搜尋成功&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;若現在要從BST中搜尋基紐隊長，便以基紐隊長的KEY(627)進入BST。&lt;br /&gt;
進入BST後，便把用來移動的&lt;code&gt;Current&lt;/code&gt;node指向&lt;code&gt;root&lt;/code&gt;，如圖一(b)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時，便將KEY(627)和比克(&lt;code&gt;root&lt;/code&gt;)的戰鬥力(513)比較，結果是基紐隊長戰勝，因此，基紐隊長如果在BST裡面，應該會長在比克的right subtree，於是便將&lt;code&gt;Current&lt;/code&gt;往比克的right child(達爾)移動，如圖一(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動到達爾之後，再將KEY(627)與達爾的戰鬥力(524)比較，結果仍然是基紐隊長大勝，因此步驟同上，繼續將&lt;code&gt;Current&lt;/code&gt;往達爾的right child(弗力札)移動，如圖一(d)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動到弗力札之後，再將KEY(627)與弗力札的戰鬥力(709)比較，結果是弗力札略勝，於是便往弗力札的left child尋找基紐隊長，如圖一(e)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時，&lt;code&gt;Current&lt;/code&gt;的Key(627)與傳送進&lt;code&gt;Search()&lt;/code&gt;的KEY(627)相同，便確認&lt;code&gt;Current&lt;/code&gt;即為基紐隊長，於是跳出&lt;code&gt;while&lt;/code&gt;迴圈，並傳回&lt;code&gt;Current&lt;/code&gt;。&lt;br /&gt;
即搜尋成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;搜尋失敗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;若現在要從BST中尋找克林，便以克林的戰鬥力(2)為KEY(2)，進入&lt;code&gt;Search()&lt;/code&gt;。&lt;br /&gt;
進入BST後，同樣把用來移動的&lt;code&gt;Current&lt;/code&gt;node指向&lt;code&gt;root&lt;/code&gt;，如圖一(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接著便將KEY(2)和比克的戰鬥力(513)比較，結果是比克勝出，於是將&lt;code&gt;Currnet&lt;/code&gt;往比克的left child(龜仙人)移動，如圖一(f)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f23.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動至龜仙人後，將KEY(2)和龜仙人的戰鬥力(8)比較，便判斷出，要將&lt;code&gt;Current&lt;/code&gt;往龜仙人的left child移動，如圖一(f)。&lt;br /&gt;
然而，由於龜仙人沒有left child，於是&lt;code&gt;Current&lt;/code&gt;指向&lt;code&gt;NULL&lt;/code&gt;，便跳出迴圈，並回傳&lt;code&gt;NULL&lt;/code&gt;，即表示搜尋失敗，克林不在BST中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是&lt;code&gt;BST::Search()&lt;/code&gt;的範例程式碼，其中，有兩種情況會跳出&lt;code&gt;while&lt;/code&gt;迴圈：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;KEY與&lt;code&gt;Current&lt;/code&gt;node的key相同，表示搜尋成功；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Current&lt;/code&gt;移動到&lt;code&gt;NULL&lt;/code&gt;，表示搜尋失敗。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 向左走&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 向右走&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="insert"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;BST::InsertBST(新增資料)&lt;/h2&gt;
&lt;p&gt;函式&lt;code&gt;InsertBST()&lt;/code&gt;的演算法概念，可以視為&lt;code&gt;Search()&lt;/code&gt;的延伸：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根據BST對Key之規則，先找到「將要新增之node」適合的位置；&lt;/li&gt;
&lt;li&gt;再將欲新增的node接上BST。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要尋找「對新增node而言的適當位置」，需要召喚一位「哨兵」先行探路，而「將會成為新增node的&lt;strong&gt;parent node&lt;/strong&gt;(準新手爸媽)」則跟著「哨兵」的腳步，往前推進。 &lt;/p&gt;
&lt;p&gt;定義「哨兵」為&lt;strong&gt;x&lt;/strong&gt;，「準新手爸媽」為&lt;strong&gt;y&lt;/strong&gt;，現欲新增「比克，戰鬥力(513)」進入如圖二(a)之BST。&lt;br /&gt;
(這裡的「哨兵&lt;strong&gt;x&lt;/strong&gt;」具有&lt;code&gt;BST::Search()&lt;/code&gt;中&lt;code&gt;Current&lt;/code&gt;node的功能。)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f24.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖二(a)，剛進入BST時，「哨兵&lt;strong&gt;x&lt;/strong&gt;」進到&lt;code&gt;root&lt;/code&gt;，而「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」即為&lt;code&gt;root&lt;/code&gt;的parent，即為&lt;code&gt;NULL&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;接著，將欲新增node之Key(比克(513))與「哨兵&lt;strong&gt;x&lt;/strong&gt;」之Key(龜仙人(8))相比，比克的戰鬥力比龜仙人高，所以比克應該要長在龜仙人的right subtree，因此把「哨兵&lt;strong&gt;x&lt;/strong&gt;」往龜仙人的right child(悟空)移動，並且更新「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」為龜仙人，如圖二(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f25.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接著，繼續比較欲新增node之Key(比克(513))與「哨兵&lt;strong&gt;x&lt;/strong&gt;」之Key(悟空(1000))，結果是悟空的戰鬥力較高，比克應該要長在悟空的left subtree，因此，將「哨兵&lt;strong&gt;x&lt;/strong&gt;」往悟空的left child(&lt;code&gt;NULL&lt;/code&gt;)移動，同時更新「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」為悟空，如圖二(c)。&lt;/li&gt;
&lt;li&gt;更新後，「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」成為悟空，「哨兵&lt;strong&gt;x&lt;/strong&gt;」指向&lt;code&gt;NULL&lt;/code&gt;壯烈犧牲，即達到跳出迴圈之條件。此時，便找到了「新增node」之適當位置。&lt;br /&gt;
那個「適當位置」在哪裡呢？就是「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的child pointer。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f26.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下一步，便是比較欲新增node之Key(比克(513))與「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」之Key(悟空(1000))，發現悟空戰鬥力較高，因此，比克(513)便成為「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的left child，如圖二(d)，便成功把比克(513)接到BST上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f27.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;BST::InsertBST()&lt;/code&gt;的範例程式碼，關鍵便是「哨兵&lt;strong&gt;x&lt;/strong&gt;」與「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的冒險之旅：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 準新手爸媽&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 哨兵&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// call default copy constructor of TreeNode&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 在while中, 以如同Search()的方式尋找適當的位置       &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;                                  &lt;span class="c1"&gt;// 跳出迴圈後, x即為NULL&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// y即為insert_node的parent&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                     &lt;span class="c1"&gt;// 下面一組if-else, 把insert_node接上BST&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;備註：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在定義函式&lt;code&gt;InsertBST()&lt;/code&gt;時，函式的參數(argument)可能會視情境而有所改變，這裡是以一個&lt;code&gt;TreeNode&lt;/code&gt;的物件(object)之&lt;strong&gt;reference&lt;/strong&gt;作為參數，傳進函式&lt;code&gt;InsertBST()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;InsertBST()&lt;/code&gt;特別標示出BST是為了與之後會介紹的Red Black Tree(紅黑樹)之&lt;code&gt;InsertRBT()&lt;/code&gt;做區別。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="main"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;main()&lt;/h2&gt;
&lt;p&gt;有了&lt;code&gt;BST::InsertBST()&lt;/code&gt;後，就可以用土法煉鋼的方式建立一棵如圖二(d)的BST:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;龜仙人&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;悟空&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;克林&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;比克&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上便是BST中&lt;code&gt;Search()&lt;/code&gt;與&lt;code&gt;InsertBST()&lt;/code&gt;之介紹，只要掌握BST的性質&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;與樹中的Traversal(pointer的移動)即可輕鬆上路。 &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch12&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;BST系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category></entry><entry><title>Binary Search Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html" rel="alternate"></link><updated>2016-01-02T12:15:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-02:SecondRound/binary-search-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;先前的文章介紹過廣義的Tree(樹)、Binary Tree(二元樹)，這篇文章將繼續增加限制條件，使Binary Tree晉升成Binary Search Tree(BST，二元搜尋樹)。  &lt;/p&gt;
&lt;p&gt;這裡要處理的資料是日本漫畫的曠世鉅作《七龍珠》中各角色的戰鬥力。&lt;br /&gt;
七龍珠的劇情(正篇有七龍珠、七龍珠Z、七龍珠改、七龍珠GT、七龍珠超，劇場版還有&lt;a href="https://zh.wikipedia.org/wiki/%E4%B8%83%E9%BE%99%E7%8F%A0#.E5.8A.87.E5.A0.B4.E7.89.88"&gt;七龍珠劇場版(太多了請參閱維基百科)&lt;/a&gt;)時而前後連貫，時而交錯，為了維持每個系列之間的角色設定，就需要對角色的戰鬥力進行管理，避免劇情不合邏輯變成鬧劇，在此，筆者推薦鳥山明老師可以使用先進如BST的資料結構來整理角色的資料(當然，也是可以用excel或是國小生字簿，&lt;a href="http://www.imdb.com/title/tt1178663/"&gt;Whatever Works&lt;/a&gt;)。  &lt;/p&gt;
&lt;p&gt;熱血沸騰了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#dictionary"&gt;引入Dictionary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bst"&gt;Binary Search Tree的特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#operation"&gt;在Binary Search Tree中管理資料&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#insert"&gt;insert(新增資料)&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#search"&gt;search(搜尋資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sort"&gt;sort(排序)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delete"&gt;delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;BST系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dictionary"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;引入Dictionary&lt;/h2&gt;
&lt;p&gt;搜尋與排序都需要「比大小」，欲執行「比大小」，就要使用「能夠比大小」的資料形態(亦即：兩個比較之物只能唯一滿足於「大於」、「小於」或「等於」之關係)，最直觀的便是使用整數(integer)。  &lt;/p&gt;
&lt;p&gt;在先前的文章中，&lt;code&gt;class TreeNode&lt;/code&gt;包含了指向child的pointer、指向parent的pointer，以及一個&lt;code&gt;char data&lt;/code&gt;來儲存字母。  &lt;/p&gt;
&lt;p&gt;而更多時候，node所攜帶的資料項目(在此為&lt;code&gt;char data&lt;/code&gt;)可能更複雜，也許是一個姓名、一組帳戶資料、一本照片集、一組科學資料等等，然而，要使用這些資料進行「比大小」必須而外自行定義規則，例如：「姓氏照字母順序排序，字母越前面值越大；若第一個字相同，則依序往下比較；若姓名中所有字母之順序皆相同則...」，非常不實際，因此，不用再則了，變通的方法便是直接在資料上加上「編號」(也可以想成，把資料對應(mapping)到特定編號)，以編號做排序，並且能夠以特定編號搜尋其所對應之資料項目，即可避開上述麻煩。  &lt;/p&gt;
&lt;p&gt;如此概念便是&lt;strong&gt;Dictionary&lt;/strong&gt;，稱上述的「編號」為「Key(鍵值)」，稱「資料項目」為「Element(元素)」，則稱一組「Key-Element pairs」的集合為&lt;strong&gt;Dictionary&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;如圖一所示，若將先前的字母視為「Element」並加上「Key」，則(Key, Element)可以表示成(編號, A)，若處理學生資料，將編號視為學號，資料視為姓名，則能夠將(Key, Element)可以表示成(學號, 姓名)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dictionary1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在接下來的篇幅裡，將使用七龍珠的角色(悟空)作為Element，角色的戰鬥力視為Key：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dictionary2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正後的&lt;code&gt;class TreeNode&lt;/code&gt;可能長這樣： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// Element&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Key, used for comparison &lt;/span&gt;
     &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;備註： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dictionary的概念也出現在&lt;a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html"&gt;Hash Table&lt;/a&gt;、C/C++標準函式庫(Standard Library)中的&lt;strong&gt;container&lt;/strong&gt;:&lt;code&gt;map&lt;/code&gt;等等，有非常多應用。&lt;/li&gt;
&lt;li&gt;以下角色戰鬥力的絕對值是捏造的，不過相對值盡力維持正確(除了撒旦)，若有疑問，歡迎龍珠粉來信討論。 &lt;/li&gt;
&lt;li&gt;由於故事的角色眾多，以下將挑選具代表性之角色用來說明BST。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Binary Search Tree的特徵&lt;/h2&gt;
&lt;p&gt;有了加裝Dictionary後的&lt;code&gt;TreeNode&lt;/code&gt;，便能夠說明BST的特徵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何CurrnetNode之Key若與其left child、right child之Key有以下關係(若pointer指向&lt;code&gt;NULL&lt;/code&gt;則忽略)：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，則可稱這棵樹為Binary Search Tree(BST)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖三為例，樹中有三個node，悟空的戰鬥力為1000，龜仙人的戰鬥力為8，克林的戰鬥力為2，若將龜仙人設為&lt;code&gt;root&lt;/code&gt;，則克林的戰鬥力較小，因此成為龜仙人的left child，悟空的戰鬥力較大，便成為龜仙人的right child，如此便滿足&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，即可稱圖三為一棵BST。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;有了BST後，便能夠替鳥山明老師處理角色之間的戰鬥力關係了。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="operation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;在Binary Search Tree中管理資料&lt;/h2&gt;
&lt;p&gt;故事一開始的主要角色有悟空(1000)、龜仙人(8)和克林(2)，以龜仙人為&lt;code&gt;root&lt;/code&gt;能夠建立出一棵BST如圖四：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="insert"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;insert(新增資料)&lt;/h3&gt;
&lt;p&gt;隨著故事劇情推進，角色也會跟著增加，因此，要在BST中&lt;strong&gt;新增node(新增資料)&lt;/strong&gt;。&lt;br /&gt;
在此，比克大魔王現身地球危害人間，其戰鬥力為513，欲將其放進BST，根據BST的規則判斷出，比克的戰鬥力比龜仙人高，因此要將比克放在龜仙人的right subtree(右子樹)；接著，再和悟空比較，比克的戰鬥力比悟空低，因此將比克建立在悟空的left child上，如圖五(a)所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insert" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，賽亞人王子達爾登場，其戰鬥力為524，根據BST的規則，判斷出其應在「龜仙人的right subtree」、「悟空的left subtree」與比克的「right child」，如圖五(b)所示。&lt;br /&gt;
在下一篇文章將會看到，實際上的演算法正是以這種方式實現：移動&lt;code&gt;CurrentNode&lt;/code&gt;，並將&lt;code&gt;CurrentNode&lt;/code&gt;之Key與「欲新增之node的Key」比較，找到符合BST規則的位置後，置入新的node。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insert" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="search"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;search(搜尋資料)&lt;/h3&gt;
&lt;p&gt;在處理資料時，時常需要尋找某特定資料，是否存在資料結構中。以BST處理資料，最簡單的方式便是用Key尋找。&lt;br /&gt;
以圖六為例，故事推進到納美克星弗力札大王篇，若想要確認基紐隊長的資料是否已經建立完成，只要記住隊長的戰鬥力為「627」，進入BST中，便能夠找到隊長，必且回傳(return)隊長的node。&lt;br /&gt;
有時會出現欲搜尋的資料尚未被建立進BST中、或者已經從BST中移除的情況，例如，若要在悟空變成超級賽亞人之前找克林，以克林的戰鬥力「2」來搜尋，但是發現找不到，便回傳&lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因為克林被弗力札大王給殺死了啊啊阿啊(變身超級賽亞人)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="search" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;（界王神的聲音：為什麼&lt;code&gt;root&lt;/code&gt;從龜仙人變成比克？不會違反BST規則嗎？詳見&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree系列之Rotation(旋轉)&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;&lt;a name="sort"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;sort(排序)&lt;/h3&gt;
&lt;p&gt;故事來到了魔人普烏篇，因為角色有點多，有點混亂，此時，若想要知道各角色戰鬥力的大小排序，只要按照&lt;strong&gt;Inorder Traversal&lt;/strong&gt;即可按照戰鬥力(Key)高低列出所有資料：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sort" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七：藍色數字為戰鬥力(key)，紅色數字表示「戰鬥力由小到大」之順序。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="delete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;delete(刪除資料)&lt;/h3&gt;
&lt;p&gt;最後，當角色死掉去領便當，就需要從BST刪除資料，而根據欲刪除資料之「&lt;strong&gt;child個數&lt;/strong&gt;」可以分成三種情況：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刪除撒旦：撒旦&lt;strong&gt;沒有child&lt;/strong&gt;，因此，直接把撒旦的parent(普烏)之left child指向&lt;code&gt;NULL&lt;/code&gt;即可。&lt;/li&gt;
&lt;li&gt;刪除弗力札：弗力札有&lt;strong&gt;一個child&lt;/strong&gt;(left child)，因此刪除弗力札之前，需要先把弗力札的left child(基紐)接到弗力札的parent(龜仙人)上，又因為弗力札原本是龜仙人的right child，因此基紐將遞補弗力札，成為龜仙人的right child。&lt;/li&gt;
&lt;li&gt;刪除西魯：西魯有&lt;strong&gt;兩個child&lt;/strong&gt;，稍微麻煩一點，需要「多一個步驟」，將留待之後的文章做詳細說明。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="delete" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖八：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是BST與BST中的基本操作之介紹，所有操作都是以BST之特徵：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;為出發點，尤其是新增node與刪除node，務必要滿足BST之規則。&lt;/p&gt;
&lt;p&gt;接下來，將以兩篇文章的篇幅，說明上述四種資料處理操作的演算法。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch12&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E4%B8%83%E9%BE%99%E7%8F%A0#.E5.8A.87.E5.A0.B4.E7.89.88"&gt;Wikipedia：七龍珠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.imdb.com/title/tt1178663/"&gt;IMDB：Whatever Works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;BST系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category><category term="Intro"></category><category term="Dictionary"></category></entry><entry><title>Binary Tree: 建立一棵Binary Tree</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html" rel="alternate"></link><updated>2015-12-27T16:53:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-27:SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal&lt;/a&gt;中，非常沒誠意地用暴力方式建了一棵Binary Tree，在這裡至上深深歉意，因此，在本篇文章將提供一種方法，由一個字元陣列(char array)輸入字母，並按照&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-intro.html#fullcomplete"&gt;Complete Binary Tree&lt;/a&gt;之順序重新建立&lt;em&gt;那顆樹&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;其中，問題情境之原始資料是一個字元陣列(char array)，為了方便處理，選擇使用C++語言中的神器：&lt;a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html"&gt;stringstream&lt;/a&gt;，這裡礙於篇幅與主題(與筆者自己也還在摸索)，就不多談避免誤導，&lt;a href="(http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html)"&gt;點進連結中&lt;/a&gt;有非常詳細的說明，關於&lt;code&gt;istringstream&lt;/code&gt;、&lt;code&gt;ostringstream&lt;/code&gt;、&lt;code&gt;stringstream&lt;/code&gt;等等template class之繼承關係(inheritance)。  &lt;/p&gt;
&lt;p&gt;以及，以下提供的Binary Tree之建立方法，基本上是在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal介紹過的level-order traversal&lt;/a&gt;上加工，因此&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;queue(佇列)&lt;/a&gt;的概念會再次出現。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#description"&gt;問題描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;   &lt;ul&gt;
&lt;li&gt;&lt;a href="#def"&gt;定義class TreeNode、class BinaryTree&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#constructor"&gt;Constructor of BinaryTree&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#func1"&gt;Function：LevelorderConstruct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#func2"&gt;Function：insertLevelorder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Binary Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="description"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;問題描述&lt;/h2&gt;
&lt;p&gt;問題描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;給定一個字元陣列，欲按照Complete Binary Tree之位置規則建立一棵Binary Tree，若陣列元素之資料為大寫字母(ASCII：65~90)，則將其建立成Tree的node，若陣列元素為 ' x ' 則表示該位置沒有node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal&lt;/a&gt;中所提到的Binary Tree為例，如圖一：
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="binary tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/ex.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;其所對應的字元陣列即為：&lt;code&gt;A B C D E F x x x G H x I&lt;/code&gt;，如圖二所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="binary tree of char array" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/ex_char.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;以下程式範例的目的就是要以如此文明的方式建立出如圖一的Binary Tree。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;先看看&lt;code&gt;main()&lt;/code&gt;中，上半部分別為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始資料：字元陣列；&lt;/li&gt;
&lt;li&gt;以該字元陣列實體化(instantiate)一棵Binary Tree，本篇重點在此；&lt;/li&gt;
&lt;li&gt;以inorder traversal印出樹的資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下半部則是示範以&lt;code&gt;queue&lt;/code&gt;實現level-order traversal之小應用：以Complete Binary Tree之位置規則在樹中新增node。  &lt;/p&gt;
&lt;p&gt;溫馨小提醒：純粹以inorder traversal之結果並無法驗證樹之結構正如圖一(舉例來說：以inorder traversal對某一Linked list也可能得出相同結果)，因此，建議還是使用IDE的debug功能把pointer全部攤開。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sstream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;A B C D E F x x x G H x I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;K&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;L&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;N&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在經過一連串程式碼後，預期得到的output：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;   
&lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="def"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;定義class TreeNode、class BinaryTree&lt;/h3&gt;
&lt;p&gt;幾點說明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這裡對&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class BinaryTree&lt;/code&gt;之定義，與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;上一篇文章&lt;/a&gt;之最大不同在於資料的隱蔽性，因為在此不需要於&lt;code&gt;main()&lt;/code&gt;中存取任何pointer(&lt;code&gt;root&lt;/code&gt;、&lt;code&gt;leftchild&lt;/code&gt;、&lt;code&gt;rightchild&lt;/code&gt;)，因此將之放進&lt;strong&gt;private&lt;/strong&gt;區塊。&lt;/li&gt;
&lt;li&gt;在許多traversal中，時常以pointer不為&lt;code&gt;NULL&lt;/code&gt;作為&lt;code&gt;while&lt;/code&gt;的判斷式，因此在constructor中，多做一步，將pointer指向&lt;code&gt;NULL&lt;/code&gt;(eg：&lt;code&gt;leftchild = 0&lt;/code&gt;)避免埋地雷在日後炸自己。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;class BinaryTree&lt;/code&gt;除了上一篇介紹過的inorder traversal外，多了兩個新朋友&lt;code&gt;LevelorderConstruct()&lt;/code&gt;與&lt;code&gt;insertLevelorder()&lt;/code&gt;，前者即是本篇主角，吃進&lt;code&gt;stringstream&lt;/code&gt;後，把樹建出來；後者純粹是好玩，其功能為「以Complete Binary Tree之位置規則，在理應出現node的位置，新增node」，能夠儘量減少在新增node時增加樹高(height)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看下去。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="constructor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Constructor of BinaryTree&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;class BinaryTree&lt;/code&gt;的constructor很直觀，拿到一個字元陣列，先送進&lt;code&gt;stringstream&lt;/code&gt;後，再由&lt;code&gt;stringstream&lt;/code&gt;放進樹中，先對樹的&lt;code&gt;root&lt;/code&gt;進行記憶體配置以及賦值，接著以level-order的方式建立Binary Tree。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt;  &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="func1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Function：LevelorderConstruct&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在看&lt;code&gt;LevelorderConstruct()&lt;/code&gt;的函式主體之前，再看一眼&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#level"&gt;level-order traversal&lt;/a&gt;，概念上即是藉著&lt;code&gt;queue&lt;/code&gt;的「先排隊就先購票」的特性，在同一個level中，只要確保由左至右將node放進&lt;code&gt;queue&lt;/code&gt;中，便能確保在進入下一個level後，以先前放入node之順序進行visiting。  &lt;/li&gt;
&lt;li&gt;在&lt;code&gt;while&lt;/code&gt;內，新增條件用來判斷從&lt;code&gt;stringstream&lt;/code&gt;中輸出的字母是「大寫字母」(ASCII：65~90)還是「x」，前者要放入樹中建成node，後者則忽略不計。  &lt;/li&gt;
&lt;li&gt;整份程式碼的關鍵在於神器&lt;code&gt;stringstream &amp;amp;ss&lt;/code&gt;，只要不斷地透過&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;，&lt;code&gt;ss&lt;/code&gt;便會自動尋找下一筆資料餵進&lt;code&gt;data&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最後，當&lt;code&gt;stringstream&lt;/code&gt;不再更新&lt;code&gt;data&lt;/code&gt;時，也就是字元陣列已全數讀取完畢，即跳出&lt;code&gt;while&lt;/code&gt;迴圈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，在Binary Tree的constructor中，先配置&lt;code&gt;root&lt;/code&gt;的記憶體位置，並透過第一次&lt;code&gt;ss &amp;gt;&amp;gt; root-&amp;gt;data&lt;/code&gt;將第一個字母放進&lt;code&gt;root&lt;/code&gt;中，如圖三(a)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_0" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：從ss取出第一個字母'A'放進&lt;code&gt;root&lt;/code&gt;。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;接著進入&lt;code&gt;while&lt;/code&gt;迴圈。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;條件式：&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;若為真，表示成功從&lt;code&gt;ss&lt;/code&gt;中取出字母，傳進&lt;code&gt;data&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;進入迴圈後，先判斷取出的字母若為大寫字母(在此為&lt;strong&gt;'B'&lt;/strong&gt;)，即生成一個新的&lt;code&gt;new_node&lt;/code&gt;，將B放進&lt;code&gt;new_node&lt;/code&gt;中，並將&lt;code&gt;CurrentNode&lt;/code&gt;(在此為A)的left child指向&lt;code&gt;new_node&lt;/code&gt;，如圖三(b)。  &lt;/li&gt;
&lt;li&gt;在&lt;code&gt;queue&lt;/code&gt;  的部分，若成功建立出新的node(此為B)，便把B放進&lt;code&gt;queue&lt;/code&gt;的隊伍中，表示之後將要把&lt;code&gt;CurrentNode&lt;/code&gt;移到B，繼續往下建立新的node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt; 
&lt;img alt="construct_1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在同一個迴圈裡，建立完&lt;code&gt;CurrentNode&lt;/code&gt;的left child後，接著嘗試建立right child。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;條件式：&lt;code&gt;if( !(ss &amp;gt;&amp;gt; data) )&lt;/code&gt;若為真，表示&lt;code&gt;ss&lt;/code&gt;中的字母已經讀取完畢，即跳出迴圈(&lt;code&gt;break&lt;/code&gt;)。若否，則繼續從&lt;code&gt;ss&lt;/code&gt;中讀取字母。&lt;/li&gt;
&lt;li&gt;判斷字母是否為大寫字母(此為&lt;strong&gt;'C'&lt;/strong&gt;)，便如同生成left child之方法，建立新的&lt;code&gt;new_node&lt;/code&gt;、配置記憶體、將字母&lt;strong&gt;'C'&lt;/strong&gt;放進&lt;code&gt;new_node&lt;/code&gt;中，並將&lt;code&gt;CurrentNode&lt;/code&gt;之right child指向&lt;code&gt;new_node&lt;/code&gt;，如圖三(c)。&lt;/li&gt;
&lt;li&gt;已成功建立新的node(C)，便把C放進&lt;code&gt;queue&lt;/code&gt;的隊伍中，表示之後將要把&lt;code&gt;CurrentNode&lt;/code&gt;移到B，繼續往下建立新的node。
此時，&lt;code&gt;queue&lt;/code&gt;裡有兩個node，分別為B與C，要注意的是，排隊時，先進入隊伍的人會代表隊伍的前方，因此B為&lt;code&gt;queue&lt;/code&gt;的&lt;strong&gt;Front&lt;/strong&gt;，C為&lt;code&gt;queue&lt;/code&gt;的&lt;strong&gt;Back&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct2.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在建立完&lt;code&gt;CurrentNode&lt;/code&gt;的left child與right child後，接著要移動&lt;code&gt;CurrentNode&lt;/code&gt;，作為下一個&lt;code&gt;while&lt;/code&gt;迴圈的起點。&lt;br /&gt;
&lt;code&gt;queue&lt;/code&gt;的功能便是提供&lt;code&gt;CurrentNode&lt;/code&gt;移動的依據：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一律將&lt;code&gt;queue&lt;/code&gt;隊伍的第一個node視作新的&lt;code&gt;CurrentNode&lt;/code&gt;：&lt;code&gt;CurrentNode = q.front()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;CurrentNode&lt;/code&gt;移動至B後，便把B從&lt;code&gt;queue&lt;/code&gt;移除：&lt;code&gt;q.pop()&lt;/code&gt;，如圖三(d)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此便能保證，&lt;code&gt;CurrentNode&lt;/code&gt;的移動會依照level-order「由上至下、由左至右」之順序。
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="construct_3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct3.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;進入第二次&lt;code&gt;while&lt;/code&gt;迴圈後，重複以上之步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;從&lt;code&gt;ss&lt;/code&gt;取出字母，放進&lt;code&gt;data&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;判斷&lt;code&gt;data&lt;/code&gt;是否為大寫，若是，便依序在&lt;code&gt;CurrentNode&lt;/code&gt;之left child與right child建立新的node。&lt;/li&gt;
&lt;li&gt;並且，將成功建立之node放進&lt;code&gt;queue&lt;/code&gt;隊伍中，用作之後&lt;code&gt;CurrentNode&lt;/code&gt;移動之用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仔細觀察圖三(e)至圖三(h)之&lt;code&gt;ss&lt;/code&gt;與&lt;code&gt;CurrentNode&lt;/code&gt;之移動，與&lt;code&gt;queue&lt;/code&gt;的變化：
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="construct_4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct4.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_5" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct5.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_6" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct6.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_7" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct7.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在建立完C的left child後，從&lt;code&gt;ss&lt;/code&gt;讀取到字母&lt;strong&gt;'x'&lt;/strong&gt;，因為其並非大寫字母，表示C沒有right child，因此跳過生成新的node之步驟，如圖三(i)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_8" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct8.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若沒有生成新的node，便沒有新的node進入&lt;code&gt;queue&lt;/code&gt;排隊。&lt;/li&gt;
&lt;li&gt;接著要繼續將&lt;code&gt;CurrentNode&lt;/code&gt;移動到&lt;code&gt;queue&lt;/code&gt;的第一個元素，也就是D，並把D從&lt;code&gt;queue&lt;/code&gt;中移除，如圖三(j)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_9" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct9.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(j)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當&lt;code&gt;CurrentNode&lt;/code&gt;移動到D之後，&lt;code&gt;ss&lt;/code&gt;連續放兩個&lt;strong&gt;'x'&lt;/strong&gt;進入&lt;code&gt;data&lt;/code&gt;，表示D的兩個child pointer皆指向&lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由於沒有新的node產生，&lt;code&gt;queue&lt;/code&gt;的隊伍便沒有更新，如圖三(k)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_10" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(k)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;接著，重複步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移動&lt;code&gt;CurrentNode&lt;/code&gt;至&lt;code&gt;queue&lt;/code&gt;的第一個元素所指示的node。&lt;/li&gt;
&lt;li&gt;從&lt;code&gt;ss&lt;/code&gt;讀取字母，判斷其為大寫字母，生成新的node接在&lt;code&gt;CurrentNode&lt;/code&gt;的child pointer上。&lt;/li&gt;
&lt;li&gt;若有生成新的node，則將該node推入&lt;code&gt;queue&lt;/code&gt;的隊伍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_11" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct11.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(l)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直到&lt;code&gt;ss&lt;/code&gt;輸出最後一個字母&lt;strong&gt;'I'&lt;/strong&gt;後，這棵樹便建立完成。&lt;/li&gt;
&lt;li&gt;由於，&lt;code&gt;ss&lt;/code&gt;已全數讀取完畢，敘述句：&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;不成立，因此結束迴圈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_12" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct12.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(m)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// call constructor TreeNode(char s)&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// call constructor TreeNode()&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// assign data to new_node&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
&lt;a name="func2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Function：insertLevelorder&lt;/h3&gt;
&lt;p&gt;函式&lt;code&gt;insertLevelorder()&lt;/code&gt;的功能是，能夠按照Complete Binary Tree的位置順序放置新增的node，例如，若要在圖三之樹上新增帶有字母&lt;strong&gt;'K'&lt;/strong&gt;的node，則&lt;code&gt;T.insertLevelorder('K')&lt;/code&gt;便會將&lt;strong&gt;'K'&lt;/strong&gt;建成C的right child，如圖四(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insertK" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/insertK.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;再依序新增L、M、N：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('L')&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('M')&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('N')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即會得到如圖四(b)的樹：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insertLMN" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/insertLMN.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;程式碼之邏輯與&lt;code&gt;LevelorderConstruct&lt;/code&gt;大同小異，最主要的部分就是利用&lt;code&gt;queue&lt;/code&gt;來記錄&lt;code&gt;CurrentNode&lt;/code&gt;移動的順序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，將&lt;code&gt;current&lt;/code&gt;設成&lt;code&gt;root&lt;/code&gt;，若樹存在，則進入&lt;code&gt;while&lt;/code&gt;迴圈。&lt;/li&gt;
&lt;li&gt;接著判斷，若&lt;code&gt;current&lt;/code&gt;之left child已經有node，則將之放入&lt;code&gt;queue&lt;/code&gt;中，在下次迴圈將以此node作為&lt;code&gt;current&lt;/code&gt;，若left child還沒有node，便產生帶有&lt;code&gt;data&lt;/code&gt;之新node，並將其建立成&lt;code&gt;current&lt;/code&gt;之left child。&lt;br /&gt;
pointer連接完成後，結束迴圈。&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之right child進行相同之步驟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此便能有效控制Binary Tree之樹高(height)，使pointer所配置之記憶體空間有效利用，亦能夠減少traversal(以及其他操作)所需的時間。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;    
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
以上便是利用&lt;code&gt;queue&lt;/code&gt;執行level-order方式建立Binary Tree之範例。&lt;br /&gt;
另外，&lt;a href="http://www.geeksforgeeks.org/level-order-tree-traversal/"&gt;有些方法是利用遞迴的方式，外帶一個迴圈來進行level-order traversal&lt;/a&gt;，也能夠完成相同的功能。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch12&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html"&gt;C++ Programming Language：Stream IO and File IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/level-order-tree-traversal/"&gt;GeeksforGeeks：Level Order Tree Traversal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Binary Tree系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="C++"></category><category term="Binary Tree"></category></entry><entry><title>Binary Tree: Traversal(尋訪)</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html" rel="alternate"></link><updated>2015-12-24T22:41:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-24:SecondRound/binary-tree-traversalxun-fang.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在Linked list與Tree中的traversal中對於pointer的操作，在概念上完全相同，不過由於Node的pointer增加了，於是從一維的移動拓展到二維的移動。&lt;br /&gt;
建議讀者可以先閱讀&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html#print"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;作簡單複習。  &lt;/p&gt;
&lt;p&gt;本篇文章將介紹在Binary Tree中的四種traversal方法。  &lt;/p&gt;
&lt;p&gt;程式實作的部分，除了&lt;strong&gt;遞迴(recursion)&lt;/strong&gt;，還有可能會使用上Stack(堆疊)與Queue(佇列)，如果不太熟悉，請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html"&gt;Stack: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html"&gt;Queue: Intro(簡介)，並以Linked list實作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bttraversal"&gt;Traversal in Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ex_code"&gt;Example with Code&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pre"&gt;Pre-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#in"&gt;In-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#post"&gt;Post-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#level"&gt;Level-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#in_parent"&gt;In-Order Traversal by Parent Field&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#successor"&gt;Successor、leftmost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#predecessor"&gt;Predecessor、rightmost&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Binary Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bttraversal"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Traversal in Binary Tree&lt;/h2&gt;
&lt;p&gt;Traversal(尋訪)有「站在A地，往所有與A地相連的地方移動」的意思：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以Graph(圖)的語言來說，站在vertex(A)上，有一條edge連結vertex(A)與vertex(B)，若能夠由A往B移動，此即可視為traversal；&lt;/li&gt;
&lt;li&gt;在以pointer實現之Linked list和Tree中，站在node(A)上，並且node(A)具有指向node(B)之pointer，便能夠由A往B移動，此即可視為traversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移動到特定的node之後，通常伴隨著其他行為，例如print out(顯示資料)、assign(賦值)、刪除資料等等，這些操作又稱作&lt;strong&gt;Visiting&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Binary Tree的Node具有兩個指向child的pointer，traversal以「當前所在的node」為參考點，所能夠進行的行為有三種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;V&lt;/strong&gt;：Visiting，對當前所在的node進行print、assign或其他操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L&lt;/strong&gt;：移動到left child。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;：移動到right child。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="VLR" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：CurrentNode位在A，leftchild與rightchild分別為B與C。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;以圖一為例，假設現在CurrentNode位在A，leftchild與rightchild分別為B與C，並加上一項限制：「L一定在R之前」，便能產生三種相對關係：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="VLR_pre" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f2.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)-(c) 依序為： (a)pre-order：VLR、(b)in-order：LVR、(c)post-order：LRV&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pre-order(VLR)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A進行Visiting，接著前往left child進行Visiting，再前往right child進行Visiting。(若child指向NULL則忽略。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;in-order(LVR)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A的left child(B)進行Visiting，接著回到A進行Visiting，再前往right child(C)進行Visiting。(若child指向NULL則忽略。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;post-order(LRV)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A的left child(B)進行Visiting，再前往right child(C)進行Visiting，接著回到A進行Visiting。(若child指向NULL則忽略。)&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
小小備註：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以下圖例中，V表示CurrentNode所在的node，標上數字後表示已經Visiting完成，以print(顯示資料)為例，標上「&lt;span class="math"&gt;\(1\)&lt;/span&gt;」表示該node第一個被印出。&lt;/li&gt;
&lt;li&gt;以下文字說明，將使用scope(視野範圍)的概念，用來表示以每個CurrentNode(也就是V)為中心，與其所能夠指向之pointer所構成的範圍(等同於「迴圈」或者「函式呼叫」的scope)。因為每個迴圈都會改變CurrentNode(V)的位置，因此scope會以CurrentNode(V)為中心不停移動，直到迴圈/函式結束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;現有一棵樹如圖三(a)，欲進行post-order traversal，並將Visiting用作print(顯示資料)，流程如下：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;一開始，CurrentNode進到A(root)，按照post-order的順序規則(LRV)，先檢查left child：B是否為NULL，若不是，則先將CurrentNode移動到B(L)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;當CurrentNode移動到B，再一次執行post-order的順序規則(LRV)，檢查left child：D是否為NULL，若不是，則將CurrentNode移動到D(L)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;當CurrentNode移動到D，再一次執行post-order的順序規則(LRV)，檢查出D的left child與right child皆為NULL，表示「LRV」的「L」與「R」都已經執行完畢，便「回到D」做Visiting，在此即印出D(print)。&lt;/p&gt;
&lt;p&gt;接著，由於「以D為CurrentNode」形成的scope內之node已經全數Visiting完畢，便可回到「以D之parent作為CurrentNode之scope」，於是將CurrentNode移回B。&lt;/p&gt;
&lt;p&gt;回到B的動作發生，即表示：以D為CurrentNode之迴圈或函式已經結束。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：scope內：D(V)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;D已經進行過Visiting，便標上數字「&lt;span class="math"&gt;\(1\)&lt;/span&gt;」，表示D為post-order traversal的第一站。&lt;br /&gt;
接著，在「以B為CurrentNode」的scope中，根據post-order規則，繼續往E(R)移動。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_e" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;進入E後，因為E為leaf node，因此過程如圖三(d)，不會進入NULL。&lt;br /&gt;
在D(L)與E(R)都Visiting過後，便回到B(V)進行Visiting，並標上數字。如此便完成「以B為CurrentNode之scope」內的所有node之Visiting。&lt;/p&gt;
&lt;p&gt;接著回到「以A為CurrentNode」的scope。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_f" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;回到「以A為CurrentNode」的scope後，按照post-order的規則，接著往C(R)移動。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_g" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;同樣地步驟，再從C移動至F(L)，並發現F為leaf node，於是對F進行Visiting，並標上數字。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_h" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：scope內：C(V)、F(L)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;列出F後，發現C的right child指向NULL，於是略過right child(R)，回到C(V)，並對C進行Visiting，標上數字。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_i" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f13.png?raw=true" /&gt;&lt;img alt="bt_j" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)-(j)：scope內：C(V)、F(L)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後回到「以A為CurrentNode」的scope，對A(V)進行Visiting，便完成了此次post-order traversal，並依序印出&lt;code&gt;D E B F C A&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_k" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f15.png?raw=true" /&gt;&lt;img alt="bt_l" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(k)-(l)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上說明了post-order traversal之過程，另外兩種pre-order與in-order在概念上皆相同，只要把握順序規則即可。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ex_code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Example with Code&lt;/h2&gt;
&lt;p&gt;(完整範例程式碼在這裡：&lt;a href="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/ExampleCode/BT_Traversal.cpp"&gt;BT_Traversal.cpp&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;接下來，再以一棵稍微複雜的Binary Tree作為範例，展示pre-order、in-order、post-order及level-order之traversal。&lt;/p&gt;
&lt;p&gt;現有一棵樹如圖四(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;並以最暴力的方式建立&lt;code&gt;TreeNode&lt;/code&gt;與&lt;code&gt;BinaryTree&lt;/code&gt;之物件(object)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Preorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Inorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Postorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Levelorder()&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// TreeNode instantiation&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;B&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeC&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;D&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;E&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeF&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;F&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;G&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;H&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeI&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// construct the Binary Tree&lt;/span&gt;
    &lt;span class="n"&gt;nodeA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;nodeA&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;nodeB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeD&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;nodeB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;nodeE&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;nodeE&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeH&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;nodeC&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;nodeF&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeI&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;BinaryTree&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodeA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的程式碼包含了幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class TreeNode&lt;/code&gt;的定義；&lt;ul&gt;
&lt;li&gt;這裡把所有的data與pointer全部設成「public」裸露在外其實不太好，不過為了要能在&lt;code&gt;main()&lt;/code&gt;裡土法煉鋼建立出一棵如圖四(a)的Binary Tree，只好將就。&lt;/li&gt;
&lt;li&gt;下一篇文章會用比較文明的方式建立Binary Tree，請參考：&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class BinaryTree&lt;/code&gt;的定義，其中有四個member function分別為四種traversal；&lt;ul&gt;
&lt;li&gt;四個函式的定義請繼續看下去。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;main()中建立如圖四(a)的樹，並依序執行四種traversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，pre-order、in-order、post-order traversal的邏輯就只是「V」、「L」、「R」誰先誰後的差別，以下程式碼是以較直覺的遞迴(recursion)形式完成，不過，換成迭代(iteration)配合&lt;strong&gt;Stack(堆疊)&lt;/strong&gt;在概念上完全相同，實作上即是考慮「V」、「L」、「R」誰先push(推)進stack。  &lt;/p&gt;
&lt;p&gt;&lt;a name="pre"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Pre-Order Traversal&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                          &lt;span class="c1"&gt;// if current != NULL&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// V&lt;/span&gt;
        &lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// R&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_pre" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="in"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;In-Order Traversal&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                          &lt;span class="c1"&gt;// if current != NULL&lt;/span&gt;
        &lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// V&lt;/span&gt;
        &lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// R&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="post"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Post-Order Traversal&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                         &lt;span class="c1"&gt;// if current != NULL&lt;/span&gt;
        &lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// R&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// V&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_post" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="level"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Level-Order Traversal&lt;/h3&gt;
&lt;p&gt;Level-order是照著「level由小到大」的順序，由上而下，並在同一個level「由左至右」依序Visiting每個node。&lt;/p&gt;
&lt;p&gt;以下提供以迴圈配合&lt;strong&gt;Queue(佇列)&lt;/strong&gt;實現level-order traversal之程式碼，其邏輯也非常直觀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖四(e)為例，當CurrentNode站在A時，先對A作Visiting，接著檢查是否有left child與right child，若不為NULL，則「依序」將child pointer 推(push)進queue中，又根據queue「先進先出」(first-in-first-out)的特性，先將B(left child)推入queue，再推入C(right child)，便能確保在下一層level時，是由左至右，先Visiting到B，才Visiting到C。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_level" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                     &lt;span class="c1"&gt;// 把root作為level-order traversal之起點&lt;/span&gt;
                                            &lt;span class="c1"&gt;// 推進queue中&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;()){&lt;/span&gt;                     &lt;span class="c1"&gt;// 若queue不是空的, 表示還有node沒有visiting&lt;/span&gt;

        &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="c1"&gt;// 取出先進入queue的node&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                          
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 進行visiting&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;    &lt;span class="c1"&gt;// 若leftchild有資料, 將其推進queue&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   &lt;span class="c1"&gt;// 若rightchild有資料, 將其推進queue&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="in_parent"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;In-Order Traversal by Parent Field&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html#code"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;提到，若在&lt;code&gt;class TreeNode&lt;/code&gt;加入pointer指向其parent node會非常有幫助，其中一項理由正是接下來要介紹的兩個函式：&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;說文解字時間：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字首Inorder-，即是按照inorder traversal之規則(LVR)；&lt;/li&gt;
&lt;li&gt;字尾Successor/ Predecessor，即是「下一個」與「前一個」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;便是用來尋找「&lt;strong&gt;以inorder順序&lt;/strong&gt;」進行traversal之下一個與前一個node。  &lt;/p&gt;
&lt;p&gt;以圖四(c)為例，若CurrentNode站在H(&lt;code&gt;CurrentNode = nodeH&lt;/code&gt;)，則：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CurrentNode = InorderSuccessor(CurrentNode)&lt;/code&gt;會將CurrentNode移動至A；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CurrentNode = InorderPredecessor(CurrentNode)&lt;/code&gt;則會將CurrentNode移動至E。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;特別介紹inorder，一大原因是為了Binary Search Tree(BST)鋪路，在BST中，照著inorder順序印出node，就會得到「排好序」的資料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;詳見：&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，若觀察前面提過的遞迴(recursion)形式之inorder traversal，Visiting被包含在遞迴函式內，這表示若要進行多種不同的Visiting，例如print(顯示資料)、assign(賦值、更新資料)，都需要重新寫一個專門功能的遞迴函式。&lt;br /&gt;
顯然，把Visiting和Traversal獨立開來會更有效率。&lt;/p&gt;
&lt;p&gt;在看兩個實用的函式之前，有幾件前置作業：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;class BinaryTree&lt;/code&gt;的定義中加入六個member function(成員函式)：&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;main()&lt;/code&gt;中，把如圖四之Binary Tree的parent pointer建立起來。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="c1"&gt;// inside main()&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="c1"&gt;// link parent pointer&lt;/span&gt;
    &lt;span class="n"&gt;nodeB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;nodeC&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;nodeD&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;nodeE&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;nodeG&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;nodeH&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;nodeF&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;nodeI&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodeF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// inside definition of class BinaryTree&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_Reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;為找到「下一個」與「上一個」的函式主體；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leftmost()&lt;/code&gt;和&lt;code&gt;rightmost()&lt;/code&gt;即是找到Binary Tree整棵樹中「最左」與「最右」的node；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Inorder_by_parent()&lt;/code&gt;與&lt;code&gt;Inorder_Reverse()&lt;/code&gt;將利用&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;進行一次In-Order Tarversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看下去。&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="successor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Successor、leftmost&lt;/h3&gt;
&lt;p&gt;函式&lt;code&gt;leftmost()&lt;/code&gt;的功能為：尋找以&lt;code&gt;current&lt;/code&gt;為root之subtree中，最左邊的node。&lt;/p&gt;
&lt;p&gt;以圖四(c)為例，進入以A為root的Binary Tree後，&lt;code&gt;leftmost()&lt;/code&gt;將一路往leftchild前進，最後回傳D。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;而以inorder的順序來說，&lt;code&gt;leftmost()&lt;/code&gt;將回傳該subtree中第一個進行Visiting的node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以下為&lt;code&gt;leftmost()&lt;/code&gt;的範例程式碼：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
接著重點來了，觀察在inorder規則下，某一node的「&lt;strong&gt;Successor&lt;/strong&gt;」之所在位置有兩種可能：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一種&lt;/strong&gt;：若CurrentNode的right child不是NULL，則CurrentNode之下一個順序的node即為以「Current&lt;span class="math"&gt;\(-\)&lt;/span&gt;&amp;gt;rightchild為root」之subtree中，最左的node。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖五(a)所示，若CurrentNode站在B上，B的下一個node即為「以B的right child(也就是E)為root」之subtree中的最左node，即為G。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第二種&lt;/strong&gt;：若CurrentNode沒有right child，則CurrentNode之下一個順序的node是「以left child的身份尋找到的ancestor」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖五(a)中的H為例，H沒有right child，因此往上(往root方向)找ancestor。  &lt;/li&gt;
&lt;li&gt;首先找到E，但是H是E的right child，因此再繼續往上找，此時CurrentNode移動到E。  &lt;/li&gt;
&lt;li&gt;接著往E的parent找到B，由於E是B的right child，所以要再繼續往上找，並更新CurrentNode為B。  &lt;/li&gt;
&lt;li&gt;接著往B的parent找到A，此時，&lt;strong&gt;B為A的left child&lt;/strong&gt;，則A即為H的下一個順序的node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特例是root，若整棵樹偏向一邊，root只有left subtree，沒有right subtree，那麼便回傳NULL，表示root沒有successor。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="successor" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以下為&lt;code&gt;InorderSuccessor()&lt;/code&gt;的範例程式碼：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 利用兩個pointer: successor與current做traversal &lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;successor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;successor&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;successor&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;successor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;successor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;successor&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;successor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最後，有了&lt;code&gt;leftmost()&lt;/code&gt;與&lt;code&gt;InorderSuccessor()&lt;/code&gt;，即能夠以迴圈的方式進行inorder traversal，相較於遞迴形式的函式，具有更大彈性，以函式&lt;code&gt;Inorder_by_parent()&lt;/code&gt;呈現：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;中輸入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;得到output：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
&lt;a name="predecessor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Predecessor、rightmost&lt;/h3&gt;
&lt;p&gt;只要把&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;leftmost()&lt;/code&gt;中，所有的left與right互換，就得到&lt;code&gt;InorderPredecessor()&lt;/code&gt;與&lt;code&gt;rightmost()&lt;/code&gt;，而概念上也確實是如此：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rightmost&lt;/strong&gt;：從「以CurrentNode為subtree」的root一路向右做Linked list的單向traversal。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Predecessor&lt;/strong&gt;：某一CurrentNode的「前一個順序的node」之位置有兩種可能：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一種&lt;/strong&gt;：若CurrentNode的left child不是NULL，則CurrentNode之前一個順序的node即為以「Current-&amp;gt;lefttchild為root」之subtree中，最右的node。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖五(b)所示，若CurrentNode站在C上，C的前一個node即為「以C的right child(也就是F)」為root之subtree中的最右node，即為I。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第二種&lt;/strong&gt;：若CurrentNode沒有left child，則CurrentNode之前一個順序的node是「以right child的身份尋找到的ancestor」。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖五(b)中的F為例，F沒有left child，因此往上(往root方向)找ancestor。&lt;/li&gt;
&lt;li&gt;首先找到C，但是F是C的left child，因此再繼續往上找，此時CurrentNode更新成C。&lt;/li&gt;
&lt;li&gt;再往C的parent找到A，此時，&lt;strong&gt;C為A的right child&lt;/strong&gt;，則A即為F的前一個順序的node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同樣地，若整棵樹偏向一邊，root只有right subtree，沒有left subtree，則回傳NULL，表示root沒有predecessor。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="predecessor" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/f23.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以下為&lt;code&gt;rightmost()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;的範例程式碼：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 利用兩個pointer: predecessor與current做traversal&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有了&lt;code&gt;rightmost()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;，便能夠照inorder traversal的相反順序對樹的node做Visiting，以函式&lt;code&gt;Inorder_Reverse&lt;/code&gt;呈現：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder_Reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;中輸入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder_Reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;得到output：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt; &lt;br /&gt;
&lt;code&gt;InorderSuccessor()&lt;/code&gt;和&lt;code&gt;InorderPredecessor()&lt;/code&gt;在Binary Search Tree的部分會再次出現，並且出現在基本操作：deletion(刪除node)中，因此學起來不止酷，還很實用的啊。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch12&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html#print"&gt;Linked List: 新增資料、刪除資料、反轉&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html"&gt;Stack: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html"&gt;Queue: Intro(簡介)，並以Linked list實作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Binary Tree系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Tree"></category></entry><entry><title>Binary Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html" rel="alternate"></link><updated>2015-12-21T22:24:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-21:SecondRound/binary-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;接續上一篇談到的&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu.html"&gt;Tree(樹)&lt;/a&gt;，這篇文章將介紹Tree的其中一支大宗：&lt;strong&gt;Binary Tree&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bt"&gt;Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fullcomplete"&gt;Full &amp;amp; Complete Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#application"&gt;學習Binary Tree的未來出路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Binary Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bt"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Binary Tree&lt;/h2&gt;
&lt;p&gt;最廣義的樹(Tree)對於樹上的node之child數目沒有限制，因此，每個node可以有多個child。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="general_tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：這是一棵樹(Tree)&lt;/strong&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;若限制node只能有兩個child，等價於「樹上的每一個node之degree皆為2」，此即稱為&lt;strong&gt;Binary Tree&lt;/strong&gt;(二元樹)，並稱兩個child pointer為&lt;strong&gt;left child&lt;/strong&gt;和&lt;strong&gt;right child&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="binary_tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/f2.png?raw=true" /&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：這是一棵Binary Tree。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;修改在&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu.html#code"&gt;Tree(樹)&lt;/a&gt;提供的程式實作方式，將node的child pointer設為left child與right child，以滿足Binary Tree的形式。  &lt;/p&gt;
&lt;p&gt;另外，在class TreeNode有個&lt;code&gt;TreeNode *parent&lt;/code&gt;，顧名思義，即是指向該node之parent的pointer，以圖二為例，B的parent pointer即指向A。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binary Tree的node未必需要parent pointer(或稱為parent field)，不過加入parent後，對樹的資料處理如inorder traversal(中序尋訪)、node deletion(刪除node)、以及任何需要back-tracing(回溯路徑)的操作時，會更加有效率。&lt;br /&gt;
&lt;/br&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 以C++為例&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;data2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="fullcomplete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Full &amp;amp; Complete Binary Tree&lt;/h2&gt;
&lt;p&gt;有兩類Binary Tree十分常見，分別為&lt;strong&gt;Full Binary Tree&lt;/strong&gt;以及&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;。&lt;br /&gt;
(這裡不知該翻作「完滿二元樹」還是「完整二元樹」，所以就不做翻譯當作專有名詞，請見諒。) &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A. Full Binary Tree&lt;/strong&gt;:  &lt;/p&gt;
&lt;p&gt;如圖三所示，一棵&lt;strong&gt;Full Binary Tree&lt;/strong&gt;(或稱作Perfect Binary Tree)具有以下性質：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有internal node都有兩個subtree(也就是兩個child pointer)；&lt;/li&gt;
&lt;li&gt;所有leaf node具有相同的level(或相同的height)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由以上性質能夠推論出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若一棵Full Binary Tree的leaf node之level為&lt;span class="math"&gt;\(n\)&lt;/span&gt;，整棵樹共有&lt;span class="math"&gt;\(2^n-1\)&lt;/span&gt;個node。&lt;/li&gt;
&lt;li&gt;例如，若leaf node的level為4， 整棵樹共有15個node。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;並且，每個node與其child有以下關係：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的left child之index為 &lt;span class="math"&gt;\(2i\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的right child之index為 &lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;除了root之parent為NULL之外，第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的parent之index為 &lt;span class="math"&gt;\(\lfloor {i\over2} \rfloor\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Full Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/f3.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：若一棵Full Binary Tree的leaf node之level為&lt;span class="math"&gt;\(n\)&lt;/span&gt;，整棵樹共有&lt;span class="math"&gt;\(2^n-1\)&lt;/span&gt;個node。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
&lt;strong&gt;B. Complete Binary Tree&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;若一棵樹的node按照Full Binary Tree的次序排列(由上至下，由左至右)，則稱此樹為&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;以圖四及圖五作說明：  &lt;/p&gt;
&lt;p&gt;圖四的樹共有10個node，且這十個node正好填滿Full Binary Tree的前十個位置，則此樹為Complete Binary Tree。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Complete Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/f4.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：這是一棵Complete Binary Tree。&lt;/strong&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;圖五的樹共有11個node，但是第11個node(K)應該要是第5個node(E)的child，因此，此樹並非Complete Binary Tree。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Not Complete Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/f5.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：這不是一棵Complete Binary Tree。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="application"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;學習Binary Tree的未來出路&lt;/h2&gt;
&lt;p&gt;如果有家長擔心小孩子學了Binary Tree之後對未來的出路沒有幫助，這裡有&lt;a href="http://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees"&gt;網路大神在StackOverFlow&lt;/a&gt;開示，以下簡單翻譯幾項Binary Tree的應用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binary Search Tree(BST)：在某些資料經常要增加、刪除的應用中，BST常用來做搜尋，例如許多程式語言的Library中的&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Binary Space Partition：應用於幾乎所有的3D電玩遊戲以決定哪些物件需要rendered。&lt;/li&gt;
&lt;li&gt;Binary Tries：應用於大多數high-bandwidth router(高頻寬路由器)以儲存router-tables。&lt;/li&gt;
&lt;li&gt;Heaps：用以實現高效率的priority queues(優先權佇列)，許多作業系統用來安排工作程序。&lt;ul&gt;
&lt;li&gt;請參考：&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Huffman Coding Tree：例如.jpeg、.mp3等壓縮技術皆使用Huffman編碼。(在一顆20MB的硬碟要價新台幣一萬元的時代，壓縮技術就是救世主。)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及其他應用(記得點進連結瞻仰大神風範)。  &lt;/p&gt;
&lt;p&gt;下一篇文章將介紹Binary Tree(以及往後主題)中最基本的操作：traversal(尋訪)，顧名思義，就是如何在樹中移動，有了traversal之後再進一步探討search(搜尋)、insertion(新增node)、deletion(刪除node)、sorting(排序)會更加容易。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Binary_tree"&gt;Wikipedia：Binary tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees"&gt;StackOverFlow：What are the applications of binary trees?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html"&gt;Priority Queue：Binary Heap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Binary Tree系列文章&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Tree"></category><category term="Intro"></category></entry><entry><title>Tree(樹): Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html" rel="alternate"></link><updated>2015-12-19T20:27:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-19:SecondRound/treeshu-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;若熟悉Linked List(連結串列)將會更容易理解樹：Linked list是一維的線性結構(不是往前、就是往後)，樹(與Graph)則推廣成多維的結構。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="linkedlist" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：A、B、C、D稱為node(節點)，用以代表資料(data)、狀態(state)。&lt;br /&gt;
連結各個node之間的連結(link)稱為edge，可能是單方向，或者雙向。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;關於Linked list，請參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html"&gt;Linked List：Intro(簡介)&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html"&gt;Linked List：新增資料、刪除資料、反轉&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=u1ZB_rGFyeU"&gt;OK Go&lt;/a&gt;.  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#example"&gt;隨處可見的Tree(樹)&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#essence"&gt;那麼，樹最根本的特徵是什麼？&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_not_tree"&gt;還有哪些結構是樹？&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#element"&gt;用以描述一棵樹的元素&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#definition"&gt;樹的定義&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#set"&gt;集合關係&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;隨處可見的Tree(樹)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Tree(樹)&lt;/strong&gt;是用以描述具有&lt;strong&gt;階層結構&lt;/strong&gt;(hierarchical structure)的問題的首選，階層結構意味著明確的先後次序，例如，若要印出ABC三個字母的所有排列組合(permutation)，直覺反射的圖像會是：  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="fig1.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f2.png?raw=true" /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;img alt="fig1.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f3.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：ABC字母排列組合。&lt;br /&gt;
視R為樹根(root)，每一個選擇狀態視為node，此即為樹的結構。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;圖二的邏輯為：從起點(R)開始，先決定第一個字母，再依序決定第二、第三個字母，並且，在每一次選擇字母時，可能有不止一個可供選擇的字母。最後一共走出六條路徑，得到六種排列組合，而且這六種排列方式只能經由一種唯一的選擇方式(唯一的路徑)產生。&lt;br /&gt;
若將起點(R)視為樹根(root)，每一個字母選擇的狀態(例如：A、C、BC、CAB)都視為一個node，這樣的結構便能夠視為一棵樹。  &lt;/p&gt;
&lt;p&gt;另外如一本書的目錄、族譜、企業的職位關係，甚至是更廣義的「從家門口為起點尋找方圓一公里以內的便利商店」都能夠建立出樹的模型。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="essence"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;那麼，樹最根本的特徵是什麼？&lt;/h2&gt;
&lt;p&gt;以族譜為例，若定義包龍星是宋世傑的爸爸，那麼包龍星就絕對不能同時又是宋世傑的兒子。  &lt;/p&gt;
&lt;p&gt;圖三以node與edge描述此關係，並定義箭頭是從父指向子，則：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包龍星指向宋世傑的箭頭表示包為父、宋為子；&lt;/li&gt;
&lt;li&gt;宋世傑指向包龍星的箭頭表示宋為父、包為子；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;後者的箭頭即違反了最初「包龍星是宋世傑的爸爸」的命題，此即稱為cycle，也就是著名的「雞生蛋」與「蛋生雞」。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cycle" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f4.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：包龍星若是宋世傑的parent(父)，又同時為其child(子)，即形成cycle。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;而樹的最根本特徵就是：&lt;strong&gt;在樹的結構裡，只有一個root(樹根)，並且不存在cycle&lt;/strong&gt;。&lt;br /&gt;
此特徵將衍生出另外兩項等價的性質：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在樹中若要從root尋找特定node，一定只存在一條路徑(path)。  &lt;/li&gt;
&lt;li&gt;每個node只會有一個parent。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="tree_not_tree"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;還有哪些結構是樹？&lt;/h2&gt;
&lt;p&gt;下列四種結構中，a、b可以視為樹，而c、d則否：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig2.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f5.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.a：若樹的node只有指向left subtree(左子樹)與right subtree(右子樹)時，又稱為Binary Tree(二元樹)。&lt;/strong&gt;&lt;br /&gt;
&lt;/br&gt; 
&lt;img alt="fig2.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f6.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.b：若樹退化成Linked list(連結串列)，仍滿足樹的定義。&lt;/strong&gt;  &lt;br /&gt;
&lt;/br&gt;
&lt;img alt="fig2.c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f7.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.c：在F出現cycle；以及，D有兩個parent node。&lt;/strong&gt;&lt;br /&gt;
&lt;/br&gt;
&lt;img alt="fig2.d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f8.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.d：一棵樹只能有一個root(樹根)。此圖像又稱為Forest(樹林)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="element"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;用以描述一棵樹的元素&lt;/h2&gt;
&lt;p&gt;配合圖四，以下將介紹在樹中常見的元素。  &lt;/p&gt;
&lt;p&gt;針對&lt;strong&gt;node / vertex&lt;/strong&gt;：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;degree(分歧度)&lt;/strong&gt;：一個node擁有的subtree(子樹)的個數。&lt;ul&gt;
&lt;li&gt;圖四，A的degree為&lt;span class="math"&gt;\(3\)&lt;/span&gt;，F的degree為&lt;span class="math"&gt;\(2\)&lt;/span&gt;，N的degree為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;root(樹根)&lt;/strong&gt;：樹中最上層的node，也是唯一一個其parent為&lt;strong&gt;NULL&lt;/strong&gt;的node。&lt;ul&gt;
&lt;li&gt;圖四，A即為root。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;leaf&lt;/strong&gt;：沒有child/subtree的node稱為leaf node。&lt;ul&gt;
&lt;li&gt;圖四，G、H、J、K、L、M、N皆為leaf node。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;external node&lt;/strong&gt;：沒有child的node。因此，leaf node與external node同義。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;internal node&lt;/strong&gt;：至少有一個child的node，稱為internal node。&lt;ul&gt;
&lt;li&gt;圖四，A、B、C、D、E、F、I皆為internal node。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f9.png?raw=true" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：這是一棵普通的樹。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;針對&lt;strong&gt;樹&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;parent&lt;/strong&gt; &amp;lt;--&amp;gt; &lt;strong&gt;child&lt;/strong&gt;：以pointer說明，被指向者(pointed)為child，指向者(point to)為parent。&lt;ul&gt;
&lt;li&gt;圖四，A為C的parent，C為A的child；E為K的parent，K為E的child。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;siblings&lt;/strong&gt;：擁有相同parent的node們，互相稱兄道弟。&lt;ul&gt;
&lt;li&gt;圖四，B、C、D共同的parent為A，那麼B、C、D即為彼此的&lt;strong&gt;sibling&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;descendant(子嗣)&lt;/strong&gt;：圖四中，站在A，所有能夠以「parent指向child」的方式找到的node，皆稱為A的descendant，因此整棵樹除了A以外皆為A的descendant。&lt;ul&gt;
&lt;li&gt;站在F，能夠以「parent指向child」找到的node有L、M，則稱L、M為F的descendant。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ancestor(祖先)&lt;/strong&gt;：圖四中，站在K，所有能夠以「尋找parent」的方式找到的node，皆稱為K的ancestor，因此，E、B、A皆為K的ancestor。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path(路徑)&lt;/strong&gt;：由descendant與ancestor關係連結成的edge，例如A-B-E-K、A-C-F-N。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;level&lt;/strong&gt;：定義root的level為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，其餘node的level為其parent的level加一。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height of node&lt;/strong&gt;：某一node與其最長path上之descendant leaf node之間的edge數。&lt;ul&gt;
&lt;li&gt;例如，F的height為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，D的height為&lt;span class="math"&gt;\(2\)&lt;/span&gt;，leaf node的height為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height of tree&lt;/strong&gt;：樹的height即為root的height。&lt;ul&gt;
&lt;li&gt;圖四中，樹的height為A的height，等於&lt;span class="math"&gt;\(3\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;depth&lt;/strong&gt;：某一node與root之間的edge數。&lt;ul&gt;
&lt;li&gt;例如，F的depth為&lt;span class="math"&gt;\(2\)&lt;/span&gt;，L的depth為&lt;span class="math"&gt;\(3\)&lt;/span&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以想像的是，在樹中的&lt;strong&gt;traversal&lt;/strong&gt;(尋訪)之時間複雜度(time complexity)會與&lt;strong&gt;height&lt;/strong&gt;(樹高)有關。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="definition"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;定義&lt;/h2&gt;
&lt;p&gt;以下列出兩種互相等價的Tree(樹)的定義：  &lt;/p&gt;
&lt;p&gt;A. &lt;strong&gt;Tree(樹)&lt;/strong&gt;是由一個或多個節點所組成的有限集合，並且滿足：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在且只有一個稱為&lt;code&gt;root&lt;/code&gt;(樹根)的節點；&lt;/li&gt;
&lt;li&gt;其餘的節點可以分割成任意正整數個(包含零個)互斥(disjoint)的集合：&lt;span class="math"&gt;\(T_1、...、T_n\)&lt;/span&gt;，其中每一個集合也都滿足樹的定義，這些集合又稱為這棵樹的&lt;strong&gt;subtree(子樹)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;B. &lt;strong&gt;Tree(樹)&lt;/strong&gt;是由一個或多個nodes/vertices以及edge所組成，而且沒有cycle的集合(set)。  &lt;/p&gt;
&lt;p&gt;在圖三(d)中，曾出現&lt;strong&gt;Forest(樹林)&lt;/strong&gt;，其定義也很直觀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由&lt;span class="math"&gt;\(n\geq 0\)&lt;/span&gt;棵彼此互斥(disjoint)的Tree(樹)所形成的集合(Set)，即稱為Forest(樹林)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="forest" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f10.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：Forest(樹林)由多個Tree(樹)所組成，可以用來表示互斥集合(disjoint set)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;實務上，要以程式碼實作一棵樹，常用的手法為：先以&lt;code&gt;class TreeNode&lt;/code&gt;(或是&lt;code&gt;struct&lt;/code&gt;)定義出每顆node能夠指向多少subtree、攜帶哪些資料形態，再以另一個&lt;code&gt;class Tree&lt;/code&gt;表示整棵樹，並以&lt;code&gt;root&lt;/code&gt;作為樹的存取點：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 以下表示每一個node有四個pointer指向child&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;whatever&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;works&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// node所攜帶的information&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;data2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 讓class Tree能夠存取TreeNode的private data&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="set"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;集合關係&lt;/h2&gt;
&lt;p&gt;Tree(樹)位居承先啟後的重要戰略位置，圖六是常見的與Tree有關的資料結構之集合關係圖：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f11.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：與Tree(樹)相關的資料結構之集合關係。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;本篇介紹的Tree(樹)並沒有限制child/ subtree的個數，理論上可以有多到超過記憶體空間的child node。  &lt;/p&gt;
&lt;p&gt;然而在實務上，較常使用每個node至多只有兩個child的樹，稱為&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;&lt;strong&gt;Binary Tree&lt;/strong&gt;(二元樹)&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;從Binary Tree再增加「鍵值(&lt;strong&gt;Key&lt;/strong&gt;)大小規則」，即得到&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;&lt;strong&gt;Binary Search Tree&lt;/strong&gt;(BST，二元搜尋樹)&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;以BST為基礎，在每個node上添加顏色(紅與黑)用以平衡樹的&lt;strong&gt;height&lt;/strong&gt;，以減短搜尋時間，這種樹稱為&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;&lt;strong&gt;Red Black Tree&lt;/strong&gt;(RBT，紅黑樹)&lt;/a&gt;。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常見的平衡樹(balanced tree)還有：&lt;strong&gt;AVL tree&lt;/strong&gt;、&lt;strong&gt;2-3-4 tree&lt;/strong&gt;、&lt;strong&gt;Splay tree&lt;/strong&gt;等等，請參考：&lt;a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree"&gt;Wikipedia：Self-balancing binary search tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一個方向，若打破「不能存在cycle」的限制，則從Tree推廣至&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;&lt;strong&gt;圖(Graph)&lt;/strong&gt;&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;在接下來的文章將先以縮小集合的方向依序介紹：Binary Tree、BST、RBT，再進入Graph(圖)這個更複雜的主題。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://program-lover.blogspot.tw/2008/12/tree.html"&gt;Infinite Loop：【演算】樹 - Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29"&gt;Wikipedia：Tree(data structure)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree"&gt;Wikipedia：Self-balancing binary search tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回到目錄：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html"&gt;目錄：演算法與資料結構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category></entry></feed>
<!DOCTYPE html>
<html lang="zh-hant">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">


        <title>Binary Search Tree: Sort(排序)、Delete(刪除資料)</title>

            <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Ordinary Days Full Atom Feed" />
            <link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" type="application/atom+xml" rel="alternate" title="Ordinary Days Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="http://alrightchiu.github.io/SecondRound/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="C++" />
        <meta name="tags" contents="Binary Search Tree(二元搜尋樹)" />


	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Ordinary Days">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html">
	<meta property="og:title" content="Binary Search Tree: Sort(排序)、Delete(刪除資料)">
	<meta property="og:description" content="">
	<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/">
	<meta property="article:published_time" content="2016-01-15 21:27:00+08:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://alrightchiu.github.io/SecondRound/">Ordinary Days</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                        <li><a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a></li>
                        <li><a href="http://alrightchiu.github.io/SecondRound/categories.html">Categories</a></li>
                        <li><a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a></li>

                            <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html">About</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('http://alrightchiu.github.io/SecondRound/theme/images/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Binary Search Tree: Sort(排序)、Delete(刪除資料)</h1>
                        <span class="meta">Posted by
                                <a href="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">Chiu CC</a>
                             on  1 15, 2016
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p></br></p>
<h6><strong>先備知識與注意事項</strong></h6>
<p>由於Sort與Delete會用到先前在<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#in_parent">Binary Tree：Traversal介紹過的Leftmost()、Rightmost()、Successor()與Predecessor()</a>，因此建議在開始閱讀本篇文章之前，先復習上述四個函式操作。  </p>
<p>在文章最後將會附上四個函式的範例程式碼。</p>
<hr />
<h2>目錄</h2>
<ul>
<li><a href="#sort">Sort(排序)</a></li>
<li><a href="#delete">BST::DeleteBST(刪除資料)</a></li>
<li><a href="#main">main()</a></li>
<li><a href="#4function">Leftmost、Rightmost、Successor、Predecessor範例程式碼</a></li>
<li><a href="#ref">參考資料</a></li>
<li><a href="#tree_series">Tree系列文章</a></li>
</ul>
<p><a name="sort"></a></p>
<h2><strong>Sort(排序)</strong></h2>
<p>讀者可能會發現，在<code>class BST</code>的定義中，根本就沒有類似<code>SortBST()</code>的函式，沒錯，因為在BST中，每一個<code>Treenode</code>都有<span class="math">\(Key(L)&lt;Key(Current)&lt;Key(R)\)</span>的性質，這正好與Inorder(LVR)之順序相同，因此，對整棵樹進行Inorder Traversal，就能夠對資料由小到大(依照Key)進行Visiting。</p>
<p>以上一篇<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao">Binary Search Tree: Search()、Insert()</a>的<code>main()</code>所建立的BST為例，如圖一，要將此樹中的資料按照Key之順序由小到大印出，只需要對整棵樹做一次Inorder Traversal即可。</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete1.png?raw=true" /></p>
<p><strong>圖一：。</strong><br />
</center></p>
<p>以下範例程式，將Visiting用作列印資料(print)：</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="kt">void</span> <span class="n">BST</span><span class="o">::</span><span class="n">InorderPrint</span><span class="p">(){</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">current</span> <span class="o">=</span> <span class="n">Leftmost</span><span class="p">(</span><span class="n">root</span><span class="p">);</span></span>
<span class="code-line">    <span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="p">){</span></span>
<span class="code-line">        <span class="c1">// Visiting</span></span>
<span class="code-line">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>    </span>
<span class="code-line">        <span class="n">current</span> <span class="o">=</span> <span class="n">Successor</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>            <span class="c1">// 移動至current的Successor</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p>output:</p>
<div class="highlight"><pre><span class="code-line"><span class="err">克林</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="err">龜仙人</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="err">比克</span><span class="p">(</span><span class="mi">513</span><span class="p">)</span> <span class="err">悟空</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> </span>
</pre></div>


<p><a name="delete"></a></p>
<h2><strong>BST::DeleteBST(刪除資料)</strong></h2>
<p>要在BST上執行刪除資料(被刪除的node稱為A)，必須讓刪除A後的BST仍然維持BST的性質，因此，所有「具有指向A的pointer」之node(也就是A的<code>parent</code>、A的<code>leftchild</code>與A的<code>rightchild</code>)都必須指向新的記憶體位置。</p>
<p>刪除資料的工作，根據欲刪除之node「有幾個child pointer」分成三類：</p>
<ol>
<li>Case1：欲刪除之node沒有<code>child pointer</code>；</li>
<li>Case2：欲刪除之node只有一個<code>child pointer</code>(不論是<code>leftchild</code>或<code>rightchild</code>)；</li>
<li>Case3：欲刪除之node有兩個<code>child pointer</code>。</li>
</ol>
<p>以圖二(a)為例，依序刪除撒旦、弗力札與西魯：</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete2.png?raw=true" /></p>
<p><strong>圖二(a)：。</strong><br />
</center></p>
<ul>
<li><strong>Case1</strong>：由於撒旦沒有<code>child pointer</code>，因此只要考慮撒旦的parent(普烏)，將普烏的<code>leftchild</code>指向<code>NULL</code>即可維持BST的正確性，如圖二(b)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete3.png?raw=true" /></p>
<p><strong>圖二(b)：。</strong><br />
</center></p>
<ul>
<li><strong>Case2</strong>：由於弗力札有一個<code>leftchild</code>(基紐)，因此在刪除弗力札之前，需要先將基紐的parent指向弗力札的<code>parent</code>(龜仙人)，並且將龜仙人的<code>rightchild</code>從原本的弗力札指向基紐，因為基紐原本就位於龜仙人的right subtree(右子樹)，因此，上述操作仍能維持BST的正確性，如圖二(c)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete4.png?raw=true" /></p>
<p><strong>圖二(c)：。</strong><br />
</center></p>
<ul>
<li>
<p><strong>Case3</strong>：由於西魯有兩個<code>child</code>，若直接刪除西魯的資料，並釋放其記憶體位置，要牽動的node較多。變通的祕訣就是「找替身」，原本要刪西魯，但是實際上是釋放西魯的「Successor(達爾)」的記憶體位置(或是「Predecessor(16號)」)，最後再把「Successor(達爾)」(或是「Predecessor(16號)」)的資料放回到西魯的記憶體位置上，又因為BST的特徵，所有「具有兩個<code>child</code>」的node的Successor或是Predecessor一定是leaf node或是只有一個<code>child</code>，如此，便回到如同撒旦與弗力札「至多只有一個<code>child</code>」的情境。 </p>
</li>
<li>
<p>驗證「具有兩個<code>child</code>的node的Successor或是Predecessor一定是leaf node或是只有一個<code>child</code>」：若某個node有兩個<code>child</code>，則Successor找的是「right subtree中Key最小的node」，而Predecessor找的是「left subtree中Key最大的node」，因此Successor和Predecessor必定不會同時也有兩個child。以圖二(d)為例：</p>
<ul>
<li>龜仙人(8)的Predecessor為克林(2)，Successor為基紐(69)；</li>
<li>比克(513)的Predecessor為基紐(69)，Successor為16號(520)；</li>
<li>悟飯(888)的Predecessor為達爾(881)，Successor為普烏(999)；</li>
</ul>
</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete5.png?raw=true" /></p>
<p><strong>圖二(d)：。</strong><br />
</center></p>
<ul>
<li>現欲刪除西魯，就去找西魯的Successor(達爾)當做替身，因為達爾沒有<code>child</code>，其刪除方法便如同上述刪除撒旦的方法，如圖二(e)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete6.png?raw=true" /></p>
<p><strong>圖二(e)：。</strong><br />
</center></p>
<ul>
<li>最後再將達爾的資料放進原先存放西魯資料的記憶體位置，便完成了刪除西魯的操作，如圖二(f)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete7.png?raw=true" /></p>
<p><strong>圖二(f)：。</strong><br />
</center></p>
<p><code>BST::DeleteBST()</code>之範例程式碼分成以下幾個步驟：：</p>
<ol>
<li>先確認BST中有沒有要刪除的node；</li>
<li>把要刪除的node調整成「至多只有一個<code>child</code>」；</li>
<li>把要刪除的node的<code>child</code>指向新的<code>parent</code>；</li>
<li>把要刪除的node的<code>parent</code>指向新的<code>child</code>；</li>
<li>若實際上刪除的是「替身」，再把替身的資料放回BST中。</li>
</ol>
<p>即完成BST之刪除資料操作。</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="kt">void</span> <span class="n">BST</span><span class="o">::</span><span class="n">DeleteBST</span><span class="p">(</span><span class="kt">int</span> <span class="n">KEY</span><span class="p">){</span>               <span class="c1">// 要刪除具有KEY的node</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">delete_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">delete_node</span> <span class="o">=</span> <span class="n">Search</span><span class="p">(</span><span class="n">KEY</span><span class="p">);</span>              <span class="c1">// 先確認BST中是否有具有KEY的node</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">delete_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;data not found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span></span>
<span class="code-line">        <span class="k">return</span><span class="p">;</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// 真正要被刪除並釋放記憶體的node</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// 要被刪除的node的child</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">        <span class="n">y</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">else</span></span>
<span class="code-line">        <span class="n">y</span> <span class="o">=</span> <span class="n">Successor</span><span class="p">(</span><span class="n">delete_node</span><span class="p">);</span></span>
<span class="code-line">                                            <span class="c1">// 經過以上的if-else, y至多只有一個child</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>               <span class="c1">// 將x設成y的child, 可能是有效記憶體, 也有可能是NULL</span></span>
<span class="code-line">        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">else</span></span>
<span class="code-line">        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>                          </span>
<span class="code-line">        <span class="n">x</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>              <span class="c1">// 此即為圖二(c)中, 基紐指向龜仙人的實作方式</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>                  <span class="c1">// 再將要被刪除的node之parent指向新的child</span></span>
<span class="code-line">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">)</span></span>
<span class="code-line">        <span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">else</span></span>
<span class="code-line">        <span class="n">y</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">delete_node</span><span class="p">)</span> <span class="p">{</span>                 <span class="c1">// y即是達爾, delete_node即是西魯</span></span>
<span class="code-line">        <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">SetKey</span><span class="p">(</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">());</span>   <span class="c1">// 實際被刪除的是y, 因此最後要再將y的資料放進delete_node的記憶體位置</span></span>
<span class="code-line">        <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">SetElement</span><span class="p">(</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">GetElement</span><span class="p">());</span></span>
<span class="code-line">    <span class="p">}</span>   </span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p><a name="main"></a></p>
<h2><strong>main()</strong></h2>
<p>延續上一篇文章<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao">Binary Search Tree: Search()、Insert()</a>的<code>main()</code>，加入<code>BST::DeleteBST</code>，把龜仙人(8)刪除，應該會得到如圖三的BST，比克(513)成為新的<code>root</code>：</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete8.png?raw=true" /></p>
<p><strong>圖三：。</strong><br />
</center></p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span></span>
<span class="code-line">    <span class="n">BST</span> <span class="n">b1</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="n">n1</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="s">&quot;龜仙人&quot;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="n">n2</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="s">&quot;悟空&quot;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="n">n3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;克林&quot;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="n">n4</span><span class="p">(</span><span class="mi">513</span><span class="p">,</span><span class="s">&quot;比克&quot;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">n1</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">n2</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">n3</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">n4</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">DeleteBST</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>          <span class="c1">// 刪除龜仙人</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InorderPrint</span><span class="p">();</span></span>
<span class="code-line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p>output:</p>
<div class="highlight"><pre><span class="code-line"><span class="err">克林</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="err">比克</span><span class="p">(</span><span class="mi">513</span><span class="p">)</span> <span class="err">悟空</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> </span>
</pre></div>


<p><a name="4function"></a></p>
<h2><strong>Leftmost、Rightmost、Successor、Predecessor範例程式碼</strong></h2>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="n">TreeNode</span><span class="o">*</span> <span class="n">BST</span><span class="o">::</span><span class="n">Leftmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span></span>
<span class="code-line">    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">return</span> <span class="n">current</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
<span class="code-line"><span class="n">TreeNode</span><span class="o">*</span> <span class="n">BST</span><span class="o">::</span><span class="n">Rightmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span></span>
<span class="code-line">    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">return</span> <span class="n">current</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
<span class="code-line"><span class="n">TreeNode</span><span class="o">*</span> <span class="n">BST</span><span class="o">::</span><span class="n">Successor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">        <span class="k">return</span> <span class="n">Leftmost</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">);</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">new_node</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">while</span> <span class="p">(</span><span class="n">new_node</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">current</span> <span class="o">==</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">        <span class="n">current</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span></span>
<span class="code-line">        <span class="n">new_node</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line">    <span class="k">return</span> <span class="n">new_node</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
<span class="code-line"><span class="n">TreeNode</span><span class="o">*</span> <span class="n">BST</span><span class="o">::</span><span class="n">Predecessor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">){</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">        <span class="k">return</span> <span class="n">Rightmost</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">);</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">new_node</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">while</span> <span class="p">(</span><span class="n">new_node</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">current</span> <span class="o">==</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">        <span class="n">current</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span></span>
<span class="code-line">        <span class="n">new_node</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line">    <span class="k">return</span> <span class="n">new_node</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p></br></p>
<p>以上便是BST中<code>BST::DeleteBST()</code>之介紹，關鍵即在Successor與Predecessor。  </p>
<p>在接下來將介紹的Red Black Tree(RBT，紅黑樹)中，BST的<code>Insert()</code>與<code>Delete()</code>會再次出現，不過，需要再「多一道手續」以滿足RBT的性質。</p>
<p>最後，因為RBT的圖比較複雜，所以圈圈裏面放名字會太擠，有礙觀瞻，因此要忍痛讓「悟空」、「克林」退居幕後，直接在node裡面放上Key。 
不過，相信透過這三篇BST的介紹，讀者對七龍珠也有一定程度的了解，後面的部分一定可以靠自學來搜集龍珠的。</p>
<p>cha la head cha la～～</p>
<p></br>
<a name="ref"></a></p>
<h6><strong>參考資料</strong>：</h6>
<ul>
<li><a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">Introduction to Algorithms</a> </li>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++</a></li>
</ul>
<p><a name="tree_series"></a></p>
<h2><strong>Tree系列文章</strong></h2>
<ul>
<li><a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html">Tree(樹): Intro(簡介)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html">Binary Tree: Intro(簡介)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html">Binary Tree: Traversal(尋訪)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">Binary Tree: 建立一棵Binary Tree</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html">Binary Search Tree: Intro(簡介)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html">Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html">Binary Search Tree: Sort(排序)、Delete(刪除資料)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html">Red Black Tree: Intro(簡介)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html">Red Black Tree: Rotation(旋轉)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Insert(新增資料)與Fixup(修正)</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Delete(刪除資料)與Fixup(修正)</a></li>
</ul>
<p></br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </article>

        <div class="tags">
            <p>tags: <a href="http://alrightchiu.github.io/SecondRound/tag/c.html">C++</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/binary-search-treeer-yuan-sou-xun-shu.html">Binary Search Tree(二元搜尋樹)</a>, </p>
        </div>

<hr>
<div class="sharing">
</div>
    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="https://github.com/alrightchiu">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="http://alrightchiu.github.io/SecondRound/theme/js/clean-blog.min.js"></script>

</body>

</html>